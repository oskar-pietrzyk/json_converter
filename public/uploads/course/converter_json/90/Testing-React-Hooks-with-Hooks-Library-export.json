{"id":85,"title":"Testing React Hooks with Hooks Library","estimated_time":12,"user_id":null,"passing_threshold":80,"published_at":"2021-01-18T11:54:37.635+01:00","has_unpublished_changes":false,"has_certificate":false,"external_id":null,"draft_external_id":null,"external_status":"inapplicable","course_type":"bridge","enrollments_count":4,"domain_id":1,"sub_account_id":1,"open_book":null,"description":null,"third_party_course_id":null,"external_course_id":null,"quizzes_count":0,"external_status_message":null,"manual_estimated_time":false,"show_correct_response":true,"max_quiz_attempts":null,"continuing_education_credits":null,"archived_at":null,"config":{},"unpublished_at":null,"external_learning_standard":null,"available_offline":false,"external_version":null,"ordered_slides":[{"id":799,"position":1,"new_position":1,"published_attributes":{"type":"slide","title":"Difficulties with testing hooks","body":null,"serialized_body":"\u003cp\u003eReact Hooks from the outside might look similar to regular functions. What makes them different is that they use other hooks. As you know, hooks can only be used inside functional React component.\u003c/p\u003e\u003cp\u003eTesting React Hooks is especially difficult, because we need to check the returned value of our hook and render it inside component at the same time.\u003c/p\u003e\u003cp\u003eThis problem is solved by @testing-library/react-hooks.\u003c/p\u003e","structured_body":{"blocks":[{"key":"69ru8","text":"React Hooks from the outside might look similar to regular functions. What makes them different is that they use other hooks. As you know, hooks can only be used inside functional React component.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a3ji","text":"Testing React Hooks is especially difficult, because we need to check the returned value of our hook and render it inside component at the same time.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7e2uh","text":"This problem is solved by @testing-library/react-hooks.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"answers":[],"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","title":"Difficulties with testing hooks","body":null,"serialized_body":"\u003cp\u003eReact Hooks from the outside might look similar to regular functions. What makes them different is that they use other hooks. As you know, hooks can only be used inside functional React component.\u003c/p\u003e\u003cp\u003eTesting React Hooks is especially difficult, because we need to check the returned value of our hook and render it inside component at the same time.\u003c/p\u003e\u003cp\u003eThis problem is solved by @testing-library/react-hooks.\u003c/p\u003e","structured_body":{"blocks":[{"key":"69ru8","text":"React Hooks from the outside might look similar to regular functions. What makes them different is that they use other hooks. As you know, hooks can only be used inside functional React component.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a3ji","text":"Testing React Hooks is especially difficult, because we need to check the returned value of our hook and render it inside component at the same time.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7e2uh","text":"This problem is solved by @testing-library/react-hooks.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"answers":[],"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":800,"position":2,"new_position":2,"published_attributes":{"type":"slide","answers":[],"title":"Creating useToggle hook","body":null,"serialized_body":"\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { useState, useCallback } from \u0026#x27;react\u0026#x27;;\n\nconst useToggle = (initialValue = false) =\u0026gt; {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() =\u0026gt; {\n    setValue((prev) =\u0026gt; !prev);\n  }, []);\n\n  return { value, toggle };\n};\n\nexport default useToggle;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003euseToggle will take the boolean value and flip it every time you call toggle.\n\u003c/p\u003e","structured_body":{"blocks":[{"key":"2dp3s","text":"import { useState, useCallback } from 'react';\n\nconst useToggle = (initialValue = false) =\u003e {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() =\u003e {\n    setValue((prev) =\u003e !prev);\n  }, []);\n\n  return { value, toggle };\n};\n\nexport default useToggle;","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9nre4","text":"useToggle will take the boolean value and flip it every time you call toggle.\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Creating useToggle hook","body":null,"serialized_body":"\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { useState, useCallback } from \u0026#x27;react\u0026#x27;;\n\nconst useToggle = (initialValue = false) =\u0026gt; {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() =\u0026gt; {\n    setValue((prev) =\u0026gt; !prev);\n  }, []);\n\n  return { value, toggle };\n};\n\nexport default useToggle;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003euseToggle will take the boolean value and flip it every time you call toggle.\n\u003c/p\u003e","structured_body":{"blocks":[{"key":"2dp3s","text":"import { useState, useCallback } from 'react';\n\nconst useToggle = (initialValue = false) =\u003e {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() =\u003e {\n    setValue((prev) =\u003e !prev);\n  }, []);\n\n  return { value, toggle };\n};\n\nexport default useToggle;","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9nre4","text":"useToggle will take the boolean value and flip it every time you call toggle.\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":801,"position":3,"new_position":3,"published_attributes":{"type":"slide","answers":[],"title":"Setting up tests for useToggle","body":null,"serialized_body":"\u003cp\u003eLet\u0026#x27;s think what we want to test in this hook.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { renderHook, act } from \u0026#x27;@testing-library/react-hooks\u0026#x27;;\n\nimport useToggle from \u0026#x27;./useToggle\u0026#x27;;\n\ndescribe(\u0026#x27;useToggle\u0026#x27;, () =\u0026gt; {\n  it(\u0026#x27;should return false by default\u0026#x27;, () =\u0026gt; {\n\n  });\n\n  it(\u0026#x27;should return initialValue if provideed\u0026#x27;, () =\u0026gt; {\n\n  });\n\n  it(\u0026#x27;should flip the value when toggle is called\u0026#x27;, () =\u0026gt; {\n\n  });\n});\u003c/code\u003e\u003c/pre\u003e","structured_body":{"blocks":[{"key":"85vfm","text":"Let's think what we want to test in this hook.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cbg3i","text":"import { renderHook, act } from '@testing-library/react-hooks';\n\nimport useToggle from './useToggle';\n\ndescribe('useToggle', () =\u003e {\n  it('should return false by default', () =\u003e {\n\n  });\n\n  it('should return initialValue if provideed', () =\u003e {\n\n  });\n\n  it('should flip the value when toggle is called', () =\u003e {\n\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Setting up tests for useToggle","body":null,"serialized_body":"\u003cp\u003eLet\u0026#x27;s think what we want to test in this hook.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { renderHook, act } from \u0026#x27;@testing-library/react-hooks\u0026#x27;;\n\nimport useToggle from \u0026#x27;./useToggle\u0026#x27;;\n\ndescribe(\u0026#x27;useToggle\u0026#x27;, () =\u0026gt; {\n  it(\u0026#x27;should return false by default\u0026#x27;, () =\u0026gt; {\n\n  });\n\n  it(\u0026#x27;should return initialValue if provideed\u0026#x27;, () =\u0026gt; {\n\n  });\n\n  it(\u0026#x27;should flip the value when toggle is called\u0026#x27;, () =\u0026gt; {\n\n  });\n});\u003c/code\u003e\u003c/pre\u003e","structured_body":{"blocks":[{"key":"85vfm","text":"Let's think what we want to test in this hook.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cbg3i","text":"import { renderHook, act } from '@testing-library/react-hooks';\n\nimport useToggle from './useToggle';\n\ndescribe('useToggle', () =\u003e {\n  it('should return false by default', () =\u003e {\n\n  });\n\n  it('should return initialValue if provideed', () =\u003e {\n\n  });\n\n  it('should flip the value when toggle is called', () =\u003e {\n\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":802,"position":4,"new_position":4,"published_attributes":{"type":"slide","answers":[],"title":"Rendering hook","body":null,"serialized_body":"\u003cp\u003eFirst test should simply call useToggle and assert the returned value is false. Let\u0026#x27;s do it using renderHook from @testing-library/react-hooks.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should return false by default\u0026#x27;, () =\u0026gt; {\n  const { result } = renderHook(() =\u0026gt; useToggle());\n\n  expect(result.current.value).toBe(false);\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe used renderHook and provided a function which calls our hook. It returns an object with result property which we will use in tests.\u003c/p\u003e\u003cp\u003eTo access current value of hook you need to use result.current, similar to how you would use value from useRef. At the end we grab value and check if it\u0026#x27;s false.\u003c/p\u003e","structured_body":{"blocks":[{"key":"5iecj","text":"First test should simply call useToggle and assert the returned value is false. Let's do it using renderHook from @testing-library/react-hooks.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"42qgf","text":"it('should return false by default', () =\u003e {\n  const { result } = renderHook(() =\u003e useToggle());\n\n  expect(result.current.value).toBe(false);\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4t5k3","text":"We used renderHook and provided a function which calls our hook. It returns an object with result property which we will use in tests.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e7f83","text":"To access current value of hook you need to use result.current, similar to how you would use value from useRef. At the end we grab value and check if it's false.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Rendering hook","body":null,"serialized_body":"\u003cp\u003eFirst test should simply call useToggle and assert the returned value is false. Let\u0026#x27;s do it using renderHook from @testing-library/react-hooks.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should return false by default\u0026#x27;, () =\u0026gt; {\n  const { result } = renderHook(() =\u0026gt; useToggle());\n\n  expect(result.current.value).toBe(false);\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe used renderHook and provided a function which calls our hook. It returns an object with result property which we will use in tests.\u003c/p\u003e\u003cp\u003eTo access current value of hook you need to use result.current, similar to how you would use value from useRef. At the end we grab value and check if it\u0026#x27;s false.\u003c/p\u003e","structured_body":{"blocks":[{"key":"5iecj","text":"First test should simply call useToggle and assert the returned value is false. Let's do it using renderHook from @testing-library/react-hooks.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"42qgf","text":"it('should return false by default', () =\u003e {\n  const { result } = renderHook(() =\u003e useToggle());\n\n  expect(result.current.value).toBe(false);\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4t5k3","text":"We used renderHook and provided a function which calls our hook. It returns an object with result property which we will use in tests.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e7f83","text":"To access current value of hook you need to use result.current, similar to how you would use value from useRef. At the end we grab value and check if it's false.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":803,"position":5,"new_position":5,"published_attributes":{"type":"slide","answers":[],"title":"Rendering hook with argument","body":null,"serialized_body":"\u003cp\u003eFor the next test we want to assert if useToggle returns provided initialValue by default.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should return initialValue if provided\u0026#x27;, () =\u0026gt; {\n  const { result: result1 } = renderHook(() =\u0026gt; useToggle(false));\n  const { result: result2 } = renderHook(() =\u0026gt; useToggle(true));\n\n  expect(result1.current.value).toBe(false);\n  expect(result2.current.value).toBe(true);\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time we rendered two hooks at the same time. Just to be sure if both false and true will work as initialValue.\u003c/p\u003e","structured_body":{"blocks":[{"key":"d8nge","text":"For the next test we want to assert if useToggle returns provided initialValue by default.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d11bs","text":"it('should return initialValue if provided', () =\u003e {\n  const { result: result1 } = renderHook(() =\u003e useToggle(false));\n  const { result: result2 } = renderHook(() =\u003e useToggle(true));\n\n  expect(result1.current.value).toBe(false);\n  expect(result2.current.value).toBe(true);\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5g4me","text":"This time we rendered two hooks at the same time. Just to be sure if both false and true will work as initialValue.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Rendering hook with argument","body":null,"serialized_body":"\u003cp\u003eFor the next test we want to assert if useToggle returns provided initialValue by default.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should return initialValue if provided\u0026#x27;, () =\u0026gt; {\n  const { result: result1 } = renderHook(() =\u0026gt; useToggle(false));\n  const { result: result2 } = renderHook(() =\u0026gt; useToggle(true));\n\n  expect(result1.current.value).toBe(false);\n  expect(result2.current.value).toBe(true);\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time we rendered two hooks at the same time. Just to be sure if both false and true will work as initialValue.\u003c/p\u003e","structured_body":{"blocks":[{"key":"d8nge","text":"For the next test we want to assert if useToggle returns provided initialValue by default.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d11bs","text":"it('should return initialValue if provided', () =\u003e {\n  const { result: result1 } = renderHook(() =\u003e useToggle(false));\n  const { result: result2 } = renderHook(() =\u003e useToggle(true));\n\n  expect(result1.current.value).toBe(false);\n  expect(result2.current.value).toBe(true);\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5g4me","text":"This time we rendered two hooks at the same time. Just to be sure if both false and true will work as initialValue.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":804,"position":6,"new_position":6,"published_attributes":{"type":"slide","answers":[],"title":"Testing interactions with hook","body":null,"serialized_body":"\u003cp\u003eThe last test. This time we will interact with our hook by calling toggle. When we do any interactions we need to wrap them in act.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should flip the value when toggle is called\u0026#x27;, () =\u0026gt; {\n  const { result } = renderHook(() =\u0026gt; useToggle(false));\n\n  act(() =\u0026gt; {\n    result.current.toggle();\n  });\n\n  expect(result.current.value).toBe(true);\n\n  act(() =\u0026gt; {\n    result.current.toggle();\n  });\n\n  expect(result.current.value).toBe(false);\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe rendered our hook will initial value set to false.\u003c/p\u003e\u003cp\u003eThen we called toggle from hook and checked if its value was changed to true.\u003c/p\u003e\u003cp\u003eAs you can see, it had to be wrapper in act from @testing-library/react-hooks.\u003c/p\u003e\u003cp\u003eThen we did the same thing again, to check if the value will be changed to false.\u003c/p\u003e","structured_body":{"blocks":[{"key":"60ln7","text":"The last test. This time we will interact with our hook by calling toggle. When we do any interactions we need to wrap them in act.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4lbq7","text":"it('should flip the value when toggle is called', () =\u003e {\n  const { result } = renderHook(() =\u003e useToggle(false));\n\n  act(() =\u003e {\n    result.current.toggle();\n  });\n\n  expect(result.current.value).toBe(true);\n\n  act(() =\u003e {\n    result.current.toggle();\n  });\n\n  expect(result.current.value).toBe(false);\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fra6k","text":"We rendered our hook will initial value set to false.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5mnlp","text":"Then we called toggle from hook and checked if its value was changed to true.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4k62r","text":"As you can see, it had to be wrapper in act from @testing-library/react-hooks.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4j2en","text":"Then we did the same thing again, to check if the value will be changed to false.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Testing interactions with hook","body":null,"serialized_body":"\u003cp\u003eThe last test. This time we will interact with our hook by calling toggle. When we do any interactions we need to wrap them in act.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should flip the value when toggle is called\u0026#x27;, () =\u0026gt; {\n  const { result } = renderHook(() =\u0026gt; useToggle(false));\n\n  act(() =\u0026gt; {\n    result.current.toggle();\n  });\n\n  expect(result.current.value).toBe(true);\n\n  act(() =\u0026gt; {\n    result.current.toggle();\n  });\n\n  expect(result.current.value).toBe(false);\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe rendered our hook will initial value set to false.\u003c/p\u003e\u003cp\u003eThen we called toggle from hook and checked if its value was changed to true.\u003c/p\u003e\u003cp\u003eAs you can see, it had to be wrapper in act from @testing-library/react-hooks.\u003c/p\u003e\u003cp\u003eThen we did the same thing again, to check if the value will be changed to false.\u003c/p\u003e","structured_body":{"blocks":[{"key":"60ln7","text":"The last test. This time we will interact with our hook by calling toggle. When we do any interactions we need to wrap them in act.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4lbq7","text":"it('should flip the value when toggle is called', () =\u003e {\n  const { result } = renderHook(() =\u003e useToggle(false));\n\n  act(() =\u003e {\n    result.current.toggle();\n  });\n\n  expect(result.current.value).toBe(true);\n\n  act(() =\u003e {\n    result.current.toggle();\n  });\n\n  expect(result.current.value).toBe(false);\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fra6k","text":"We rendered our hook will initial value set to false.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5mnlp","text":"Then we called toggle from hook and checked if its value was changed to true.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4k62r","text":"As you can see, it had to be wrapper in act from @testing-library/react-hooks.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4j2en","text":"Then we did the same thing again, to check if the value will be changed to false.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":805,"position":7,"new_position":7,"published_attributes":{"type":"slide","answers":[],"title":"Creating useData hook","body":null,"serialized_body":"\u003cp\u003eNow we will test more complicated hook. It will fetch some data from external API using provided id and return the data along with isLoading state.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { useEffect, useState } from \u0026#x27;react\u0026#x27;;\n\nimport api from \u0026#x27;./api\u0026#x27;;\n\nconst useData = (id) =\u0026gt; {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() =\u0026gt; {\n    setIsLoading(true);\n    api(id).then((data) =\u0026gt; {\n      setIsLoading(false);\n      setData(data);\n    });\n  }, [id]);\n\n  return {\n    data,\n    isLoading,\n  };\n};\n\nexport default useData;\u003c/code\u003e\u003c/pre\u003e","structured_body":{"blocks":[{"key":"et7qh","text":"Now we will test more complicated hook. It will fetch some data from external API using provided id and return the data along with isLoading state.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4bkou","text":"import { useEffect, useState } from 'react';\n\nimport api from './api';\n\nconst useData = (id) =\u003e {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() =\u003e {\n    setIsLoading(true);\n    api(id).then((data) =\u003e {\n      setIsLoading(false);\n      setData(data);\n    });\n  }, [id]);\n\n  return {\n    data,\n    isLoading,\n  };\n};\n\nexport default useData;","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Creating useData hook","body":null,"serialized_body":"\u003cp\u003eNow we will test more complicated hook. It will fetch some data from external API using provided id and return the data along with isLoading state.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { useEffect, useState } from \u0026#x27;react\u0026#x27;;\n\nimport api from \u0026#x27;./api\u0026#x27;;\n\nconst useData = (id) =\u0026gt; {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() =\u0026gt; {\n    setIsLoading(true);\n    api(id).then((data) =\u0026gt; {\n      setIsLoading(false);\n      setData(data);\n    });\n  }, [id]);\n\n  return {\n    data,\n    isLoading,\n  };\n};\n\nexport default useData;\u003c/code\u003e\u003c/pre\u003e","structured_body":{"blocks":[{"key":"et7qh","text":"Now we will test more complicated hook. It will fetch some data from external API using provided id and return the data along with isLoading state.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4bkou","text":"import { useEffect, useState } from 'react';\n\nimport api from './api';\n\nconst useData = (id) =\u003e {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() =\u003e {\n    setIsLoading(true);\n    api(id).then((data) =\u003e {\n      setIsLoading(false);\n      setData(data);\n    });\n  }, [id]);\n\n  return {\n    data,\n    isLoading,\n  };\n};\n\nexport default useData;","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":806,"position":8,"new_position":8,"published_attributes":{"type":"slide","answers":[],"title":"Setting up tests for useData","body":null,"serialized_body":"\u003cp\u003eAnd as always, we create tests we will fill in.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { renderHook } from \u0026#x27;@testing-library/react-hooks\u0026#x27;;\n\nimport useData from \u0026#x27;./useData\u0026#x27;;\n\ndescribe(\u0026#x27;useData\u0026#x27;, () =\u0026gt; {\n  it(\u0026#x27;should return data\u0026#x27;, () =\u0026gt; {\n\n  });\n\n  it(\u0026#x27;should fetch new data when id is updated\u0026#x27;, () =\u0026gt; {\n\n  });\n\n  it(\u0026#x27;should update isLoading\u0026#x27;, () =\u0026gt; {\n\n  });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time we need to mock api module before we start testing our hook. I will use jest.mock. Mocking modules is explained in depth in a separate course.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003ejest.mock(\u0026#x27;./api\u0026#x27;, () =\u0026gt; (id) =\u0026gt; Promise.resolve(id));\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo simplify testing, the api module will now return a Promise which resolves with the same value we provided in the argument. This way we can see what argument api was called with.\u003c/p\u003e","structured_body":{"blocks":[{"key":"d87o","text":"And as always, we create tests we will fill in.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eqakj","text":"import { renderHook } from '@testing-library/react-hooks';\n\nimport useData from './useData';\n\ndescribe('useData', () =\u003e {\n  it('should return data', () =\u003e {\n\n  });\n\n  it('should fetch new data when id is updated', () =\u003e {\n\n  });\n\n  it('should update isLoading', () =\u003e {\n\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1tqbl","text":"This time we need to mock api module before we start testing our hook. I will use jest.mock. Mocking modules is explained in depth in a separate course.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2ehsn","text":"jest.mock('./api', () =\u003e (id) =\u003e Promise.resolve(id));","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1sr5m","text":"To simplify testing, the api module will now return a Promise which resolves with the same value we provided in the argument. This way we can see what argument api was called with.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Setting up tests for useData","body":null,"serialized_body":"\u003cp\u003eAnd as always, we create tests we will fill in.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { renderHook } from \u0026#x27;@testing-library/react-hooks\u0026#x27;;\n\nimport useData from \u0026#x27;./useData\u0026#x27;;\n\ndescribe(\u0026#x27;useData\u0026#x27;, () =\u0026gt; {\n  it(\u0026#x27;should return data\u0026#x27;, () =\u0026gt; {\n\n  });\n\n  it(\u0026#x27;should fetch new data when id is updated\u0026#x27;, () =\u0026gt; {\n\n  });\n\n  it(\u0026#x27;should update isLoading\u0026#x27;, () =\u0026gt; {\n\n  });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time we need to mock api module before we start testing our hook. I will use jest.mock. Mocking modules is explained in depth in a separate course.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003ejest.mock(\u0026#x27;./api\u0026#x27;, () =\u0026gt; (id) =\u0026gt; Promise.resolve(id));\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo simplify testing, the api module will now return a Promise which resolves with the same value we provided in the argument. This way we can see what argument api was called with.\u003c/p\u003e","structured_body":{"blocks":[{"key":"d87o","text":"And as always, we create tests we will fill in.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eqakj","text":"import { renderHook } from '@testing-library/react-hooks';\n\nimport useData from './useData';\n\ndescribe('useData', () =\u003e {\n  it('should return data', () =\u003e {\n\n  });\n\n  it('should fetch new data when id is updated', () =\u003e {\n\n  });\n\n  it('should update isLoading', () =\u003e {\n\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1tqbl","text":"This time we need to mock api module before we start testing our hook. I will use jest.mock. Mocking modules is explained in depth in a separate course.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2ehsn","text":"jest.mock('./api', () =\u003e (id) =\u003e Promise.resolve(id));","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1sr5m","text":"To simplify testing, the api module will now return a Promise which resolves with the same value we provided in the argument. This way we can see what argument api was called with.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":807,"position":9,"new_position":9,"published_attributes":{"type":"slide","answers":[],"title":"First test - waiting for hook value","body":null,"serialized_body":"\u003cp\u003eFor the first test we want to call hook with some id and observe if it will finally return the data obtained from mocked api module.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should return data\u0026#x27;, async () =\u0026gt; {\n  const { result, waitFor } = renderHook(() =\u0026gt; useData(\u0026#x27;testId\u0026#x27;));\n\n  await waitFor(() =\u0026gt; {\n    expect(result.current.data).toBe(\u0026#x27;testId\u0026#x27;);\n  });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince we deal with async data now we need to use waitFor from @testing-library/react. It will wait until result.current.data is testId.\u003c/p\u003e","structured_body":{"blocks":[{"key":"hjjm","text":"For the first test we want to call hook with some id and observe if it will finally return the data obtained from mocked api module.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cm2of","text":"it('should return data', async () =\u003e {\n  const { result, waitFor } = renderHook(() =\u003e useData('testId'));\n\n  await waitFor(() =\u003e {\n    expect(result.current.data).toBe('testId');\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ch86v","text":"Since we deal with async data now we need to use waitFor from @testing-library/react. It will wait until result.current.data is testId.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"First test - waiting for hook value","body":null,"serialized_body":"\u003cp\u003eFor the first test we want to call hook with some id and observe if it will finally return the data obtained from mocked api module.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should return data\u0026#x27;, async () =\u0026gt; {\n  const { result, waitFor } = renderHook(() =\u0026gt; useData(\u0026#x27;testId\u0026#x27;));\n\n  await waitFor(() =\u0026gt; {\n    expect(result.current.data).toBe(\u0026#x27;testId\u0026#x27;);\n  });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince we deal with async data now we need to use waitFor from @testing-library/react. It will wait until result.current.data is testId.\u003c/p\u003e","structured_body":{"blocks":[{"key":"hjjm","text":"For the first test we want to call hook with some id and observe if it will finally return the data obtained from mocked api module.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cm2of","text":"it('should return data', async () =\u003e {\n  const { result, waitFor } = renderHook(() =\u003e useData('testId'));\n\n  await waitFor(() =\u003e {\n    expect(result.current.data).toBe('testId');\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ch86v","text":"Since we deal with async data now we need to use waitFor from @testing-library/react. It will wait until result.current.data is testId.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":808,"position":10,"new_position":10,"published_attributes":{"type":"slide","answers":[],"title":"Second test - rerendering hook","body":null,"serialized_body":"\u003cp\u003eIn the next test we want to observe rerendering hook with new id and see if it updates the returned data.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should fetch new data when id is updated\u0026#x27;, async () =\u0026gt; {\n  const { result, rerender, waitFor } = renderHook(({ id }) =\u0026gt; useData(id), {\n    initialProps: { id: \u0026#x27;testId\u0026#x27; },\n  });\n\n  rerender({ id: \u0026#x27;newTestId\u0026#x27; });\n\n  await waitFor(() =\u0026gt; {\n    expect(result.current.data).toBe(\u0026#x27;newTestId\u0026#x27;);\n  });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can see two new things here. renderHook is now called in a different way and we used rerender. Let\u0026#x27;s break it down.\u003c/p\u003e\u003cp\u003ePreviously we rendered a hook with a static argument renderHook(() =\u0026gt; useData(\u0026#x27;testId\u0026#x27;)). Now our case is slightly different.\u003c/p\u003e\u003cp\u003eWe want to check how our hook reacts to when component rerenders. This is why we will use a dynamic id when rendering our hook ({ id }) =\u0026gt; useData(id) and provide an initial value: initialProps: { id: \u0026#x27;testId\u0026#x27; }.\u003c/p\u003e\u003cp\u003eTo this point everything works the same as in the test above.\u003c/p\u003e\u003cp\u003eNow we call rerender({ id: \u0026#x27;newTestId\u0026#x27; }) and provide a new value for id. Hook will recognize that id was changed and call useEffect which fetches new data.\u003c/p\u003e\u003cp\u003e\u003c/p\u003e","structured_body":{"blocks":[{"key":"46fn4","text":"In the next test we want to observe rerendering hook with new id and see if it updates the returned data.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2onkl","text":"it('should fetch new data when id is updated', async () =\u003e {\n  const { result, rerender, waitFor } = renderHook(({ id }) =\u003e useData(id), {\n    initialProps: { id: 'testId' },\n  });\n\n  rerender({ id: 'newTestId' });\n\n  await waitFor(() =\u003e {\n    expect(result.current.data).toBe('newTestId');\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"di62i","text":"We can see two new things here. renderHook is now called in a different way and we used rerender. Let's break it down.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2iunf","text":"Previously we rendered a hook with a static argument renderHook(() =\u003e useData('testId')). Now our case is slightly different.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"37vq2","text":"We want to check how our hook reacts to when component rerenders. This is why we will use a dynamic id when rendering our hook ({ id }) =\u003e useData(id) and provide an initial value: initialProps: { id: 'testId' }.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8dtt0","text":"To this point everything works the same as in the test above.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"349pn","text":"Now we call rerender({ id: 'newTestId' }) and provide a new value for id. Hook will recognize that id was changed and call useEffect which fetches new data.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"82uo","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Second test - rerendering hook","body":null,"serialized_body":"\u003cp\u003eIn the next test we want to observe rerendering hook with new id and see if it updates the returned data.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should fetch new data when id is updated\u0026#x27;, async () =\u0026gt; {\n  const { result, rerender, waitFor } = renderHook(({ id }) =\u0026gt; useData(id), {\n    initialProps: { id: \u0026#x27;testId\u0026#x27; },\n  });\n\n  rerender({ id: \u0026#x27;newTestId\u0026#x27; });\n\n  await waitFor(() =\u0026gt; {\n    expect(result.current.data).toBe(\u0026#x27;newTestId\u0026#x27;);\n  });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can see two new things here. renderHook is now called in a different way and we used rerender. Let\u0026#x27;s break it down.\u003c/p\u003e\u003cp\u003ePreviously we rendered a hook with a static argument renderHook(() =\u0026gt; useData(\u0026#x27;testId\u0026#x27;)). Now our case is slightly different.\u003c/p\u003e\u003cp\u003eWe want to check how our hook reacts to when component rerenders. This is why we will use a dynamic id when rendering our hook ({ id }) =\u0026gt; useData(id) and provide an initial value: initialProps: { id: \u0026#x27;testId\u0026#x27; }.\u003c/p\u003e\u003cp\u003eTo this point everything works the same as in the test above.\u003c/p\u003e\u003cp\u003eNow we call rerender({ id: \u0026#x27;newTestId\u0026#x27; }) and provide a new value for id. Hook will recognize that id was changed and call useEffect which fetches new data.\u003c/p\u003e\u003cp\u003e\u003c/p\u003e","structured_body":{"blocks":[{"key":"46fn4","text":"In the next test we want to observe rerendering hook with new id and see if it updates the returned data.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2onkl","text":"it('should fetch new data when id is updated', async () =\u003e {\n  const { result, rerender, waitFor } = renderHook(({ id }) =\u003e useData(id), {\n    initialProps: { id: 'testId' },\n  });\n\n  rerender({ id: 'newTestId' });\n\n  await waitFor(() =\u003e {\n    expect(result.current.data).toBe('newTestId');\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"di62i","text":"We can see two new things here. renderHook is now called in a different way and we used rerender. Let's break it down.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2iunf","text":"Previously we rendered a hook with a static argument renderHook(() =\u003e useData('testId')). Now our case is slightly different.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"37vq2","text":"We want to check how our hook reacts to when component rerenders. This is why we will use a dynamic id when rendering our hook ({ id }) =\u003e useData(id) and provide an initial value: initialProps: { id: 'testId' }.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8dtt0","text":"To this point everything works the same as in the test above.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"349pn","text":"Now we call rerender({ id: 'newTestId' }) and provide a new value for id. Hook will recognize that id was changed and call useEffect which fetches new data.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"82uo","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":809,"position":11,"new_position":11,"published_attributes":{"type":"slide","answers":[],"title":"Third test - checking isLoading state","body":null,"serialized_body":"\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should update isLoading\u0026#x27;, async () =\u0026gt; {\n  const { result, rerender, waitFor } = renderHook(({ id }) =\u0026gt; useData(id), {\n    initialProps: { id: \u0026#x27;testId\u0026#x27; },\n  });\n\n  expect(result.current.isLoading).toBe(true);\n\n  await waitFor(() =\u0026gt; {\n    expect(result.current.isLoading).toBe(false);\n  });\n\n  rerender({ id: \u0026#x27;newTestId\u0026#x27; });\n\n  expect(result.current.isLoading).toBe(true);\n\n  await waitFor(() =\u0026gt; {\n    expect(result.current.isLoading).toBe(false);\n  });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we used solutions from previous tests. We checked if isLoading is true when hook is first rendered and then we wait until it\u0026#x27;s false again.\u003c/p\u003e\u003cp\u003eJust to be sure we rerendered with new id and checked isLoading state again.\u003c/p\u003e","structured_body":{"blocks":[{"key":"2dj3g","text":"it('should update isLoading', async () =\u003e {\n  const { result, rerender, waitFor } = renderHook(({ id }) =\u003e useData(id), {\n    initialProps: { id: 'testId' },\n  });\n\n  expect(result.current.isLoading).toBe(true);\n\n  await waitFor(() =\u003e {\n    expect(result.current.isLoading).toBe(false);\n  });\n\n  rerender({ id: 'newTestId' });\n\n  expect(result.current.isLoading).toBe(true);\n\n  await waitFor(() =\u003e {\n    expect(result.current.isLoading).toBe(false);\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7nkiu","text":"Here we used solutions from previous tests. We checked if isLoading is true when hook is first rendered and then we wait until it's false again.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ftfr0","text":"Just to be sure we rerendered with new id and checked isLoading state again.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Third test - checking isLoading state","body":null,"serialized_body":"\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eit(\u0026#x27;should update isLoading\u0026#x27;, async () =\u0026gt; {\n  const { result, rerender, waitFor } = renderHook(({ id }) =\u0026gt; useData(id), {\n    initialProps: { id: \u0026#x27;testId\u0026#x27; },\n  });\n\n  expect(result.current.isLoading).toBe(true);\n\n  await waitFor(() =\u0026gt; {\n    expect(result.current.isLoading).toBe(false);\n  });\n\n  rerender({ id: \u0026#x27;newTestId\u0026#x27; });\n\n  expect(result.current.isLoading).toBe(true);\n\n  await waitFor(() =\u0026gt; {\n    expect(result.current.isLoading).toBe(false);\n  });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we used solutions from previous tests. We checked if isLoading is true when hook is first rendered and then we wait until it\u0026#x27;s false again.\u003c/p\u003e\u003cp\u003eJust to be sure we rerendered with new id and checked isLoading state again.\u003c/p\u003e","structured_body":{"blocks":[{"key":"2dj3g","text":"it('should update isLoading', async () =\u003e {\n  const { result, rerender, waitFor } = renderHook(({ id }) =\u003e useData(id), {\n    initialProps: { id: 'testId' },\n  });\n\n  expect(result.current.isLoading).toBe(true);\n\n  await waitFor(() =\u003e {\n    expect(result.current.isLoading).toBe(false);\n  });\n\n  rerender({ id: 'newTestId' });\n\n  expect(result.current.isLoading).toBe(true);\n\n  await waitFor(() =\u003e {\n    expect(result.current.isLoading).toBe(false);\n  });\n});","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7nkiu","text":"Here we used solutions from previous tests. We checked if isLoading is true when hook is first rendered and then we wait until it's false again.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ftfr0","text":"Just to be sure we rerendered with new id and checked isLoading state again.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":810,"position":12,"new_position":12,"published_attributes":{"type":"slide","answers":[],"title":"Exercise - testing useCounter hook","body":null,"serialized_body":"\u003cp\u003eUse this hook:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { useState, useCallback } from \u0026#x27;react\u0026#x27;\n\nconst useCounter = (initialValue = 0) =\u0026gt; {\n  const [count, setCount] = useState(initialValue)\n  const increment = useCallback(() =\u0026gt; setCount((x) =\u0026gt; x + 1), [])\n  const decrement = useCallback(() =\u0026gt; setCount((x) =\u0026gt; x - 1), [])\n  return { count, increment, decrement }\n}\nexport default useCounter\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd fill in tests below:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003edescribe(\u0026#x27;useCounter\u0026#x27;, () =\u0026gt; {\n  it(\u0026#x27;should return initial value\u0026#x27;, () =\u0026gt; {\n\n  })\n\n  it(\u0026#x27;should increment\u0026#x27;, () =\u0026gt; {\n\n  })\n\n  it(\u0026#x27;should decrement\u0026#x27;, () =\u0026gt; {\n    \n  })\n})\u003c/code\u003e\u003c/pre\u003e","structured_body":{"blocks":[{"key":"6otmh","text":"Use this hook:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2mvvg","text":"import { useState, useCallback } from 'react'\n\nconst useCounter = (initialValue = 0) =\u003e {\n  const [count, setCount] = useState(initialValue)\n  const increment = useCallback(() =\u003e setCount((x) =\u003e x + 1), [])\n  const decrement = useCallback(() =\u003e setCount((x) =\u003e x - 1), [])\n  return { count, increment, decrement }\n}\nexport default useCounter","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"576a8","text":"And fill in tests below:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cj16r","text":"describe('useCounter', () =\u003e {\n  it('should return initial value', () =\u003e {\n\n  })\n\n  it('should increment', () =\u003e {\n\n  })\n\n  it('should decrement', () =\u003e {\n    \n  })\n})","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Exercise - testing useCounter hook","body":null,"serialized_body":"\u003cp\u003eUse this hook:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eimport { useState, useCallback } from \u0026#x27;react\u0026#x27;\n\nconst useCounter = (initialValue = 0) =\u0026gt; {\n  const [count, setCount] = useState(initialValue)\n  const increment = useCallback(() =\u0026gt; setCount((x) =\u0026gt; x + 1), [])\n  const decrement = useCallback(() =\u0026gt; setCount((x) =\u0026gt; x - 1), [])\n  return { count, increment, decrement }\n}\nexport default useCounter\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd fill in tests below:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003edescribe(\u0026#x27;useCounter\u0026#x27;, () =\u0026gt; {\n  it(\u0026#x27;should return initial value\u0026#x27;, () =\u0026gt; {\n\n  })\n\n  it(\u0026#x27;should increment\u0026#x27;, () =\u0026gt; {\n\n  })\n\n  it(\u0026#x27;should decrement\u0026#x27;, () =\u0026gt; {\n    \n  })\n})\u003c/code\u003e\u003c/pre\u003e","structured_body":{"blocks":[{"key":"6otmh","text":"Use this hook:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2mvvg","text":"import { useState, useCallback } from 'react'\n\nconst useCounter = (initialValue = 0) =\u003e {\n  const [count, setCount] = useState(initialValue)\n  const increment = useCallback(() =\u003e setCount((x) =\u003e x + 1), [])\n  const decrement = useCallback(() =\u003e setCount((x) =\u003e x - 1), [])\n  return { count, increment, decrement }\n}\nexport default useCounter","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"576a8","text":"And fill in tests below:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cj16r","text":"describe('useCounter', () =\u003e {\n  it('should return initial value', () =\u003e {\n\n  })\n\n  it('should increment', () =\u003e {\n\n  })\n\n  it('should decrement', () =\u003e {\n    \n  })\n})","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-01-18T11:54:37.635+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]}],"attachments":[]}