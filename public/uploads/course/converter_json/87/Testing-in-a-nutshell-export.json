{"id":221,"title":"Testing in a nutshell","estimated_time":24,"user_id":666,"passing_threshold":80,"published_at":"2021-08-27T09:15:04.640+02:00","has_unpublished_changes":false,"has_certificate":false,"external_id":null,"draft_external_id":null,"external_status":"inapplicable","course_type":"bridge","enrollments_count":38,"domain_id":1,"sub_account_id":1,"open_book":null,"description":null,"third_party_course_id":null,"external_course_id":null,"quizzes_count":0,"external_status_message":null,"manual_estimated_time":false,"show_correct_response":false,"max_quiz_attempts":null,"continuing_education_credits":null,"archived_at":null,"config":{},"unpublished_at":null,"external_learning_standard":null,"available_offline":false,"external_version":null,"ordered_slides":[{"id":1714,"position":1,"new_position":1,"published_attributes":{"type":"cover","answers":[],"title":null,"body":null,"serialized_body":null,"structured_body":null,"feedback":null,"cover_slide_data":{"heading":"Testing in a nutshell","intro":"\"Program testing can be used to show the presence of bugs, but never to show their absence!\"\n\nEdsger Dijkstra"}},"draft_attributes":{"type":"cover","answers":[],"title":null,"body":null,"serialized_body":null,"structured_body":null,"feedback":null,"cover_slide_data":{"heading":"Testing in a nutshell","intro":"\"Program testing can be used to show the presence of bugs, but never to show their absence!\"\n\nEdsger Dijkstra"}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":0,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":1712,"position":2,"new_position":2,"published_attributes":{"type":"slide","title":"Intro","body":null,"serialized_body":"\u003ch3\u003e\u003cstrong\u003eHello world!\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eI\u0026#x27;m glad that you decided to take a look at my guide. You are probably aware that we could talk about testing for days, maybe even weeks or months, and there are plenty of books written about it. But the purpose of this guide is to align practices and assumptions that are considered the best one and that are often neglected. As much as you are lucky and always found a project where the tests were well conducted, believe me, there are many projects without well-written tests or even completely untested functionalities.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWho is this guide for?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eyou are at the very beginning of your professional career as a developer\u003c/li\u003e\u003cli\u003eyou would like to familiarize the concepts related to software testing\u003c/li\u003e\u003cli\u003ethe line between unit testing and integration testing seems slippery to you\u003c/li\u003e\u003cli\u003eyou think testing is unnecessary\u003c/li\u003e\u003cli\u003eyou don\u0026#x27;t see the difference between a stub and a mock\u003c/li\u003e\u003cli\u003eyou are looking for argumentation in a conversation with a client\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"fp31q","text":"Hello world!","type":"header-three","depth":0,"inlineStyleRanges":[{"offset":0,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"24ipl","text":"I'm glad that you decided to take a look at my guide. You are probably aware that we could talk about testing for days, maybe even weeks or months, and there are plenty of books written about it. But the purpose of this guide is to align practices and assumptions that are considered the best one and that are often neglected. As much as you are lucky and always found a project where the tests were well conducted, believe me, there are many projects without well-written tests or even completely untested functionalities.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6f32u","text":"Who is this guide for?","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"33pci","text":"you are at the very beginning of your professional career as a developer","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4ojdj","text":"you would like to familiarize the concepts related to software testing","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d78a1","text":"the line between unit testing and integration testing seems slippery to you","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cj2oi","text":"you think testing is unnecessary","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cgits","text":"you don't see the difference between a stub and a mock","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bt6u0","text":"you are looking for argumentation in a conversation with a client","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"answers":[],"feedback":null,"cover_slide_data":{},"allow_comments":false},"draft_attributes":{"type":"slide","title":"Intro","body":null,"serialized_body":"\u003ch3\u003e\u003cstrong\u003eHello world!\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eI\u0026#x27;m glad that you decided to take a look at my guide. You are probably aware that we could talk about testing for days, maybe even weeks or months, and there are plenty of books written about it. But the purpose of this guide is to align practices and assumptions that are considered the best one and that are often neglected. As much as you are lucky and always found a project where the tests were well conducted, believe me, there are many projects without well-written tests or even completely untested functionalities.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWho is this guide for?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eyou are at the very beginning of your professional career as a developer\u003c/li\u003e\u003cli\u003eyou would like to familiarize the concepts related to software testing\u003c/li\u003e\u003cli\u003ethe line between unit testing and integration testing seems slippery to you\u003c/li\u003e\u003cli\u003eyou think testing is unnecessary\u003c/li\u003e\u003cli\u003eyou don\u0026#x27;t see the difference between a stub and a mock\u003c/li\u003e\u003cli\u003eyou are looking for argumentation in a conversation with a client\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"fp31q","text":"Hello world!","type":"header-three","depth":0,"inlineStyleRanges":[{"offset":0,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"24ipl","text":"I'm glad that you decided to take a look at my guide. You are probably aware that we could talk about testing for days, maybe even weeks or months, and there are plenty of books written about it. But the purpose of this guide is to align practices and assumptions that are considered the best one and that are often neglected. As much as you are lucky and always found a project where the tests were well conducted, believe me, there are many projects without well-written tests or even completely untested functionalities.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6f32u","text":"Who is this guide for?","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"33pci","text":"you are at the very beginning of your professional career as a developer","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4ojdj","text":"you would like to familiarize the concepts related to software testing","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d78a1","text":"the line between unit testing and integration testing seems slippery to you","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cj2oi","text":"you think testing is unnecessary","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cgits","text":"you don't see the difference between a stub and a mock","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bt6u0","text":"you are looking for argumentation in a conversation with a client","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"answers":[],"feedback":null,"cover_slide_data":{},"allow_comments":false},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":1715,"position":3,"new_position":3,"published_attributes":{"type":"slide","answers":[],"title":"Agenda","body":null,"serialized_body":"\u003col\u003e\u003cli\u003eAbout testing\u003c/li\u003e\u003cli\u003eFunctional tests\u003col\u003e\u003cli\u003eUnit tests\u003c/li\u003e\u003cli\u003eIntegration tests\u003c/li\u003e\u003cli\u003eE2E tests\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003eNon-functional tests\u003col\u003e\u003cli\u003ePerformance tests\u003c/li\u003e\u003cli\u003eSecurity tests\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003ePopular test smells\u003col\u003e\u003cli\u003eSlow tests\u003c/li\u003e\u003cli\u003eRandomly failing tests\u003c/li\u003e\u003cli\u003eHard to test code\u003c/li\u003e\u003cli\u003eDuplicated assertions\u003c/li\u003e\u003cli\u003eFragile tests\u003c/li\u003e\u003cli\u003eAssertions roulette\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003eTest doubles\u003col\u003e\u003cli\u003eDummies\u003c/li\u003e\u003cli\u003eFakes\u003c/li\u003e\u003cli\u003eStubs\u003c/li\u003e\u003cli\u003eSpies\u003c/li\u003e\u003cli\u003eMocks\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003eContract tests\u003c/li\u003e\u003cli\u003eTest Driven Development vs Test First Development\u003c/li\u003e\u003cli\u003eBehaviour Driven Development\u003c/li\u003e\u003c/ol\u003e","structured_body":{"blocks":[{"key":"dsa6o","text":"About testing","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"97oeo","text":"Functional tests","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5b9r1","text":"Unit tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"804mj","text":"Integration tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"65g25","text":"E2E tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"59lhj","text":"Non-functional tests","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dvcfi","text":"Performance tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3vf3p","text":"Security tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3nq3l","text":"Popular test smells","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3jnhq","text":"Slow tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9uai2","text":"Randomly failing tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8l7r2","text":"Hard to test code","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ammk3","text":"Duplicated assertions","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3655q","text":"Fragile tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dkiis","text":"Assertions roulette","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2q15o","text":"Test doubles","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ah78o","text":"Dummies","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8bvij","text":"Fakes","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"arhl5","text":"Stubs","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5ceji","text":"Spies","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7g3q9","text":"Mocks","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8aso2","text":"Contract tests","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ft56h","text":"Test Driven Development vs Test First Development","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"959va","text":"Behaviour Driven Development","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Agenda","body":null,"serialized_body":"\u003col\u003e\u003cli\u003eAbout testing\u003c/li\u003e\u003cli\u003eFunctional tests\u003col\u003e\u003cli\u003eUnit tests\u003c/li\u003e\u003cli\u003eIntegration tests\u003c/li\u003e\u003cli\u003eE2E tests\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003eNon-functional tests\u003col\u003e\u003cli\u003ePerformance tests\u003c/li\u003e\u003cli\u003eSecurity tests\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003ePopular test smells\u003col\u003e\u003cli\u003eSlow tests\u003c/li\u003e\u003cli\u003eRandomly failing tests\u003c/li\u003e\u003cli\u003eHard to test code\u003c/li\u003e\u003cli\u003eDuplicated assertions\u003c/li\u003e\u003cli\u003eFragile tests\u003c/li\u003e\u003cli\u003eAssertions roulette\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003eTest doubles\u003col\u003e\u003cli\u003eDummies\u003c/li\u003e\u003cli\u003eFakes\u003c/li\u003e\u003cli\u003eStubs\u003c/li\u003e\u003cli\u003eSpies\u003c/li\u003e\u003cli\u003eMocks\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003eContract tests\u003c/li\u003e\u003cli\u003eTest Driven Development vs Test First Development\u003c/li\u003e\u003cli\u003eBehaviour Driven Development\u003c/li\u003e\u003c/ol\u003e","structured_body":{"blocks":[{"key":"dsa6o","text":"About testing","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"97oeo","text":"Functional tests","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5b9r1","text":"Unit tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"804mj","text":"Integration tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"65g25","text":"E2E tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"59lhj","text":"Non-functional tests","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dvcfi","text":"Performance tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3vf3p","text":"Security tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3nq3l","text":"Popular test smells","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3jnhq","text":"Slow tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9uai2","text":"Randomly failing tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8l7r2","text":"Hard to test code","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ammk3","text":"Duplicated assertions","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3655q","text":"Fragile tests","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dkiis","text":"Assertions roulette","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2q15o","text":"Test doubles","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ah78o","text":"Dummies","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8bvij","text":"Fakes","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"arhl5","text":"Stubs","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5ceji","text":"Spies","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7g3q9","text":"Mocks","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8aso2","text":"Contract tests","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ft56h","text":"Test Driven Development vs Test First Development","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"959va","text":"Behaviour Driven Development","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":1737,"position":4,"new_position":4,"published_attributes":{"type":"slide","answers":[],"title":"About testing","body":null,"serialized_body":"\u003cp\u003eBefore we jump into more details it\u0026#x27;s good to answer a couple of questions.\u003c/p\u003e\u003ch3\u003eWhy do we test?\u003c/h3\u003e\u003cp\u003eLet us say it once again and loudly: The primary goal of software testing is to detect as many issues as possible and as early as possible. This is the main reason we should write the test first if we plan to add any logic to our codebase. It doesn\u0026#x27;t mean it will save us from all bugs and errors but will provide at least a bit of confidence that things we do actually work.\u003c/p\u003e\u003cp\u003eBut that\u0026#x27;s not the end. We can think of tests as a plan for work to be done. It\u0026#x27;s all about reverting our way of thinking about software development. Instead of writing any code first we should think for a moment about requirements and try to define them. Maybe we could create a mind map or use stickers to go through the whole process and think about some edge cases?\u003c/p\u003e\u003cp\u003eHow about some examples? Let\u0026#x27;s have a look at sending a custom email notification via some service using Miro.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/80b6e1e9-5792-400c-bdb7-f2dfc35c73e7.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-20%2Bo%2B09.52.01.png\u0026amp;Expires=1621498970\u0026amp;Signature=jMfn5NbuIxC2zzd38c3AAs8B7RCaojBvr-IsQRcIV1DM5ZNDG7BwkfEg9kNnJrD4l2PtMOApyAhtGT-yLIlttjnTIeSbYX3x1Sed05fK0-O8pNV~14PFKo2-hW5uyo2Hx0qgRRxvKjw0nWIcK5Zw4xwlscJFvwx7dBYuwnuH40GnpjGSAlbUhePUE7i2XI~BBZhAsZTdYdzYy1hgiC9tLGS7e6arjMBRbx2SMMu27Z1j7gHApLf0W22wo6DKKd8vUlKAHnm-TYgtOsIGp1~otNcyVvLm18WkIy-xOGKx6h9ehoDYMWUnBpgsyEd1Arj5nwQ~Oi5z974zcPDhz5-GzQ__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003eProbably you could figure out more conditions to be met. Now you can figure out which of them should be tested with unit or integration tests? You can consider splitting the logic to smaller classes and make a component/s from it. What is more, you\u0026#x27;ve just created a base of conditions that you can reuse during a work on a similar issue. And remember it doesn\u0026#x27;t have to be done that way, do it the way it\u0026#x27;s most comfortable to you.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s continue with the example. Imagine you decided to create a small service that will encapsulate validation logic for sending the email notification and once it\u0026#x27;s valid it will pass it to the service. One of the requirements we figure out is to make sure that the receiver\u0026#x27;s email exists in our database and we want to test it with unit tests. What about allowing us to inject a database source adapter to our service so we could use whatever store for our user emails?\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e// example in TypeScript\n\nclass EmailVerificationService {\n  store: UserDataStoreInterface;\n  constructor(store: UserDataStoreInterface) {\n    this.store = store || new UserDataStore();\n  }\n  ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI hope you start feeling the benefits that come from testing. By having well-thought defined conditions we can think of tests as documentation for our system.\u003c/p\u003e\u003cp\u003eOk, all those sounds pretty good right? So ...\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eWhy do we not test?\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eI am afraid that there might be at least several reasons for that. Let\u0026#x27;s start with the easiest one.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWe don\u0026#x27;t have much time\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis one is quite popular among us, isn\u0026#x27;t? It\u0026#x27;s hard to estimate properly if some substantial information is missing. Due to missing constraints we are not able to make proper assumptions, instead of a good plan we are working in the dark.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWe don\u0026#x27;t see any value in it\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI am pretty sure you experienced situations when requirements in your project were changing rapidly or despite the full test coverage there were undiscovered bugs in your app and you decided to abandon the tests at all. It\u0026#x27;s just a matter of having a good plan, seeing the bigger picture and making your code open to extension but closed to modification.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCode smells\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTesting is not easy. There are plenty of issues we may encounter during software testing. Later on we will learn about those code smells and how to handle them. This will allow us to make our test suites less fragile and more maintainable.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://martinfowler.com/bliki/UnitTest.html\"\u003ehttps://martinfowler.com/bliki/UnitTest.html\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://martinfowler.com/bliki/IntegrationTest.html\"\u003ehttps://martinfowler.com/bliki/IntegrationTest.html\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003c/p\u003e\u003ch3\u003e\u003c/h3\u003e","structured_body":{"blocks":[{"key":"aq5cr","text":"Before we jump into more details it's good to answer a couple of questions.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f787e","text":"Why do we test?","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8rpf3","text":"Let us say it once again and loudly: The primary goal of software testing is to detect as many issues as possible and as early as possible. This is the main reason we should write the test first if we plan to add any logic to our codebase. It doesn't mean it will save us from all bugs and errors but will provide at least a bit of confidence that things we do actually work.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"du9bl","text":"But that's not the end. We can think of tests as a plan for work to be done. It's all about reverting our way of thinking about software development. Instead of writing any code first we should think for a moment about requirements and try to define them. Maybe we could create a mind map or use stickers to go through the whole process and think about some edge cases?","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cqfdj","text":"How about some examples? Let's have a look at sending a custom email notification via some service using Miro.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"79oau","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"3ppsb","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ds73b","text":"Probably you could figure out more conditions to be met. Now you can figure out which of them should be tested with unit or integration tests? You can consider splitting the logic to smaller classes and make a component/s from it. What is more, you've just created a base of conditions that you can reuse during a work on a similar issue. And remember it doesn't have to be done that way, do it the way it's most comfortable to you.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bspp9","text":"Let's continue with the example. Imagine you decided to create a small service that will encapsulate validation logic for sending the email notification and once it's valid it will pass it to the service. One of the requirements we figure out is to make sure that the receiver's email exists in our database and we want to test it with unit tests. What about allowing us to inject a database source adapter to our service so we could use whatever store for our user emails?","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cd46g","text":"// example in TypeScript\n\nclass EmailVerificationService {\n  store: UserDataStoreInterface;\n  constructor(store: UserDataStoreInterface) {\n    this.store = store || new UserDataStore();\n  }\n  ...\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"adh2l","text":"I hope you start feeling the benefits that come from testing. By having well-thought defined conditions we can think of tests as documentation for our system.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ki5n","text":"Ok, all those sounds pretty good right? So ...","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3ft8h","text":"Why do we not test?","type":"header-three","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4t24k","text":"I am afraid that there might be at least several reasons for that. Let's start with the easiest one.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"71qnm","text":"We don't have much time","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5e41m","text":"This one is quite popular among us, isn't? It's hard to estimate properly if some substantial information is missing. Due to missing constraints we are not able to make proper assumptions, instead of a good plan we are working in the dark.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"81igr","text":"We don't see any value in it","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dvcgi","text":"I am pretty sure you experienced situations when requirements in your project were changing rapidly or despite the full test coverage there were undiscovered bugs in your app and you decided to abandon the tests at all. It's just a matter of having a good plan, seeing the bigger picture and making your code open to extension but closed to modification.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"asacd","text":"Code smells","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1nclc","text":"Testing is not easy. There are plenty of issues we may encounter during software testing. Later on we will learn about those code smells and how to handle them. This will allow us to make our test suites less fragile and more maintainable.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4jhhh","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3ajji","text":"https://martinfowler.com/bliki/UnitTest.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":44,"key":1}],"data":{}},{"key":"bcpmp","text":"https://martinfowler.com/bliki/IntegrationTest.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":51,"key":2}],"data":{}},{"key":"eagoe","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"378n0","text":"","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/80b6e1e9-5792-400c-bdb7-f2dfc35c73e7.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-20%2Bo%2B09.52.01.png\u0026Expires=1621498970\u0026Signature=jMfn5NbuIxC2zzd38c3AAs8B7RCaojBvr-IsQRcIV1DM5ZNDG7BwkfEg9kNnJrD4l2PtMOApyAhtGT-yLIlttjnTIeSbYX3x1Sed05fK0-O8pNV~14PFKo2-hW5uyo2Hx0qgRRxvKjw0nWIcK5Zw4xwlscJFvwx7dBYuwnuH40GnpjGSAlbUhePUE7i2XI~BBZhAsZTdYdzYy1hgiC9tLGS7e6arjMBRbx2SMMu27Z1j7gHApLf0W22wo6DKKd8vUlKAHnm-TYgtOsIGp1~otNcyVvLm18WkIy-xOGKx6h9ehoDYMWUnBpgsyEd1Arj5nwQ~Oi5z974zcPDhz5-GzQ__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3022"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://martinfowler.com/bliki/UnitTest.html","url":"https://martinfowler.com/bliki/UnitTest.html"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://martinfowler.com/bliki/IntegrationTest.html","url":"https://martinfowler.com/bliki/IntegrationTest.html"}}}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"About testing","body":null,"serialized_body":"\u003cp\u003eBefore we jump into more details it\u0026#x27;s good to answer a couple of questions.\u003c/p\u003e\u003ch3\u003eWhy do we test?\u003c/h3\u003e\u003cp\u003eLet us say it once again and loudly: The primary goal of software testing is to detect as many issues as possible and as early as possible. This is the main reason we should write the test first if we plan to add any logic to our codebase. It doesn\u0026#x27;t mean it will save us from all bugs and errors but will provide at least a bit of confidence that things we do actually work.\u003c/p\u003e\u003cp\u003eBut that\u0026#x27;s not the end. We can think of tests as a plan for work to be done. It\u0026#x27;s all about reverting our way of thinking about software development. Instead of writing any code first we should think for a moment about requirements and try to define them. Maybe we could create a mind map or use stickers to go through the whole process and think about some edge cases?\u003c/p\u003e\u003cp\u003eHow about some examples? Let\u0026#x27;s have a look at sending a custom email notification via some service using Miro.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/80b6e1e9-5792-400c-bdb7-f2dfc35c73e7.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-20%2Bo%2B09.52.01.png\u0026amp;Expires=1621498970\u0026amp;Signature=jMfn5NbuIxC2zzd38c3AAs8B7RCaojBvr-IsQRcIV1DM5ZNDG7BwkfEg9kNnJrD4l2PtMOApyAhtGT-yLIlttjnTIeSbYX3x1Sed05fK0-O8pNV~14PFKo2-hW5uyo2Hx0qgRRxvKjw0nWIcK5Zw4xwlscJFvwx7dBYuwnuH40GnpjGSAlbUhePUE7i2XI~BBZhAsZTdYdzYy1hgiC9tLGS7e6arjMBRbx2SMMu27Z1j7gHApLf0W22wo6DKKd8vUlKAHnm-TYgtOsIGp1~otNcyVvLm18WkIy-xOGKx6h9ehoDYMWUnBpgsyEd1Arj5nwQ~Oi5z974zcPDhz5-GzQ__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003eProbably you could figure out more conditions to be met. Now you can figure out which of them should be tested with unit or integration tests? You can consider splitting the logic to smaller classes and make a component/s from it. What is more, you\u0026#x27;ve just created a base of conditions that you can reuse during a work on a similar issue. And remember it doesn\u0026#x27;t have to be done that way, do it the way it\u0026#x27;s most comfortable to you.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s continue with the example. Imagine you decided to create a small service that will encapsulate validation logic for sending the email notification and once it\u0026#x27;s valid it will pass it to the service. One of the requirements we figure out is to make sure that the receiver\u0026#x27;s email exists in our database and we want to test it with unit tests. What about allowing us to inject a database source adapter to our service so we could use whatever store for our user emails?\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e// example in TypeScript\n\nclass EmailVerificationService {\n  store: UserDataStoreInterface;\n  constructor(store: UserDataStoreInterface) {\n    this.store = store || new UserDataStore();\n  }\n  ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI hope you start feeling the benefits that come from testing. By having well-thought defined conditions we can think of tests as documentation for our system.\u003c/p\u003e\u003cp\u003eOk, all those sounds pretty good right? So ...\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eWhy do we not test?\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eI am afraid that there might be at least several reasons for that. Let\u0026#x27;s start with the easiest one.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWe don\u0026#x27;t have much time\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis one is quite popular among us, isn\u0026#x27;t? It\u0026#x27;s hard to estimate properly if some substantial information is missing. Due to missing constraints we are not able to make proper assumptions, instead of a good plan we are working in the dark.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWe don\u0026#x27;t see any value in it\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eI am pretty sure you experienced situations when requirements in your project were changing rapidly or despite the full test coverage there were undiscovered bugs in your app and you decided to abandon the tests at all. It\u0026#x27;s just a matter of having a good plan, seeing the bigger picture and making your code open to extension but closed to modification.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCode smells\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTesting is not easy. There are plenty of issues we may encounter during software testing. Later on we will learn about those code smells and how to handle them. This will allow us to make our test suites less fragile and more maintainable.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://martinfowler.com/bliki/UnitTest.html\"\u003ehttps://martinfowler.com/bliki/UnitTest.html\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://martinfowler.com/bliki/IntegrationTest.html\"\u003ehttps://martinfowler.com/bliki/IntegrationTest.html\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003c/p\u003e\u003ch3\u003e\u003c/h3\u003e","structured_body":{"blocks":[{"key":"aq5cr","text":"Before we jump into more details it's good to answer a couple of questions.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f787e","text":"Why do we test?","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8rpf3","text":"Let us say it once again and loudly: The primary goal of software testing is to detect as many issues as possible and as early as possible. This is the main reason we should write the test first if we plan to add any logic to our codebase. It doesn't mean it will save us from all bugs and errors but will provide at least a bit of confidence that things we do actually work.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"du9bl","text":"But that's not the end. We can think of tests as a plan for work to be done. It's all about reverting our way of thinking about software development. Instead of writing any code first we should think for a moment about requirements and try to define them. Maybe we could create a mind map or use stickers to go through the whole process and think about some edge cases?","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cqfdj","text":"How about some examples? Let's have a look at sending a custom email notification via some service using Miro.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"79oau","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"3ppsb","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ds73b","text":"Probably you could figure out more conditions to be met. Now you can figure out which of them should be tested with unit or integration tests? You can consider splitting the logic to smaller classes and make a component/s from it. What is more, you've just created a base of conditions that you can reuse during a work on a similar issue. And remember it doesn't have to be done that way, do it the way it's most comfortable to you.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bspp9","text":"Let's continue with the example. Imagine you decided to create a small service that will encapsulate validation logic for sending the email notification and once it's valid it will pass it to the service. One of the requirements we figure out is to make sure that the receiver's email exists in our database and we want to test it with unit tests. What about allowing us to inject a database source adapter to our service so we could use whatever store for our user emails?","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cd46g","text":"// example in TypeScript\n\nclass EmailVerificationService {\n  store: UserDataStoreInterface;\n  constructor(store: UserDataStoreInterface) {\n    this.store = store || new UserDataStore();\n  }\n  ...\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"adh2l","text":"I hope you start feeling the benefits that come from testing. By having well-thought defined conditions we can think of tests as documentation for our system.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ki5n","text":"Ok, all those sounds pretty good right? So ...","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3ft8h","text":"Why do we not test?","type":"header-three","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4t24k","text":"I am afraid that there might be at least several reasons for that. Let's start with the easiest one.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"71qnm","text":"We don't have much time","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5e41m","text":"This one is quite popular among us, isn't? It's hard to estimate properly if some substantial information is missing. Due to missing constraints we are not able to make proper assumptions, instead of a good plan we are working in the dark.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"81igr","text":"We don't see any value in it","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dvcgi","text":"I am pretty sure you experienced situations when requirements in your project were changing rapidly or despite the full test coverage there were undiscovered bugs in your app and you decided to abandon the tests at all. It's just a matter of having a good plan, seeing the bigger picture and making your code open to extension but closed to modification.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"asacd","text":"Code smells","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1nclc","text":"Testing is not easy. There are plenty of issues we may encounter during software testing. Later on we will learn about those code smells and how to handle them. This will allow us to make our test suites less fragile and more maintainable.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4jhhh","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3ajji","text":"https://martinfowler.com/bliki/UnitTest.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":44,"key":1}],"data":{}},{"key":"bcpmp","text":"https://martinfowler.com/bliki/IntegrationTest.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":51,"key":2}],"data":{}},{"key":"eagoe","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"378n0","text":"","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/80b6e1e9-5792-400c-bdb7-f2dfc35c73e7.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-20%2Bo%2B09.52.01.png\u0026Expires=1621498970\u0026Signature=jMfn5NbuIxC2zzd38c3AAs8B7RCaojBvr-IsQRcIV1DM5ZNDG7BwkfEg9kNnJrD4l2PtMOApyAhtGT-yLIlttjnTIeSbYX3x1Sed05fK0-O8pNV~14PFKo2-hW5uyo2Hx0qgRRxvKjw0nWIcK5Zw4xwlscJFvwx7dBYuwnuH40GnpjGSAlbUhePUE7i2XI~BBZhAsZTdYdzYy1hgiC9tLGS7e6arjMBRbx2SMMu27Z1j7gHApLf0W22wo6DKKd8vUlKAHnm-TYgtOsIGp1~otNcyVvLm18WkIy-xOGKx6h9ehoDYMWUnBpgsyEd1Arj5nwQ~Oi5z974zcPDhz5-GzQ__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3022"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://martinfowler.com/bliki/UnitTest.html","url":"https://martinfowler.com/bliki/UnitTest.html"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://martinfowler.com/bliki/IntegrationTest.html","url":"https://martinfowler.com/bliki/IntegrationTest.html"}}}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":4,"attachments_count":1,"presentable":true,"external_id":null,"attachments":[{"id":3022,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/80b6e1e9-5792-400c-bdb7-f2dfc35c73e7.png","duration":null,"name":"Zrzut ekranu 2021-05-20 o 09.52.01.png","learner_visible":true,"confirmed":false,"user_id":666,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2021-05-20T09:52:50.424+02:00","sources":[]}]},{"id":1713,"position":5,"new_position":5,"published_attributes":{"type":"slide","answers":[],"title":"Functional tests","body":null,"serialized_body":"\u003cp\u003eIn every book about functional testing, you will find a standard division into tests, as shown in the illustration below. These describe technical and business functional requirements, hence the name functional tests. Also this is why functional tests should be a source of documentation.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/7eccc644-31a3-4721-b2cc-6dd161464eec.png?response-content-disposition=attachment%3Bfilename%3Dtesting_piramid.png\u0026amp;Expires=1621245591\u0026amp;Signature=gY6RDhNpIdGqah4NJO8CDWa5~zWd-352C1d1~xpJOexsBhJ1SxayQVoRyZJ1jqXPP5CSFBrHQgyJLb8vAUMg-AzNks3~mZkrcMGaoZjl-RxnuqGt~YwXvTF2GzXJk7~0JvelnQWm779dSs67Uu759gGPxNym3HK8skrF3RiHRHadyeFC46a-H5K4-8roc5qembbxPVceIKYszWxfJWlFydtH3Tg84M5Q13LA4b0wrVqudCf3fgRbZvNYrQP5-Oic88o4pFsa9TFgcZNJF3jw1MY0rEDcZfcWupBUalLmVvGoe2khukpuUWs5L283SzedwMIgcEl4lhNGG8uDmcqSGQ__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\nLet us try to discuss the attributes of each kind.\u003c/p\u003e\u003ch3\u003eUnit tests\u003c/h3\u003e\u003cp\u003eThey are responsible for validating the correctness of the solution of the smallest logical unit in our application. For some it can be a single method or class, for others it can be an entire component as long as you are not performing I / O operations.\u003c/p\u003e\u003cp\u003eExamples:\u003c/p\u003e\u003cul\u003e\u003cli\u003emethod verifying the correctness of the user\u0026#x27;s password\u003c/li\u003e\u003cli\u003ecalculation of the discount of products in the customer\u0026#x27;s cart\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe two most important parameters for this group of tests are isolation and speed.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eIsolation\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTests must be independent and operate in an isolated environment, most often called testing. Any external change, such as an environment variable, connection to a database, external service or file system, will violate this rule.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSpeed\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIt is a very subjective matter, so the time it takes to execute unit tests will depend largely on the assumptions of the team, but should not exceed a few seconds. In some projects, the very launch of the tests is problematic. Be careful not to load unnecessary libraries during their startup.\u003c/p\u003e\u003ch3\u003eIntegration tests\u003c/h3\u003e\u003cp\u003eThe main difference to unit testing is the focus on validating behavior between components. Isolation and speed will not play a major role, but they are still worth remembering and making exceptions only in exceptional cases. After all, we do not want to be surprised by the long running CI, and even more randomly falling tests.\u003c/p\u003e\u003cp\u003eExample:\u003c/p\u003e\u003cul\u003e\u003cli\u003esaving user sessions to the database\u003c/li\u003e\u003cli\u003ereading weather data from API\u003c/li\u003e\u003cli\u003econfirmation of sending the payment by the system\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003eE2E (end to end) tests\u003c/h3\u003e\u003cp\u003eThey are the highest-level type of verification of the functional assumptions of our solution. They are often written with the help of user stories in the Gherkin language. They test the entire flow of information from the application\u0026#x27;s end user input to the end of its process. If possible, we avoid using mock services here.\u003c/p\u003e\u003cp\u003eExample:\u003c/p\u003e\u003cul\u003e\u003cli\u003eproduct purchase on the website\u003c/li\u003e\u003cli\u003esending the application via the contact form\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html\"\u003ehttps://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"8vsof","text":"In every book about functional testing, you will find a standard division into tests, as shown in the illustration below. These describe technical and business functional requirements, hence the name functional tests. Also this is why functional tests should be a source of documentation.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"345c5","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"7alco","text":"\nLet us try to discuss the attributes of each kind.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6eqob","text":"Unit tests","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9aiue","text":"They are responsible for validating the correctness of the solution of the smallest logical unit in our application. For some it can be a single method or class, for others it can be an entire component as long as you are not performing I / O operations.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3frvp","text":"Examples:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"37uiv","text":"method verifying the correctness of the user's password","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"68p18","text":"calculation of the discount of products in the customer's cart","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"131ln","text":"The two most important parameters for this group of tests are isolation and speed.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bmgiq","text":"Isolation","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"76q67","text":"Tests must be independent and operate in an isolated environment, most often called testing. Any external change, such as an environment variable, connection to a database, external service or file system, will violate this rule.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"159gj","text":"Speed","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1ohga","text":"It is a very subjective matter, so the time it takes to execute unit tests will depend largely on the assumptions of the team, but should not exceed a few seconds. In some projects, the very launch of the tests is problematic. Be careful not to load unnecessary libraries during their startup.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bfjml","text":"Integration tests","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7iqfd","text":"The main difference to unit testing is the focus on validating behavior between components. Isolation and speed will not play a major role, but they are still worth remembering and making exceptions only in exceptional cases. After all, we do not want to be surprised by the long running CI, and even more randomly falling tests.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d7aj8","text":"Example:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2bo7v","text":"saving user sessions to the database","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"57jke","text":"reading weather data from API","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f0009","text":"confirmation of sending the payment by the system","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5v1v3","text":"E2E (end to end) tests","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fp0kt","text":"They are the highest-level type of verification of the functional assumptions of our solution. They are often written with the help of user stories in the Gherkin language. They test the entire flow of information from the application's end user input to the end of its process. If possible, we avoid using mock services here.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"98b2m","text":"Example:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"35fo6","text":"product purchase on the website","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1dr63","text":"sending the application via the contact form","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dkgo4","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4c704","text":"https://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":87,"key":1}],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/7eccc644-31a3-4721-b2cc-6dd161464eec.png?response-content-disposition=attachment%3Bfilename%3Dtesting_piramid.png\u0026Expires=1621245591\u0026Signature=gY6RDhNpIdGqah4NJO8CDWa5~zWd-352C1d1~xpJOexsBhJ1SxayQVoRyZJ1jqXPP5CSFBrHQgyJLb8vAUMg-AzNks3~mZkrcMGaoZjl-RxnuqGt~YwXvTF2GzXJk7~0JvelnQWm779dSs67Uu759gGPxNym3HK8skrF3RiHRHadyeFC46a-H5K4-8roc5qembbxPVceIKYszWxfJWlFydtH3Tg84M5Q13LA4b0wrVqudCf3fgRbZvNYrQP5-Oic88o4pFsa9TFgcZNJF3jw1MY0rEDcZfcWupBUalLmVvGoe2khukpuUWs5L283SzedwMIgcEl4lhNGG8uDmcqSGQ__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3011"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html","url":"https://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html"}}}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Functional tests","body":null,"serialized_body":"\u003cp\u003eIn every book about functional testing, you will find a standard division into tests, as shown in the illustration below. These describe technical and business functional requirements, hence the name functional tests. Also this is why functional tests should be a source of documentation.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/7eccc644-31a3-4721-b2cc-6dd161464eec.png?response-content-disposition=attachment%3Bfilename%3Dtesting_piramid.png\u0026amp;Expires=1621245591\u0026amp;Signature=gY6RDhNpIdGqah4NJO8CDWa5~zWd-352C1d1~xpJOexsBhJ1SxayQVoRyZJ1jqXPP5CSFBrHQgyJLb8vAUMg-AzNks3~mZkrcMGaoZjl-RxnuqGt~YwXvTF2GzXJk7~0JvelnQWm779dSs67Uu759gGPxNym3HK8skrF3RiHRHadyeFC46a-H5K4-8roc5qembbxPVceIKYszWxfJWlFydtH3Tg84M5Q13LA4b0wrVqudCf3fgRbZvNYrQP5-Oic88o4pFsa9TFgcZNJF3jw1MY0rEDcZfcWupBUalLmVvGoe2khukpuUWs5L283SzedwMIgcEl4lhNGG8uDmcqSGQ__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\nLet us try to discuss the attributes of each kind.\u003c/p\u003e\u003ch3\u003eUnit tests\u003c/h3\u003e\u003cp\u003eThey are responsible for validating the correctness of the solution of the smallest logical unit in our application. For some it can be a single method or class, for others it can be an entire component as long as you are not performing I / O operations.\u003c/p\u003e\u003cp\u003eExamples:\u003c/p\u003e\u003cul\u003e\u003cli\u003emethod verifying the correctness of the user\u0026#x27;s password\u003c/li\u003e\u003cli\u003ecalculation of the discount of products in the customer\u0026#x27;s cart\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe two most important parameters for this group of tests are isolation and speed.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eIsolation\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eTests must be independent and operate in an isolated environment, most often called testing. Any external change, such as an environment variable, connection to a database, external service or file system, will violate this rule.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSpeed\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIt is a very subjective matter, so the time it takes to execute unit tests will depend largely on the assumptions of the team, but should not exceed a few seconds. In some projects, the very launch of the tests is problematic. Be careful not to load unnecessary libraries during their startup.\u003c/p\u003e\u003ch3\u003eIntegration tests\u003c/h3\u003e\u003cp\u003eThe main difference to unit testing is the focus on validating behavior between components. Isolation and speed will not play a major role, but they are still worth remembering and making exceptions only in exceptional cases. After all, we do not want to be surprised by the long running CI, and even more randomly falling tests.\u003c/p\u003e\u003cp\u003eExample:\u003c/p\u003e\u003cul\u003e\u003cli\u003esaving user sessions to the database\u003c/li\u003e\u003cli\u003ereading weather data from API\u003c/li\u003e\u003cli\u003econfirmation of sending the payment by the system\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003eE2E (end to end) tests\u003c/h3\u003e\u003cp\u003eThey are the highest-level type of verification of the functional assumptions of our solution. They are often written with the help of user stories in the Gherkin language. They test the entire flow of information from the application\u0026#x27;s end user input to the end of its process. If possible, we avoid using mock services here.\u003c/p\u003e\u003cp\u003eExample:\u003c/p\u003e\u003cul\u003e\u003cli\u003eproduct purchase on the website\u003c/li\u003e\u003cli\u003esending the application via the contact form\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html\"\u003ehttps://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"8vsof","text":"In every book about functional testing, you will find a standard division into tests, as shown in the illustration below. These describe technical and business functional requirements, hence the name functional tests. Also this is why functional tests should be a source of documentation.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"345c5","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"7alco","text":"\nLet us try to discuss the attributes of each kind.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6eqob","text":"Unit tests","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9aiue","text":"They are responsible for validating the correctness of the solution of the smallest logical unit in our application. For some it can be a single method or class, for others it can be an entire component as long as you are not performing I / O operations.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3frvp","text":"Examples:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"37uiv","text":"method verifying the correctness of the user's password","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"68p18","text":"calculation of the discount of products in the customer's cart","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"131ln","text":"The two most important parameters for this group of tests are isolation and speed.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bmgiq","text":"Isolation","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"76q67","text":"Tests must be independent and operate in an isolated environment, most often called testing. Any external change, such as an environment variable, connection to a database, external service or file system, will violate this rule.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"159gj","text":"Speed","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1ohga","text":"It is a very subjective matter, so the time it takes to execute unit tests will depend largely on the assumptions of the team, but should not exceed a few seconds. In some projects, the very launch of the tests is problematic. Be careful not to load unnecessary libraries during their startup.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bfjml","text":"Integration tests","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7iqfd","text":"The main difference to unit testing is the focus on validating behavior between components. Isolation and speed will not play a major role, but they are still worth remembering and making exceptions only in exceptional cases. After all, we do not want to be surprised by the long running CI, and even more randomly falling tests.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d7aj8","text":"Example:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2bo7v","text":"saving user sessions to the database","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"57jke","text":"reading weather data from API","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f0009","text":"confirmation of sending the payment by the system","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5v1v3","text":"E2E (end to end) tests","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fp0kt","text":"They are the highest-level type of verification of the functional assumptions of our solution. They are often written with the help of user stories in the Gherkin language. They test the entire flow of information from the application's end user input to the end of its process. If possible, we avoid using mock services here.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"98b2m","text":"Example:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"35fo6","text":"product purchase on the website","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1dr63","text":"sending the application via the contact form","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dkgo4","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4c704","text":"https://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":87,"key":1}],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/7eccc644-31a3-4721-b2cc-6dd161464eec.png?response-content-disposition=attachment%3Bfilename%3Dtesting_piramid.png\u0026Expires=1621245591\u0026Signature=gY6RDhNpIdGqah4NJO8CDWa5~zWd-352C1d1~xpJOexsBhJ1SxayQVoRyZJ1jqXPP5CSFBrHQgyJLb8vAUMg-AzNks3~mZkrcMGaoZjl-RxnuqGt~YwXvTF2GzXJk7~0JvelnQWm779dSs67Uu759gGPxNym3HK8skrF3RiHRHadyeFC46a-H5K4-8roc5qembbxPVceIKYszWxfJWlFydtH3Tg84M5Q13LA4b0wrVqudCf3fgRbZvNYrQP5-Oic88o4pFsa9TFgcZNJF3jw1MY0rEDcZfcWupBUalLmVvGoe2khukpuUWs5L283SzedwMIgcEl4lhNGG8uDmcqSGQ__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3011"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html","url":"https://jessewarden.com/2018/06/functional-programming-unit-testing-in-node-part-1.html"}}}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":2,"attachments_count":1,"presentable":true,"external_id":null,"attachments":[{"id":3011,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/7eccc644-31a3-4721-b2cc-6dd161464eec.png","duration":null,"name":"testing_piramid.png","learner_visible":true,"confirmed":false,"user_id":666,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2021-05-17T11:29:51.626+02:00","sources":[]}]},{"id":1738,"position":6,"new_position":6,"published_attributes":{"type":"slide","answers":[],"title":"Non-functional tests","body":null,"serialized_body":"\u003cp\u003eSo what are non-functional requirements?\u003c/p\u003e\u003cp\u003eUsually those answer the question what the system should be like instead of what the system should do. These non-functional constraints enhance the actual functionalities of our systems. Lets have an example:\u003c/p\u003e\u003cp\u003eBelow we can see a trivial login screen. The main functionality is to allow the end user to log in. Users should not think about anything else but we require from our system to work fast to provide the best user experience. That\u0026#x27;s why one of the performance requirements is to render the page in less than 300 ms. We also have some security restrictions like blocking the user access to the app in case of 3 unsuccessful attempts or making password time attacks more difficult to achieve.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/fc32682b-c496-4bd1-bf64-ef1311195e8a.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-20%2Bo%2B13.09.16.png\u0026amp;Expires=1621510778\u0026amp;Signature=Q1l1oLXvXbD1~sEa78Q2YrYzFCB-6ahjXcmhyGxf8mrxZjfGK1mP-gWnpgggMGCdkvaZymbCuqrtS8ora-ccqXSyuiFMy941mr9C-kSO1fWsrt0oU1VBm4qRLVgli~qr-K4BWnEwnn00G9hskJhRlnzCLPEB7hOBdtAkM2UwV42NGYRNMPA-62N32597WsBGdTNW75kRxSWiJSadXWt6P7qBlpgKf0NsUFOx34~sOgrmiakTJsg8~BXcWbuUwiCeLZa7oW1~ELMHNyrsgRRHp980-ehFV6SwcbGMICNF6LK6AiTJwwh~9fLo4KwUgPKiK3QhPXDEJMol3BQaB0gFxg__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003eAs you can see functional requirements are built around the end user and non-functional around the system. They describe capabilities and attribute qualities instead of behaviours.\u003c/p\u003e\u003cp\u003eThere are many different examples of non-functional tests but most popular kinds are:\u003c/p\u003e\u003cul\u003e\u003cli\u003eperformance\u003c/li\u003e\u003cli\u003esecurity\u003c/li\u003e\u003cli\u003eusability\u003c/li\u003e\u003cli\u003elocalization\u003c/li\u003e\u003cli\u003ereliability\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eActually everything that can be measured can be also tested explicitly or implicitly by automated test suites or set of metrics and system alerts.\u003c/p\u003e\u003cp\u003eI\u0026#x27;ve also found very interesting description of a family of performance tests written by our Netgural Marta Grzesiak:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eStress testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis test pushes an application beyond normal load conditions to determine which components fail first. Stress testing attempts to find the breaking point of the application and is used to evaluate the robustness of the applications data processing capabilities and response to high volumes of traffic.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eSpike testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis testing evaluates the ability of the application to handle sudden volume increases. It is done by suddenly increasing the load generated by a very large number of users. The goal is to determine whether performance will suffer, the system will fail, or it will be able to handle dramatic changes in load. This testing is critical for applications that experience large increases in number of users; for example, utility customers reporting power outages during storms. This can be considered a component of stress testing.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eLoad testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe purpose of load testing is to evaluate the applications performance under increasingly high numbers of users. Load, or increasing numbers of users are applied to the application under test and the results are measured to validate the requirements are met. This load can be the expected concurrent number of users on the application performing a specific number of transactions within the set duration. This test will give out the response times of all the important business critical transactions. If the database, application server, etc. are also monitored, then this simple test can itself point towards bottlenecks in the application software.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eEndurance testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eEndurance testing evaluates the performance of the system under load over time. It is executed by applying varying loads to the application under test for an extended period of time to validate that the performance requirements related to production loads and durations of those loads are met. Endurance testing can be considered a component of load testing and is also known as soak testing.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eVolume testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAlso known as flood testing, this testing is used to evaluate the applications ability to handle large volumes of data. The impact on response time and the behavior of the application are analyzed. This testing can be used to identify bottlenecks and to determine the capacity of the system. This type of performance testing is important for applications that deal with big data.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eScalability testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis testing is used to determine your applications ability to handle increasing amounts of load and processing. It involves measuring attributes including response time, throughput, hits and requests per second, transaction processing speed, CPU usage, Network usage and more. Results of this testing can be used in the planning and design phases of development which reduces costs and mitigates the potential for performance issues.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity\"\u003ehttps://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"4k31j","text":"So what are non-functional requirements?","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3b4p7","text":"Usually those answer the question what the system should be like instead of what the system should do. These non-functional constraints enhance the actual functionalities of our systems. Lets have an example:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9ht9m","text":"Below we can see a trivial login screen. The main functionality is to allow the end user to log in. Users should not think about anything else but we require from our system to work fast to provide the best user experience. That's why one of the performance requirements is to render the page in less than 300 ms. We also have some security restrictions like blocking the user access to the app in case of 3 unsuccessful attempts or making password time attacks more difficult to achieve.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4keds","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"d5oi8","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"df2bl","text":"As you can see functional requirements are built around the end user and non-functional around the system. They describe capabilities and attribute qualities instead of behaviours.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5masj","text":"There are many different examples of non-functional tests but most popular kinds are:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bjuu3","text":"performance","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ufde","text":"security","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4952v","text":"usability","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e535u","text":"localization","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"uhr1","text":"reliability","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4k47q","text":"Actually everything that can be measured can be also tested explicitly or implicitly by automated test suites or set of metrics and system alerts.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c4dl5","text":"I've also found very interesting description of a family of performance tests written by our Netgural Marta Grzesiak:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fef1o","text":"Stress testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":14,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"djmp5","text":"This test pushes an application beyond normal load conditions to determine which components fail first. Stress testing attempts to find the breaking point of the application and is used to evaluate the robustness of the applications data processing capabilities and response to high volumes of traffic.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ma54","text":"Spike testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fqqjg","text":"This testing evaluates the ability of the application to handle sudden volume increases. It is done by suddenly increasing the load generated by a very large number of users. The goal is to determine whether performance will suffer, the system will fail, or it will be able to handle dramatic changes in load. This testing is critical for applications that experience large increases in number of users; for example, utility customers reporting power outages during storms. This can be considered a component of stress testing.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7k6cp","text":"Load testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6j6mf","text":"The purpose of load testing is to evaluate the applications performance under increasingly high numbers of users. Load, or increasing numbers of users are applied to the application under test and the results are measured to validate the requirements are met. This load can be the expected concurrent number of users on the application performing a specific number of transactions within the set duration. This test will give out the response times of all the important business critical transactions. If the database, application server, etc. are also monitored, then this simple test can itself point towards bottlenecks in the application software.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"njoi","text":"Endurance testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"877cn","text":"Endurance testing evaluates the performance of the system under load over time. It is executed by applying varying loads to the application under test for an extended period of time to validate that the performance requirements related to production loads and durations of those loads are met. Endurance testing can be considered a component of load testing and is also known as soak testing.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4p9tr","text":"Volume testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":14,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a30oc","text":"Also known as flood testing, this testing is used to evaluate the applications ability to handle large volumes of data. The impact on response time and the behavior of the application are analyzed. This testing can be used to identify bottlenecks and to determine the capacity of the system. This type of performance testing is important for applications that deal with big data.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b31n6","text":"Scalability testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2qpac","text":"This testing is used to determine your applications ability to handle increasing amounts of load and processing. It involves measuring attributes including response time, throughput, hits and requests per second, transaction processing speed, CPU usage, Network usage and more. Results of this testing can be used in the planning and design phases of development which reduces costs and mitigates the potential for performance issues.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"15kl3","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"889hu","text":"https://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":188,"key":1}],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/fc32682b-c496-4bd1-bf64-ef1311195e8a.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-20%2Bo%2B13.09.16.png\u0026Expires=1621510778\u0026Signature=Q1l1oLXvXbD1~sEa78Q2YrYzFCB-6ahjXcmhyGxf8mrxZjfGK1mP-gWnpgggMGCdkvaZymbCuqrtS8ora-ccqXSyuiFMy941mr9C-kSO1fWsrt0oU1VBm4qRLVgli~qr-K4BWnEwnn00G9hskJhRlnzCLPEB7hOBdtAkM2UwV42NGYRNMPA-62N32597WsBGdTNW75kRxSWiJSadXWt6P7qBlpgKf0NsUFOx34~sOgrmiakTJsg8~BXcWbuUwiCeLZa7oW1~ELMHNyrsgRRHp980-ehFV6SwcbGMICNF6LK6AiTJwwh~9fLo4KwUgPKiK3QhPXDEJMol3BQaB0gFxg__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3023"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity","text":"https://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity"}}}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Non-functional tests","body":null,"serialized_body":"\u003cp\u003eSo what are non-functional requirements?\u003c/p\u003e\u003cp\u003eUsually those answer the question what the system should be like instead of what the system should do. These non-functional constraints enhance the actual functionalities of our systems. Lets have an example:\u003c/p\u003e\u003cp\u003eBelow we can see a trivial login screen. The main functionality is to allow the end user to log in. Users should not think about anything else but we require from our system to work fast to provide the best user experience. That\u0026#x27;s why one of the performance requirements is to render the page in less than 300 ms. We also have some security restrictions like blocking the user access to the app in case of 3 unsuccessful attempts or making password time attacks more difficult to achieve.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/fc32682b-c496-4bd1-bf64-ef1311195e8a.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-20%2Bo%2B13.09.16.png\u0026amp;Expires=1621510778\u0026amp;Signature=Q1l1oLXvXbD1~sEa78Q2YrYzFCB-6ahjXcmhyGxf8mrxZjfGK1mP-gWnpgggMGCdkvaZymbCuqrtS8ora-ccqXSyuiFMy941mr9C-kSO1fWsrt0oU1VBm4qRLVgli~qr-K4BWnEwnn00G9hskJhRlnzCLPEB7hOBdtAkM2UwV42NGYRNMPA-62N32597WsBGdTNW75kRxSWiJSadXWt6P7qBlpgKf0NsUFOx34~sOgrmiakTJsg8~BXcWbuUwiCeLZa7oW1~ELMHNyrsgRRHp980-ehFV6SwcbGMICNF6LK6AiTJwwh~9fLo4KwUgPKiK3QhPXDEJMol3BQaB0gFxg__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003eAs you can see functional requirements are built around the end user and non-functional around the system. They describe capabilities and attribute qualities instead of behaviours.\u003c/p\u003e\u003cp\u003eThere are many different examples of non-functional tests but most popular kinds are:\u003c/p\u003e\u003cul\u003e\u003cli\u003eperformance\u003c/li\u003e\u003cli\u003esecurity\u003c/li\u003e\u003cli\u003eusability\u003c/li\u003e\u003cli\u003elocalization\u003c/li\u003e\u003cli\u003ereliability\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eActually everything that can be measured can be also tested explicitly or implicitly by automated test suites or set of metrics and system alerts.\u003c/p\u003e\u003cp\u003eI\u0026#x27;ve also found very interesting description of a family of performance tests written by our Netgural Marta Grzesiak:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eStress testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis test pushes an application beyond normal load conditions to determine which components fail first. Stress testing attempts to find the breaking point of the application and is used to evaluate the robustness of the applications data processing capabilities and response to high volumes of traffic.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eSpike testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis testing evaluates the ability of the application to handle sudden volume increases. It is done by suddenly increasing the load generated by a very large number of users. The goal is to determine whether performance will suffer, the system will fail, or it will be able to handle dramatic changes in load. This testing is critical for applications that experience large increases in number of users; for example, utility customers reporting power outages during storms. This can be considered a component of stress testing.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eLoad testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe purpose of load testing is to evaluate the applications performance under increasingly high numbers of users. Load, or increasing numbers of users are applied to the application under test and the results are measured to validate the requirements are met. This load can be the expected concurrent number of users on the application performing a specific number of transactions within the set duration. This test will give out the response times of all the important business critical transactions. If the database, application server, etc. are also monitored, then this simple test can itself point towards bottlenecks in the application software.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eEndurance testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eEndurance testing evaluates the performance of the system under load over time. It is executed by applying varying loads to the application under test for an extended period of time to validate that the performance requirements related to production loads and durations of those loads are met. Endurance testing can be considered a component of load testing and is also known as soak testing.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eVolume testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAlso known as flood testing, this testing is used to evaluate the applications ability to handle large volumes of data. The impact on response time and the behavior of the application are analyzed. This testing can be used to identify bottlenecks and to determine the capacity of the system. This type of performance testing is important for applications that deal with big data.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cstrong\u003eScalability testing\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis testing is used to determine your applications ability to handle increasing amounts of load and processing. It involves measuring attributes including response time, throughput, hits and requests per second, transaction processing speed, CPU usage, Network usage and more. Results of this testing can be used in the planning and design phases of development which reduces costs and mitigates the potential for performance issues.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity\"\u003ehttps://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"4k31j","text":"So what are non-functional requirements?","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3b4p7","text":"Usually those answer the question what the system should be like instead of what the system should do. These non-functional constraints enhance the actual functionalities of our systems. Lets have an example:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9ht9m","text":"Below we can see a trivial login screen. The main functionality is to allow the end user to log in. Users should not think about anything else but we require from our system to work fast to provide the best user experience. That's why one of the performance requirements is to render the page in less than 300 ms. We also have some security restrictions like blocking the user access to the app in case of 3 unsuccessful attempts or making password time attacks more difficult to achieve.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4keds","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"d5oi8","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"df2bl","text":"As you can see functional requirements are built around the end user and non-functional around the system. They describe capabilities and attribute qualities instead of behaviours.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5masj","text":"There are many different examples of non-functional tests but most popular kinds are:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bjuu3","text":"performance","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ufde","text":"security","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4952v","text":"usability","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e535u","text":"localization","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"uhr1","text":"reliability","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4k47q","text":"Actually everything that can be measured can be also tested explicitly or implicitly by automated test suites or set of metrics and system alerts.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c4dl5","text":"I've also found very interesting description of a family of performance tests written by our Netgural Marta Grzesiak:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fef1o","text":"Stress testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":14,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"djmp5","text":"This test pushes an application beyond normal load conditions to determine which components fail first. Stress testing attempts to find the breaking point of the application and is used to evaluate the robustness of the applications data processing capabilities and response to high volumes of traffic.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ma54","text":"Spike testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fqqjg","text":"This testing evaluates the ability of the application to handle sudden volume increases. It is done by suddenly increasing the load generated by a very large number of users. The goal is to determine whether performance will suffer, the system will fail, or it will be able to handle dramatic changes in load. This testing is critical for applications that experience large increases in number of users; for example, utility customers reporting power outages during storms. This can be considered a component of stress testing.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7k6cp","text":"Load testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6j6mf","text":"The purpose of load testing is to evaluate the applications performance under increasingly high numbers of users. Load, or increasing numbers of users are applied to the application under test and the results are measured to validate the requirements are met. This load can be the expected concurrent number of users on the application performing a specific number of transactions within the set duration. This test will give out the response times of all the important business critical transactions. If the database, application server, etc. are also monitored, then this simple test can itself point towards bottlenecks in the application software.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"njoi","text":"Endurance testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"877cn","text":"Endurance testing evaluates the performance of the system under load over time. It is executed by applying varying loads to the application under test for an extended period of time to validate that the performance requirements related to production loads and durations of those loads are met. Endurance testing can be considered a component of load testing and is also known as soak testing.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4p9tr","text":"Volume testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":14,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a30oc","text":"Also known as flood testing, this testing is used to evaluate the applications ability to handle large volumes of data. The impact on response time and the behavior of the application are analyzed. This testing can be used to identify bottlenecks and to determine the capacity of the system. This type of performance testing is important for applications that deal with big data.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b31n6","text":"Scalability testing","type":"header-five","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2qpac","text":"This testing is used to determine your applications ability to handle increasing amounts of load and processing. It involves measuring attributes including response time, throughput, hits and requests per second, transaction processing speed, CPU usage, Network usage and more. Results of this testing can be used in the planning and design phases of development which reduces costs and mitigates the potential for performance issues.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"15kl3","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"889hu","text":"https://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":188,"key":1}],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/fc32682b-c496-4bd1-bf64-ef1311195e8a.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-20%2Bo%2B13.09.16.png\u0026Expires=1621510778\u0026Signature=Q1l1oLXvXbD1~sEa78Q2YrYzFCB-6ahjXcmhyGxf8mrxZjfGK1mP-gWnpgggMGCdkvaZymbCuqrtS8ora-ccqXSyuiFMy941mr9C-kSO1fWsrt0oU1VBm4qRLVgli~qr-K4BWnEwnn00G9hskJhRlnzCLPEB7hOBdtAkM2UwV42NGYRNMPA-62N32597WsBGdTNW75kRxSWiJSadXWt6P7qBlpgKf0NsUFOx34~sOgrmiakTJsg8~BXcWbuUwiCeLZa7oW1~ELMHNyrsgRRHp980-ehFV6SwcbGMICNF6LK6AiTJwwh~9fLo4KwUgPKiK3QhPXDEJMol3BQaB0gFxg__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3023"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity","text":"https://netguru.atlassian.net/wiki/spaces/PRS/pages/2730296955/How+to+estimate+performance+tests+in+the+Discovery+phase+Introduction+to+performance+testing+types+and+spotting+the+necessity"}}}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":4,"attachments_count":1,"presentable":true,"external_id":null,"attachments":[{"id":3023,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/fc32682b-c496-4bd1-bf64-ef1311195e8a.png","duration":null,"name":"Zrzut ekranu 2021-05-20 o 13.09.16.png","learner_visible":true,"confirmed":false,"user_id":666,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2021-05-20T13:09:38.645+02:00","sources":[]}]},{"id":1747,"position":7,"new_position":7,"published_attributes":{"type":"slide","answers":[],"title":"Popular test smells","body":null,"serialized_body":"\u003cp\u003eThese are one of the main reasons why our test suites become neglected. Our tests are also code and even if they are not part of a production application they should be treated as first class citizens in our project. Here is the list of popular test smells we can find in our app and solutions to fix them.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSlow tests\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis is definitely the most smelly element of our test suites. It\u0026#x27;s the reason developers stop depending on tests and do not run them on a regular basis. I\u0026#x27;ve worked on a project that tests were taking over 30min and developers were going for a walk in the meantime... If that\u0026#x27;s the case in your example, you start seeing that waiting for tests to finish takes more than a couple of seconds. It\u0026#x27;s high time to change it.\u003c/p\u003e\u003cp\u003eAction steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003eFirst of all, order your test results based on spec speed. It should be easy to spot the ones that are exceeding the common threshold.\u003c/li\u003e\u003cli\u003eIf you are working with large codebase you should try to group your specs by some boundary contexts and run only the related suites\u003c/li\u003e\u003cli\u003eIf your app boots up too slowly before you run the spec, investigate the cause of it. Maybe there are deprecated or circular dependencies, network issues, etc\u003c/li\u003e\u003cli\u003eThere is high chance that your test framework has support for multiple CPU cores. By default, such options are usually disabled.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eRandomly failing specs\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eRaise the hand if you haven\u0026#x27;t seen randomly failing CI or your local test suites so far. You are probably the luckiest developer walking on earth :) Very often specs fail randomly because there are some leftovers after running some other spec for the first time.\u003c/p\u003e\u003cp\u003eLets have a couple examples:\u003c/p\u003e\u003cul\u003e\u003cli\u003ea data storage is not cleaned properly\u003c/li\u003e\u003cli\u003ethere is a dependency on the other test\u0026#x27;s setup\u003c/li\u003e\u003cli\u003ean environment variable is modified\u003c/li\u003e\u003cli\u003ethere is modification to file system\u003c/li\u003e\u003cli\u003ean external service/mock could be modified\u003c/li\u003e\u003cli\u003ea global object is modified\u003c/li\u003e\u003cli\u003etest is too slow\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eEven if it seems obvious for us to have data clean after each test, we tend to forget about it due to libraries we use to do most of the cleaning for us. Lack of proper understanding of those libraries may lead to violation of the isolation principle.\u003c/p\u003e\u003cp\u003eAction steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003eIf you spotted randomly failing spec act immediately, there is a chance that recent changes made the CI to fail\u003c/li\u003e\u003cli\u003eTo find the issue use test seed to run the tests in the same order, change format of your test runner to documentation instead of dots to figure out which specs where running before and might have negative impact\u003c/li\u003e\u003cli\u003eLearn your libraries which support your testing environment\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eCode is hard to test\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThere are at least three cases that come to my mind but probably you can find more. First one is the communication with some external services that are responding slowly, are often unavailable or don\u0026#x27;t provide a testing environment at all that we could test against. The other example is when we have a very long process that should result in some output. And the last when we take over a legacy code that is written in poor manner without code coverage.\u003c/p\u003e\u003cp\u003eWhere to start and how to handle those situations? As the first two mentioned are quite similar, the solution will be the same.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/98123a10-6078-40f7-9c64-4e32dcefbc15.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-25%2Bo%2B18.17.01.png\u0026amp;Expires=1621961242\u0026amp;Signature=riEj3G-ksh63v7eKVPk39Amf07rMoWpTKUHiWjBxD02gNG7zdjulcvVVtoIAbwCBXI10zALCz6wSg5bsZCTtOqa1Bo-VvAFsKveRwS4OXNo5z-G0Tm~1j1bk2lYtaTfxH~GXveKEfE6kxXV2Ji58RlDZV~solezyhdvB9JvRAUnUNHhsJytXgca1BAkeLQDSTKvIctyv6sHr8gdVmMStvhv0ly1p9M~9E71MQYgzUJfsidJTfB2qMsA8B-MTfoCqEg57DLA3wsxS62VwrLA9P4cAF5DxirapUJaHssSbAX3fkz2Cf59tfI3L0VmS5tvXMYSMjUu7tH9vEFd5o~46rg__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\nBased on the example, let us approach the problem from different angles.\u003c/p\u003e\u003cul\u003e\u003cli\u003euse VCR tooling to record response from the stock and payment services\u003c/li\u003e\u003cli\u003ebuild testing mock of stock and payment services\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNo matter what solution you pick up you should remember to have contract tests for those services anyway. Thanks to that you will know when services have changed their API.\u003c/p\u003e\u003cp\u003eRegarding legacy code we should be careful. If the current specs are yacky or there are no specs at all the most reasonable would be to start from covering the main functionalities with e2e or integration specs and then modifying the codebase and adjusting it to our needs.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDuplicated assertions\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWhen we are focused on testing a specific functionality, we tend to repeat some assertions despite the fact that the given part was already tested before. It happens due to copying and pasting previous tests. Take a look on this example:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003edescribe(\u0026#x27;BookCreation\u0026#x27;, () =\u0026gt; {\n  it(\u0026#x27;return book object\u0026#x27;, async () =\u0026gt; {\n   const bookParams = { \u0026quot;title\u0026quot;: \u0026quot;Harry\u0026quot; } \n   const { body: book } = \u003cem\u003eawait\u003c/em\u003e request(app)\n     .post(\u0026#x27;/books\u0026#x27;)\n     .send(bookParams)\n     .expect(200);\n\n   expect(book).toBeObject();\n });\n\n it(\u0026#x27;allow to create book with spaces\u0026#x27;, async () =\u0026gt; {\n   const bookParams = { \u0026quot;title\u0026quot;: \u0026quot;Harry Potter\u0026quot; } \n   const { body: book } = \u003cem\u003eawait\u003c/em\u003e request(app)\n     .post(\u0026#x27;books\u0026#x27;)\n     .send(bookParams)\n     .expect(200);\n \n   expect(book.title).toEql(\u0026quot;Harry Potter\u0026quot;);\n });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eExpecting the same status code from the book creation doesn\u0026#x27;t make sense as it\u0026#x27;s about the same result. If we decide to change a behaviour from synchronous to asynchronous and change the status code to 202 both spec will fail despite the fact they test different things.\u003c/p\u003e\u003cp\u003eAction step:\u003c/p\u003e\u003cul\u003e\u003cli\u003eTry to keep in mind that single test should have only one reason to fail\u003c/li\u003e\u003cli\u003eDon\u0026#x27;t be afraid to remove duplicated assertions or even whole specs from your codebase\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eFragile tests\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe have one or more tests that used to run and pass which either fail to compile and run or fail when they are run. Whenever we introduce a change to our codebase but is not related to any production code or tests then we have a case of Fragile Test. There are four of sensitivities that cause our system under test to fail:\u003c/p\u003e\u003cul\u003e\u003cli\u003eInterface sensitivity - errors start to popup that say that method is undefined or class does not exists, etc\u003c/li\u003e\u003cli\u003eBehaviour sensitivity - we didn\u0026#x27;t change production code but we changed mocks/tests setups/teardowns etc\u003c/li\u003e\u003cli\u003eData sensitivity - database or fixtures were modified\u003c/li\u003e\u003cli\u003eContext sensitivity - there is a change in your testing environment\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTests may be failing because the functionality they are verifying has been modified. This is not a case of behavior sensitivity because it is the whole reason for having regression tests.\u003c/p\u003e\u003cp\u003eAction steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003elook for patterns in how the tests fail. Ask yourself \u0026quot;What do all these broken tests have in common?\u0026quot;. This should help you understand how the tests are coupled.\u003c/li\u003e\u003cli\u003etry to minimize coupling between tests\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eAssertions roulette\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThere is failing spec and we can\u0026#x27;t easily determine which assertion had failed. It\u0026#x27;s a specially annoying when it happens on CI and cannot be reproduced quickly or the spec is weakly isolated and fails randomly.\u003c/p\u003e\u003cp\u003eAction steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003eavoid multiple asserts that tests different requirements\u003c/li\u003e\u003cli\u003ein case of many steps in our test, consider using some other way to set up the fixture for the latter parts of the test\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://testsmells.org/pages/testsmells.html\"\u003ehttps://testsmells.org/pages/testsmells.html\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code\"\u003ehttp://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"46isa","text":"These are one of the main reasons why our test suites become neglected. Our tests are also code and even if they are not part of a production application they should be treated as first class citizens in our project. Here is the list of popular test smells we can find in our app and solutions to fix them.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bjqvd","text":"Slow tests","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"31l2f","text":"This is definitely the most smelly element of our test suites. It's the reason developers stop depending on tests and do not run them on a regular basis. I've worked on a project that tests were taking over 30min and developers were going for a walk in the meantime... If that's the case in your example, you start seeing that waiting for tests to finish takes more than a couple of seconds. It's high time to change it.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f1898","text":"Action steps:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6ikuv","text":"First of all, order your test results based on spec speed. It should be easy to spot the ones that are exceeding the common threshold.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"447sn","text":"If you are working with large codebase you should try to group your specs by some boundary contexts and run only the related suites","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5u6hu","text":"If your app boots up too slowly before you run the spec, investigate the cause of it. Maybe there are deprecated or circular dependencies, network issues, etc","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dfalb","text":"There is high chance that your test framework has support for multiple CPU cores. By default, such options are usually disabled.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c2u2i","text":"Randomly failing specs","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1lbll","text":"Raise the hand if you haven't seen randomly failing CI or your local test suites so far. You are probably the luckiest developer walking on earth :) Very often specs fail randomly because there are some leftovers after running some other spec for the first time.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b2ikk","text":"Lets have a couple examples:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1g671","text":"a data storage is not cleaned properly","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fqpdl","text":"there is a dependency on the other test's setup","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f13ft","text":"an environment variable is modified","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7lm3q","text":"there is modification to file system","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ed3hu","text":"an external service/mock could be modified","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"50h7r","text":"a global object is modified","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cge4o","text":"test is too slow","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5iteq","text":"Even if it seems obvious for us to have data clean after each test, we tend to forget about it due to libraries we use to do most of the cleaning for us. Lack of proper understanding of those libraries may lead to violation of the isolation principle.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4pq1d","text":"Action steps:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1orpg","text":"If you spotted randomly failing spec act immediately, there is a chance that recent changes made the CI to fail","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9trv6","text":"To find the issue use test seed to run the tests in the same order, change format of your test runner to documentation instead of dots to figure out which specs where running before and might have negative impact","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6ipkg","text":"Learn your libraries which support your testing environment","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5spia","text":"Code is hard to test","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4djfq","text":"There are at least three cases that come to my mind but probably you can find more. First one is the communication with some external services that are responding slowly, are often unavailable or don't provide a testing environment at all that we could test against. The other example is when we have a very long process that should result in some output. And the last when we take over a legacy code that is written in poor manner without code coverage.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3g48m","text":"Where to start and how to handle those situations? As the first two mentioned are quite similar, the solution will be the same.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"euq4e","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"dk6ro","text":"\nBased on the example, let us approach the problem from different angles.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fjsed","text":"use VCR tooling to record response from the stock and payment services","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ebel","text":"build testing mock of stock and payment services","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d9g05","text":"No matter what solution you pick up you should remember to have contract tests for those services anyway. Thanks to that you will know when services have changed their API.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4g7hf","text":"Regarding legacy code we should be careful. If the current specs are yacky or there are no specs at all the most reasonable would be to start from covering the main functionalities with e2e or integration specs and then modifying the codebase and adjusting it to our needs.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ceaea","text":"Duplicated assertions","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":21,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"cp2ne","text":"When we are focused on testing a specific functionality, we tend to repeat some assertions despite the fact that the given part was already tested before. It happens due to copying and pasting previous tests. Take a look on this example:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c21fa","text":"describe('BookCreation', () =\u003e {\n  it('return book object', async () =\u003e {\n   const bookParams = { \"title\": \"Harry\" } \n   const { body: book } = await request(app)\n     .post('/books')\n     .send(bookParams)\n     .expect(200);\n\n   expect(book).toBeObject();\n });\n\n it('allow to create book with spaces', async () =\u003e {\n   const bookParams = { \"title\": \"Harry Potter\" } \n   const { body: book } = await request(app)\n     .post('books')\n     .send(bookParams)\n     .expect(200);\n \n   expect(book.title).toEql(\"Harry Potter\");\n });\n});","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":144,"length":5,"style":"ITALIC"},{"offset":394,"length":5,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"6i1s3","text":"Expecting the same status code from the book creation doesn't make sense as it's about the same result. If we decide to change a behaviour from synchronous to asynchronous and change the status code to 202 both spec will fail despite the fact they test different things.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dlaqe","text":"Action step:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"19itm","text":"Try to keep in mind that single test should have only one reason to fail","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1rc40","text":"Don't be afraid to remove duplicated assertions or even whole specs from your codebase","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ftcda","text":"Fragile tests","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"l0a8","text":"We have one or more tests that used to run and pass which either fail to compile and run or fail when they are run. Whenever we introduce a change to our codebase but is not related to any production code or tests then we have a case of Fragile Test. There are four of sensitivities that cause our system under test to fail:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7bdq5","text":"Interface sensitivity - errors start to popup that say that method is undefined or class does not exists, etc","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8vmip","text":"Behaviour sensitivity - we didn't change production code but we changed mocks/tests setups/teardowns etc","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fiuk","text":"Data sensitivity - database or fixtures were modified","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"45esa","text":"Context sensitivity - there is a change in your testing environment","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7irse","text":"Tests may be failing because the functionality they are verifying has been modified. This is not a case of behavior sensitivity because it is the whole reason for having regression tests.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"210sa","text":"Action steps:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9cga","text":"look for patterns in how the tests fail. Ask yourself \"What do all these broken tests have in common?\". This should help you understand how the tests are coupled.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1uuu5","text":"try to minimize coupling between tests","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b2hrm","text":"Assertions roulette","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"forer","text":"There is failing spec and we can't easily determine which assertion had failed. It's a specially annoying when it happens on CI and cannot be reproduced quickly or the spec is weakly isolated and fails randomly.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1mm12","text":"Action steps:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fi5v0","text":"avoid multiple asserts that tests different requirements","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2htbo","text":"in case of many steps in our test, consider using some other way to set up the fixture for the latter parts of the test","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"97scp","text":"Read more","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8lvuu","text":"https://testsmells.org/pages/testsmells.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":44,"key":1}],"data":{}},{"key":"brqls","text":"http://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":79,"key":2}],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/98123a10-6078-40f7-9c64-4e32dcefbc15.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-25%2Bo%2B18.17.01.png\u0026Expires=1621961242\u0026Signature=riEj3G-ksh63v7eKVPk39Amf07rMoWpTKUHiWjBxD02gNG7zdjulcvVVtoIAbwCBXI10zALCz6wSg5bsZCTtOqa1Bo-VvAFsKveRwS4OXNo5z-G0Tm~1j1bk2lYtaTfxH~GXveKEfE6kxXV2Ji58RlDZV~solezyhdvB9JvRAUnUNHhsJytXgca1BAkeLQDSTKvIctyv6sHr8gdVmMStvhv0ly1p9M~9E71MQYgzUJfsidJTfB2qMsA8B-MTfoCqEg57DLA3wsxS62VwrLA9P4cAF5DxirapUJaHssSbAX3fkz2Cf59tfI3L0VmS5tvXMYSMjUu7tH9vEFd5o~46rg__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3066"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://testsmells.org/pages/testsmells.html","text":"https://testsmells.org/pages/testsmells.html"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"http://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code","url":"http://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code"}}}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Popular test smells","body":null,"serialized_body":"\u003cp\u003eThese are one of the main reasons why our test suites become neglected. Our tests are also code and even if they are not part of a production application they should be treated as first class citizens in our project. Here is the list of popular test smells we can find in our app and solutions to fix them.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSlow tests\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThis is definitely the most smelly element of our test suites. It\u0026#x27;s the reason developers stop depending on tests and do not run them on a regular basis. I\u0026#x27;ve worked on a project that tests were taking over 30min and developers were going for a walk in the meantime... If that\u0026#x27;s the case in your example, you start seeing that waiting for tests to finish takes more than a couple of seconds. It\u0026#x27;s high time to change it.\u003c/p\u003e\u003cp\u003eAction steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003eFirst of all, order your test results based on spec speed. It should be easy to spot the ones that are exceeding the common threshold.\u003c/li\u003e\u003cli\u003eIf you are working with large codebase you should try to group your specs by some boundary contexts and run only the related suites\u003c/li\u003e\u003cli\u003eIf your app boots up too slowly before you run the spec, investigate the cause of it. Maybe there are deprecated or circular dependencies, network issues, etc\u003c/li\u003e\u003cli\u003eThere is high chance that your test framework has support for multiple CPU cores. By default, such options are usually disabled.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eRandomly failing specs\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eRaise the hand if you haven\u0026#x27;t seen randomly failing CI or your local test suites so far. You are probably the luckiest developer walking on earth :) Very often specs fail randomly because there are some leftovers after running some other spec for the first time.\u003c/p\u003e\u003cp\u003eLets have a couple examples:\u003c/p\u003e\u003cul\u003e\u003cli\u003ea data storage is not cleaned properly\u003c/li\u003e\u003cli\u003ethere is a dependency on the other test\u0026#x27;s setup\u003c/li\u003e\u003cli\u003ean environment variable is modified\u003c/li\u003e\u003cli\u003ethere is modification to file system\u003c/li\u003e\u003cli\u003ean external service/mock could be modified\u003c/li\u003e\u003cli\u003ea global object is modified\u003c/li\u003e\u003cli\u003etest is too slow\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eEven if it seems obvious for us to have data clean after each test, we tend to forget about it due to libraries we use to do most of the cleaning for us. Lack of proper understanding of those libraries may lead to violation of the isolation principle.\u003c/p\u003e\u003cp\u003eAction steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003eIf you spotted randomly failing spec act immediately, there is a chance that recent changes made the CI to fail\u003c/li\u003e\u003cli\u003eTo find the issue use test seed to run the tests in the same order, change format of your test runner to documentation instead of dots to figure out which specs where running before and might have negative impact\u003c/li\u003e\u003cli\u003eLearn your libraries which support your testing environment\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eCode is hard to test\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThere are at least three cases that come to my mind but probably you can find more. First one is the communication with some external services that are responding slowly, are often unavailable or don\u0026#x27;t provide a testing environment at all that we could test against. The other example is when we have a very long process that should result in some output. And the last when we take over a legacy code that is written in poor manner without code coverage.\u003c/p\u003e\u003cp\u003eWhere to start and how to handle those situations? As the first two mentioned are quite similar, the solution will be the same.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/98123a10-6078-40f7-9c64-4e32dcefbc15.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-25%2Bo%2B18.17.01.png\u0026amp;Expires=1621961242\u0026amp;Signature=riEj3G-ksh63v7eKVPk39Amf07rMoWpTKUHiWjBxD02gNG7zdjulcvVVtoIAbwCBXI10zALCz6wSg5bsZCTtOqa1Bo-VvAFsKveRwS4OXNo5z-G0Tm~1j1bk2lYtaTfxH~GXveKEfE6kxXV2Ji58RlDZV~solezyhdvB9JvRAUnUNHhsJytXgca1BAkeLQDSTKvIctyv6sHr8gdVmMStvhv0ly1p9M~9E71MQYgzUJfsidJTfB2qMsA8B-MTfoCqEg57DLA3wsxS62VwrLA9P4cAF5DxirapUJaHssSbAX3fkz2Cf59tfI3L0VmS5tvXMYSMjUu7tH9vEFd5o~46rg__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\nBased on the example, let us approach the problem from different angles.\u003c/p\u003e\u003cul\u003e\u003cli\u003euse VCR tooling to record response from the stock and payment services\u003c/li\u003e\u003cli\u003ebuild testing mock of stock and payment services\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNo matter what solution you pick up you should remember to have contract tests for those services anyway. Thanks to that you will know when services have changed their API.\u003c/p\u003e\u003cp\u003eRegarding legacy code we should be careful. If the current specs are yacky or there are no specs at all the most reasonable would be to start from covering the main functionalities with e2e or integration specs and then modifying the codebase and adjusting it to our needs.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDuplicated assertions\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWhen we are focused on testing a specific functionality, we tend to repeat some assertions despite the fact that the given part was already tested before. It happens due to copying and pasting previous tests. Take a look on this example:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003edescribe(\u0026#x27;BookCreation\u0026#x27;, () =\u0026gt; {\n  it(\u0026#x27;return book object\u0026#x27;, async () =\u0026gt; {\n   const bookParams = { \u0026quot;title\u0026quot;: \u0026quot;Harry\u0026quot; } \n   const { body: book } = \u003cem\u003eawait\u003c/em\u003e request(app)\n     .post(\u0026#x27;/books\u0026#x27;)\n     .send(bookParams)\n     .expect(200);\n\n   expect(book).toBeObject();\n });\n\n it(\u0026#x27;allow to create book with spaces\u0026#x27;, async () =\u0026gt; {\n   const bookParams = { \u0026quot;title\u0026quot;: \u0026quot;Harry Potter\u0026quot; } \n   const { body: book } = \u003cem\u003eawait\u003c/em\u003e request(app)\n     .post(\u0026#x27;books\u0026#x27;)\n     .send(bookParams)\n     .expect(200);\n \n   expect(book.title).toEql(\u0026quot;Harry Potter\u0026quot;);\n });\n});\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eExpecting the same status code from the book creation doesn\u0026#x27;t make sense as it\u0026#x27;s about the same result. If we decide to change a behaviour from synchronous to asynchronous and change the status code to 202 both spec will fail despite the fact they test different things.\u003c/p\u003e\u003cp\u003eAction step:\u003c/p\u003e\u003cul\u003e\u003cli\u003eTry to keep in mind that single test should have only one reason to fail\u003c/li\u003e\u003cli\u003eDon\u0026#x27;t be afraid to remove duplicated assertions or even whole specs from your codebase\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eFragile tests\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eWe have one or more tests that used to run and pass which either fail to compile and run or fail when they are run. Whenever we introduce a change to our codebase but is not related to any production code or tests then we have a case of Fragile Test. There are four of sensitivities that cause our system under test to fail:\u003c/p\u003e\u003cul\u003e\u003cli\u003eInterface sensitivity - errors start to popup that say that method is undefined or class does not exists, etc\u003c/li\u003e\u003cli\u003eBehaviour sensitivity - we didn\u0026#x27;t change production code but we changed mocks/tests setups/teardowns etc\u003c/li\u003e\u003cli\u003eData sensitivity - database or fixtures were modified\u003c/li\u003e\u003cli\u003eContext sensitivity - there is a change in your testing environment\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTests may be failing because the functionality they are verifying has been modified. This is not a case of behavior sensitivity because it is the whole reason for having regression tests.\u003c/p\u003e\u003cp\u003eAction steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003elook for patterns in how the tests fail. Ask yourself \u0026quot;What do all these broken tests have in common?\u0026quot;. This should help you understand how the tests are coupled.\u003c/li\u003e\u003cli\u003etry to minimize coupling between tests\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eAssertions roulette\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThere is failing spec and we can\u0026#x27;t easily determine which assertion had failed. It\u0026#x27;s a specially annoying when it happens on CI and cannot be reproduced quickly or the spec is weakly isolated and fails randomly.\u003c/p\u003e\u003cp\u003eAction steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003eavoid multiple asserts that tests different requirements\u003c/li\u003e\u003cli\u003ein case of many steps in our test, consider using some other way to set up the fixture for the latter parts of the test\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://testsmells.org/pages/testsmells.html\"\u003ehttps://testsmells.org/pages/testsmells.html\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code\"\u003ehttp://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"46isa","text":"These are one of the main reasons why our test suites become neglected. Our tests are also code and even if they are not part of a production application they should be treated as first class citizens in our project. Here is the list of popular test smells we can find in our app and solutions to fix them.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bjqvd","text":"Slow tests","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"31l2f","text":"This is definitely the most smelly element of our test suites. It's the reason developers stop depending on tests and do not run them on a regular basis. I've worked on a project that tests were taking over 30min and developers were going for a walk in the meantime... If that's the case in your example, you start seeing that waiting for tests to finish takes more than a couple of seconds. It's high time to change it.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f1898","text":"Action steps:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6ikuv","text":"First of all, order your test results based on spec speed. It should be easy to spot the ones that are exceeding the common threshold.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"447sn","text":"If you are working with large codebase you should try to group your specs by some boundary contexts and run only the related suites","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5u6hu","text":"If your app boots up too slowly before you run the spec, investigate the cause of it. Maybe there are deprecated or circular dependencies, network issues, etc","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dfalb","text":"There is high chance that your test framework has support for multiple CPU cores. By default, such options are usually disabled.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c2u2i","text":"Randomly failing specs","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1lbll","text":"Raise the hand if you haven't seen randomly failing CI or your local test suites so far. You are probably the luckiest developer walking on earth :) Very often specs fail randomly because there are some leftovers after running some other spec for the first time.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b2ikk","text":"Lets have a couple examples:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1g671","text":"a data storage is not cleaned properly","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fqpdl","text":"there is a dependency on the other test's setup","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f13ft","text":"an environment variable is modified","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7lm3q","text":"there is modification to file system","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ed3hu","text":"an external service/mock could be modified","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"50h7r","text":"a global object is modified","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cge4o","text":"test is too slow","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5iteq","text":"Even if it seems obvious for us to have data clean after each test, we tend to forget about it due to libraries we use to do most of the cleaning for us. Lack of proper understanding of those libraries may lead to violation of the isolation principle.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4pq1d","text":"Action steps:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1orpg","text":"If you spotted randomly failing spec act immediately, there is a chance that recent changes made the CI to fail","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9trv6","text":"To find the issue use test seed to run the tests in the same order, change format of your test runner to documentation instead of dots to figure out which specs where running before and might have negative impact","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6ipkg","text":"Learn your libraries which support your testing environment","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5spia","text":"Code is hard to test","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4djfq","text":"There are at least three cases that come to my mind but probably you can find more. First one is the communication with some external services that are responding slowly, are often unavailable or don't provide a testing environment at all that we could test against. The other example is when we have a very long process that should result in some output. And the last when we take over a legacy code that is written in poor manner without code coverage.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3g48m","text":"Where to start and how to handle those situations? As the first two mentioned are quite similar, the solution will be the same.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"euq4e","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"dk6ro","text":"\nBased on the example, let us approach the problem from different angles.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fjsed","text":"use VCR tooling to record response from the stock and payment services","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ebel","text":"build testing mock of stock and payment services","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d9g05","text":"No matter what solution you pick up you should remember to have contract tests for those services anyway. Thanks to that you will know when services have changed their API.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4g7hf","text":"Regarding legacy code we should be careful. If the current specs are yacky or there are no specs at all the most reasonable would be to start from covering the main functionalities with e2e or integration specs and then modifying the codebase and adjusting it to our needs.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ceaea","text":"Duplicated assertions","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":21,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"cp2ne","text":"When we are focused on testing a specific functionality, we tend to repeat some assertions despite the fact that the given part was already tested before. It happens due to copying and pasting previous tests. Take a look on this example:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c21fa","text":"describe('BookCreation', () =\u003e {\n  it('return book object', async () =\u003e {\n   const bookParams = { \"title\": \"Harry\" } \n   const { body: book } = await request(app)\n     .post('/books')\n     .send(bookParams)\n     .expect(200);\n\n   expect(book).toBeObject();\n });\n\n it('allow to create book with spaces', async () =\u003e {\n   const bookParams = { \"title\": \"Harry Potter\" } \n   const { body: book } = await request(app)\n     .post('books')\n     .send(bookParams)\n     .expect(200);\n \n   expect(book.title).toEql(\"Harry Potter\");\n });\n});","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":144,"length":5,"style":"ITALIC"},{"offset":394,"length":5,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"6i1s3","text":"Expecting the same status code from the book creation doesn't make sense as it's about the same result. If we decide to change a behaviour from synchronous to asynchronous and change the status code to 202 both spec will fail despite the fact they test different things.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dlaqe","text":"Action step:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"19itm","text":"Try to keep in mind that single test should have only one reason to fail","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1rc40","text":"Don't be afraid to remove duplicated assertions or even whole specs from your codebase","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ftcda","text":"Fragile tests","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"l0a8","text":"We have one or more tests that used to run and pass which either fail to compile and run or fail when they are run. Whenever we introduce a change to our codebase but is not related to any production code or tests then we have a case of Fragile Test. There are four of sensitivities that cause our system under test to fail:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7bdq5","text":"Interface sensitivity - errors start to popup that say that method is undefined or class does not exists, etc","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8vmip","text":"Behaviour sensitivity - we didn't change production code but we changed mocks/tests setups/teardowns etc","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fiuk","text":"Data sensitivity - database or fixtures were modified","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"45esa","text":"Context sensitivity - there is a change in your testing environment","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7irse","text":"Tests may be failing because the functionality they are verifying has been modified. This is not a case of behavior sensitivity because it is the whole reason for having regression tests.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"210sa","text":"Action steps:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9cga","text":"look for patterns in how the tests fail. Ask yourself \"What do all these broken tests have in common?\". This should help you understand how the tests are coupled.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1uuu5","text":"try to minimize coupling between tests","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b2hrm","text":"Assertions roulette","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"forer","text":"There is failing spec and we can't easily determine which assertion had failed. It's a specially annoying when it happens on CI and cannot be reproduced quickly or the spec is weakly isolated and fails randomly.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1mm12","text":"Action steps:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fi5v0","text":"avoid multiple asserts that tests different requirements","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2htbo","text":"in case of many steps in our test, consider using some other way to set up the fixture for the latter parts of the test","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"97scp","text":"Read more","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8lvuu","text":"https://testsmells.org/pages/testsmells.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":44,"key":1}],"data":{}},{"key":"brqls","text":"http://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":79,"key":2}],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/98123a10-6078-40f7-9c64-4e32dcefbc15.png?response-content-disposition=attachment%3Bfilename%3DZrzut%2Bekranu%2B2021-05-25%2Bo%2B18.17.01.png\u0026Expires=1621961242\u0026Signature=riEj3G-ksh63v7eKVPk39Amf07rMoWpTKUHiWjBxD02gNG7zdjulcvVVtoIAbwCBXI10zALCz6wSg5bsZCTtOqa1Bo-VvAFsKveRwS4OXNo5z-G0Tm~1j1bk2lYtaTfxH~GXveKEfE6kxXV2Ji58RlDZV~solezyhdvB9JvRAUnUNHhsJytXgca1BAkeLQDSTKvIctyv6sHr8gdVmMStvhv0ly1p9M~9E71MQYgzUJfsidJTfB2qMsA8B-MTfoCqEg57DLA3wsxS62VwrLA9P4cAF5DxirapUJaHssSbAX3fkz2Cf59tfI3L0VmS5tvXMYSMjUu7tH9vEFd5o~46rg__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3066"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://testsmells.org/pages/testsmells.html","text":"https://testsmells.org/pages/testsmells.html"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"http://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code","url":"http://xunitpatterns.com/Conditional%20Test%20Logic.html#Indented%20Test%20Code"}}}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":4,"attachments_count":1,"presentable":true,"external_id":null,"attachments":[{"id":3066,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/98123a10-6078-40f7-9c64-4e32dcefbc15.png","duration":null,"name":"Zrzut ekranu 2021-05-25 o 18.17.01.png","learner_visible":true,"confirmed":false,"user_id":666,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2021-05-25T18:17:22.613+02:00","sources":[]}]},{"id":1780,"position":8,"new_position":8,"published_attributes":{"type":"slide","answers":[],"title":"Test doubles","body":null,"serialized_body":"\u003cp\u003eWhenever we are talking about stubs or mocks we actually refer to a family of test doubles. It\u0026#x27;s good to know the difference between those two as they usually divide programmers into classists (Detroit style) and mockists (London style). Let\u0026#x27;s meet the family of test doubles. For this purpose let\u0026#x27;s imagine we want to create a test double for a human being :)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003edummies \u003c/strong\u003e- use when you want to pass as argument or return from function and you don\u0026#x27;t care about anything else yet its existence\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if double was a human being: \u003cem\u003eI am (truthy value)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003efakes\u003c/strong\u003e - similar to dummies but in this case we care about identity like class\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if fake was a human being: \u003cem\u003eI am human (ie. instance of a class human)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003estubs\u003c/strong\u003e - we extend fake with some functionality\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if stub was a human being: \u003cem\u003eI am human. My name is \u0026lt;put_your_name\u0026gt; (ie. instance of a class human with defined method name)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003espies\u003c/strong\u003e - it can act like a stub but it has a functionality that can allow to test some hidden state\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if a spy was a human being: \u003cem\u003eI am human. I am an adult. He is \u0026lt;put_your_age\u0026gt; (ie. instance of a class human with defined method isAdult? and private attribute age)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003emocks\u003c/strong\u003e - in contrast to stubs we define behaviour\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if mock was a human being: \u003cem\u003eI was told to say that I am human and my name is \u0026lt;put_your_name\u0026gt; (an instance of a class with overwritten method class and name)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWe are using test doubles to simplify our tests and get rid of dependencies but not the class under test! So instead of this code:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003econst AWS = require(\u0026#x27;aws-sdk\u0026#x27;) \nconst s3 = new AWS.S3()  \n\nasync function() { \n  return s3.listBuckets().promise() \n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt would be better to see something like this:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003easync function(s3client) {\n  return s3client.listBuckets().promise()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut is this really easier to test? It\u0026#x27;s just about creating our own stub with method listBuckets() which will return an object on which we can call a promise method which will return a Promise... Sounds overwhelming for such an easy case, right? Could mocks help us here somehow? Actually, not really as we also are obligated to define all expectations. The advantage of stub over mock is that we can pull it out to our stubs library and reuse it over again when mocks need to be defined each time. The cons of stubbing is that it requires a bit more coding than mock. It allows you to pull out the stub to some factories that you make reuse in other tests but it comes with the price as changing the interface may cause multiple errors.\u003c/p\u003e\u003cp\u003eThat\u0026#x27;s why it\u0026#x27;s good to use test doubles only when they are needed. Use the simplest and least compromising test double that does the trick. Mock or stub everything that is not unreliable like network calls, database accesses, external libraries and so on. If your test grows and gets complicated, it may be a code smell. Make sure that problem is not an architectural one. Otherwise use your best practices like SOLID to refactor the code.\u003c/p\u003e\u003cp\u003eSumming up stubs:\u003c/p\u003e\u003cul\u003e\u003cli\u003easserts state\u003c/li\u003e\u003cli\u003ecan be reused across multiple tests using factories\u003c/li\u003e\u003cli\u003edue to multiple usage change in stubs interface may case multiple errors in related specs\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eMocks on the other hand:\u003c/p\u003e\u003cul\u003e\u003cli\u003easserts behaviour\u003c/li\u003e\u003cli\u003eneeds to be defined with every test\u003c/li\u003e\u003cli\u003echanges to the codes can cause errors in related specs\u003c/li\u003e\u003cli\u003eare more coupled to real implementation\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eRead more:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c\"\u003ehttps://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html\"\u003ehttps://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html\"\u003ehttp://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"clcqu","text":"Whenever we are talking about stubs or mocks we actually refer to a family of test doubles. It's good to know the difference between those two as they usually divide programmers into classists (Detroit style) and mockists (London style). Let's meet the family of test doubles. For this purpose let's imagine we want to create a test double for a human being :)","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b12fa","text":"dummies - use when you want to pass as argument or return from function and you don't care about anything else yet its existence","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6mes9","text":"example if double was a human being: I am (truthy value)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":37,"length":19,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"3mdsd","text":"fakes - similar to dummies but in this case we care about identity like class","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"cieh","text":"example if fake was a human being: I am human (ie. instance of a class human)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":35,"length":42,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"fdnr8","text":"stubs - we extend fake with some functionality","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ath51","text":"example if stub was a human being: I am human. My name is \u003cput_your_name\u003e (ie. instance of a class human with defined method name)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":35,"length":95,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"cchqo","text":"spies - it can act like a stub but it has a functionality that can allow to test some hidden state","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"k6q9","text":"example if a spy was a human being: I am human. I am an adult. He is \u003cput_your_age\u003e (ie. instance of a class human with defined method isAdult? and private attribute age)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":36,"length":134,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"asbsb","text":"mocks - in contrast to stubs we define behaviour","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"333rt","text":"example if mock was a human being: I was told to say that I am human and my name is \u003cput_your_name\u003e (an instance of a class with overwritten method class and name)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":35,"length":128,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"8obqq","text":"We are using test doubles to simplify our tests and get rid of dependencies but not the class under test! So instead of this code:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"egujt","text":"const AWS = require('aws-sdk') \nconst s3 = new AWS.S3()  \n\nasync function() { \n  return s3.listBuckets().promise() \n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"44al7","text":"It would be better to see something like this:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"76s59","text":"async function(s3client) {\n  return s3client.listBuckets().promise()\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aklnm","text":"But is this really easier to test? It's just about creating our own stub with method listBuckets() which will return an object on which we can call a promise method which will return a Promise... Sounds overwhelming for such an easy case, right? Could mocks help us here somehow? Actually, not really as we also are obligated to define all expectations. The advantage of stub over mock is that we can pull it out to our stubs library and reuse it over again when mocks need to be defined each time. The cons of stubbing is that it requires a bit more coding than mock. It allows you to pull out the stub to some factories that you make reuse in other tests but it comes with the price as changing the interface may cause multiple errors.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7flo8","text":"That's why it's good to use test doubles only when they are needed. Use the simplest and least compromising test double that does the trick. Mock or stub everything that is not unreliable like network calls, database accesses, external libraries and so on. If your test grows and gets complicated, it may be a code smell. Make sure that problem is not an architectural one. Otherwise use your best practices like SOLID to refactor the code.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"qodt","text":"Summing up stubs:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fnne5","text":"asserts state","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5l8gb","text":"can be reused across multiple tests using factories","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ahgs2","text":"due to multiple usage change in stubs interface may case multiple errors in related specs","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5lp8i","text":"Mocks on the other hand:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5nbj1","text":"asserts behaviour","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2sd6c","text":"needs to be defined with every test","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1i0h","text":"changes to the codes can cause errors in related specs","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"58els","text":"are more coupled to real implementation","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"erbdi","text":"Read more:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4so9c","text":"https://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":91,"key":0}],"data":{}},{"key":"4fcf9","text":"https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":64,"key":1}],"data":{}},{"key":"852vt","text":"http://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":68,"key":2}],"data":{}}],"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c","url":"https://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html","text":"https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"http://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html","url":"http://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html"}}}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Test doubles","body":null,"serialized_body":"\u003cp\u003eWhenever we are talking about stubs or mocks we actually refer to a family of test doubles. It\u0026#x27;s good to know the difference between those two as they usually divide programmers into classists (Detroit style) and mockists (London style). Let\u0026#x27;s meet the family of test doubles. For this purpose let\u0026#x27;s imagine we want to create a test double for a human being :)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003edummies \u003c/strong\u003e- use when you want to pass as argument or return from function and you don\u0026#x27;t care about anything else yet its existence\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if double was a human being: \u003cem\u003eI am (truthy value)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003efakes\u003c/strong\u003e - similar to dummies but in this case we care about identity like class\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if fake was a human being: \u003cem\u003eI am human (ie. instance of a class human)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003estubs\u003c/strong\u003e - we extend fake with some functionality\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if stub was a human being: \u003cem\u003eI am human. My name is \u0026lt;put_your_name\u0026gt; (ie. instance of a class human with defined method name)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003espies\u003c/strong\u003e - it can act like a stub but it has a functionality that can allow to test some hidden state\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if a spy was a human being: \u003cem\u003eI am human. I am an adult. He is \u0026lt;put_your_age\u0026gt; (ie. instance of a class human with defined method isAdult? and private attribute age)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003emocks\u003c/strong\u003e - in contrast to stubs we define behaviour\u003c/p\u003e\u003cul\u003e\u003cli\u003eexample if mock was a human being: \u003cem\u003eI was told to say that I am human and my name is \u0026lt;put_your_name\u0026gt; (an instance of a class with overwritten method class and name)\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWe are using test doubles to simplify our tests and get rid of dependencies but not the class under test! So instead of this code:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003econst AWS = require(\u0026#x27;aws-sdk\u0026#x27;) \nconst s3 = new AWS.S3()  \n\nasync function() { \n  return s3.listBuckets().promise() \n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt would be better to see something like this:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003easync function(s3client) {\n  return s3client.listBuckets().promise()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut is this really easier to test? It\u0026#x27;s just about creating our own stub with method listBuckets() which will return an object on which we can call a promise method which will return a Promise... Sounds overwhelming for such an easy case, right? Could mocks help us here somehow? Actually, not really as we also are obligated to define all expectations. The advantage of stub over mock is that we can pull it out to our stubs library and reuse it over again when mocks need to be defined each time. The cons of stubbing is that it requires a bit more coding than mock. It allows you to pull out the stub to some factories that you make reuse in other tests but it comes with the price as changing the interface may cause multiple errors.\u003c/p\u003e\u003cp\u003eThat\u0026#x27;s why it\u0026#x27;s good to use test doubles only when they are needed. Use the simplest and least compromising test double that does the trick. Mock or stub everything that is not unreliable like network calls, database accesses, external libraries and so on. If your test grows and gets complicated, it may be a code smell. Make sure that problem is not an architectural one. Otherwise use your best practices like SOLID to refactor the code.\u003c/p\u003e\u003cp\u003eSumming up stubs:\u003c/p\u003e\u003cul\u003e\u003cli\u003easserts state\u003c/li\u003e\u003cli\u003ecan be reused across multiple tests using factories\u003c/li\u003e\u003cli\u003edue to multiple usage change in stubs interface may case multiple errors in related specs\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eMocks on the other hand:\u003c/p\u003e\u003cul\u003e\u003cli\u003easserts behaviour\u003c/li\u003e\u003cli\u003eneeds to be defined with every test\u003c/li\u003e\u003cli\u003echanges to the codes can cause errors in related specs\u003c/li\u003e\u003cli\u003eare more coupled to real implementation\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eRead more:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c\"\u003ehttps://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html\"\u003ehttps://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html\"\u003ehttp://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"clcqu","text":"Whenever we are talking about stubs or mocks we actually refer to a family of test doubles. It's good to know the difference between those two as they usually divide programmers into classists (Detroit style) and mockists (London style). Let's meet the family of test doubles. For this purpose let's imagine we want to create a test double for a human being :)","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b12fa","text":"dummies - use when you want to pass as argument or return from function and you don't care about anything else yet its existence","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6mes9","text":"example if double was a human being: I am (truthy value)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":37,"length":19,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"3mdsd","text":"fakes - similar to dummies but in this case we care about identity like class","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"cieh","text":"example if fake was a human being: I am human (ie. instance of a class human)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":35,"length":42,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"fdnr8","text":"stubs - we extend fake with some functionality","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ath51","text":"example if stub was a human being: I am human. My name is \u003cput_your_name\u003e (ie. instance of a class human with defined method name)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":35,"length":95,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"cchqo","text":"spies - it can act like a stub but it has a functionality that can allow to test some hidden state","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"k6q9","text":"example if a spy was a human being: I am human. I am an adult. He is \u003cput_your_age\u003e (ie. instance of a class human with defined method isAdult? and private attribute age)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":36,"length":134,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"asbsb","text":"mocks - in contrast to stubs we define behaviour","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"333rt","text":"example if mock was a human being: I was told to say that I am human and my name is \u003cput_your_name\u003e (an instance of a class with overwritten method class and name)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":35,"length":128,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"8obqq","text":"We are using test doubles to simplify our tests and get rid of dependencies but not the class under test! So instead of this code:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"egujt","text":"const AWS = require('aws-sdk') \nconst s3 = new AWS.S3()  \n\nasync function() { \n  return s3.listBuckets().promise() \n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"44al7","text":"It would be better to see something like this:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"76s59","text":"async function(s3client) {\n  return s3client.listBuckets().promise()\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aklnm","text":"But is this really easier to test? It's just about creating our own stub with method listBuckets() which will return an object on which we can call a promise method which will return a Promise... Sounds overwhelming for such an easy case, right? Could mocks help us here somehow? Actually, not really as we also are obligated to define all expectations. The advantage of stub over mock is that we can pull it out to our stubs library and reuse it over again when mocks need to be defined each time. The cons of stubbing is that it requires a bit more coding than mock. It allows you to pull out the stub to some factories that you make reuse in other tests but it comes with the price as changing the interface may cause multiple errors.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7flo8","text":"That's why it's good to use test doubles only when they are needed. Use the simplest and least compromising test double that does the trick. Mock or stub everything that is not unreliable like network calls, database accesses, external libraries and so on. If your test grows and gets complicated, it may be a code smell. Make sure that problem is not an architectural one. Otherwise use your best practices like SOLID to refactor the code.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"qodt","text":"Summing up stubs:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fnne5","text":"asserts state","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5l8gb","text":"can be reused across multiple tests using factories","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ahgs2","text":"due to multiple usage change in stubs interface may case multiple errors in related specs","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5lp8i","text":"Mocks on the other hand:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5nbj1","text":"asserts behaviour","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2sd6c","text":"needs to be defined with every test","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1i0h","text":"changes to the codes can cause errors in related specs","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"58els","text":"are more coupled to real implementation","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"erbdi","text":"Read more:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4so9c","text":"https://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":91,"key":0}],"data":{}},{"key":"4fcf9","text":"https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":64,"key":1}],"data":{}},{"key":"852vt","text":"http://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":68,"key":2}],"data":{}}],"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c","url":"https://engineering.talkdesk.com/double-trouble-why-we-decided-against-mocking-498c915bbe1c"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html","text":"https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"http://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html","url":"http://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html"}}}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":3,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":1789,"position":9,"new_position":9,"published_attributes":{"type":"slide","answers":[],"title":"Contract tests","body":null,"serialized_body":"\u003cp\u003eUsually you want to make sure the communication between your services and some 3rd party services is working as supposed. But what happens if the external system does not provide a sandbox environment you can test against or the environment is working slowly or even fails unexpectedly? There are a couple of solutions to this problem. None of them unfortunately is a silver bullet.\u003c/p\u003e\u003cp\u003eFirst of all we can create our own mock of that service that can be plugged into the services instead of using real connection. The purpose of doing that is not to confirm that the partner\u0026#x27;s service is working but that we are compliant with the given schema and that our recent changes didn\u0026#x27;t break a single test suite.\u003c/p\u003e\u003cp\u003eWe could also use VCR if you like to handling multiple files. It\u0026#x27;s definitely the easiest way to record the response body and headers and reuse it but it\u0026#x27;s not as customizable as the first one and it\u0026#x27;s harder to maintain.\u003c/p\u003e\u003cp\u003eBut what next? What will happen if the partner\u0026#x27;s schema changes? That\u0026#x27;s why we should have a second pair of our test suites that will check if the response schema has not changed surprisingly. What\u0026#x27;s important is that those specs should not break the regular pipeline and should not be run that frequently. Martin Fowler says that running such flow once per day should be enough but that\u0026#x27;s definitely something a team has to feel right.\u003c/p\u003e\u003cp\u003eFor typical partner relationships we may introduce Consumer Driven Contract. Which means only that both consumer and provider aka partner create API contracts you can test against and before introducing changes to the system you first need to update the contract. That way you can plan ahead features and modifications to your current branch and don\u0026#x27;t have to be worrying about the schema too much.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/c796e564-d019-4be8-8f34-5aae81ebc259.png?response-content-disposition=attachment%3Bfilename%3Dsummary.png\u0026amp;Expires=1625057765\u0026amp;Signature=PkPYH7y3brulVG~uK0zjOgNMII0KYu8DpaIu0so6XsVVQ8-VWrYMtGEkW9fo5561OUmAF39WKA~80-HhmQPIo8X0ECi2luVejXz6xNgbYoT5hKs9caRv60l9ekj6sjlCnIBd9kQdsk96TQnbW8MIhXtHNHWB58OwLW-5HWZ146ayRrB6PcEqQobYG~ndssP6lLGx-65sEFUWuwI5EehzfINh6LqJ9atCyULLFjHbopl3vr9eVdeZRfTsxcpnhqwPb3hK1CSqbdTyWr~7Hy9yc-QQT8mJecxd8vp4DyeeFvJbuuIO9f9T1lB1Hl~e~EI~1YSd3J8R1r6UrR7GyD31tg__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://martinfowler.com/articles/consumerDrivenContracts.html\"\u003ehttps://martinfowler.com/articles/consumerDrivenContracts.html\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://martinfowler.com/bliki/ContractTest.html\"\u003ehttps://martinfowler.com/bliki/ContractTest.html\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"ouod","text":"Usually you want to make sure the communication between your services and some 3rd party services is working as supposed. But what happens if the external system does not provide a sandbox environment you can test against or the environment is working slowly or even fails unexpectedly? There are a couple of solutions to this problem. None of them unfortunately is a silver bullet.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"323ps","text":"First of all we can create our own mock of that service that can be plugged into the services instead of using real connection. The purpose of doing that is not to confirm that the partner's service is working but that we are compliant with the given schema and that our recent changes didn't break a single test suite.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1npas","text":"We could also use VCR if you like to handling multiple files. It's definitely the easiest way to record the response body and headers and reuse it but it's not as customizable as the first one and it's harder to maintain.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c1snp","text":"But what next? What will happen if the partner's schema changes? That's why we should have a second pair of our test suites that will check if the response schema has not changed surprisingly. What's important is that those specs should not break the regular pipeline and should not be run that frequently. Martin Fowler says that running such flow once per day should be enough but that's definitely something a team has to feel right.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3s4rf","text":"For typical partner relationships we may introduce Consumer Driven Contract. Which means only that both consumer and provider aka partner create API contracts you can test against and before introducing changes to the system you first need to update the contract. That way you can plan ahead features and modifications to your current branch and don't have to be worrying about the schema too much.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7ocov","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"dgg2e","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1s8fh","text":"Read more","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"flaq8","text":"https://martinfowler.com/articles/consumerDrivenContracts.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":62,"key":1}],"data":{}},{"key":"d92gk","text":"https://martinfowler.com/bliki/ContractTest.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":48,"key":2}],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/c796e564-d019-4be8-8f34-5aae81ebc259.png?response-content-disposition=attachment%3Bfilename%3Dsummary.png\u0026Expires=1625057765\u0026Signature=PkPYH7y3brulVG~uK0zjOgNMII0KYu8DpaIu0so6XsVVQ8-VWrYMtGEkW9fo5561OUmAF39WKA~80-HhmQPIo8X0ECi2luVejXz6xNgbYoT5hKs9caRv60l9ekj6sjlCnIBd9kQdsk96TQnbW8MIhXtHNHWB58OwLW-5HWZ146ayRrB6PcEqQobYG~ndssP6lLGx-65sEFUWuwI5EehzfINh6LqJ9atCyULLFjHbopl3vr9eVdeZRfTsxcpnhqwPb3hK1CSqbdTyWr~7Hy9yc-QQT8mJecxd8vp4DyeeFvJbuuIO9f9T1lB1Hl~e~EI~1YSd3J8R1r6UrR7GyD31tg__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3077"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://martinfowler.com/articles/consumerDrivenContracts.html","text":"https://martinfowler.com/articles/consumerDrivenContracts.html"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://martinfowler.com/bliki/ContractTest.html","url":"https://martinfowler.com/bliki/ContractTest.html"}}}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Contract tests","body":null,"serialized_body":"\u003cp\u003eUsually you want to make sure the communication between your services and some 3rd party services is working as supposed. But what happens if the external system does not provide a sandbox environment you can test against or the environment is working slowly or even fails unexpectedly? There are a couple of solutions to this problem. None of them unfortunately is a silver bullet.\u003c/p\u003e\u003cp\u003eFirst of all we can create our own mock of that service that can be plugged into the services instead of using real connection. The purpose of doing that is not to confirm that the partner\u0026#x27;s service is working but that we are compliant with the given schema and that our recent changes didn\u0026#x27;t break a single test suite.\u003c/p\u003e\u003cp\u003eWe could also use VCR if you like to handling multiple files. It\u0026#x27;s definitely the easiest way to record the response body and headers and reuse it but it\u0026#x27;s not as customizable as the first one and it\u0026#x27;s harder to maintain.\u003c/p\u003e\u003cp\u003eBut what next? What will happen if the partner\u0026#x27;s schema changes? That\u0026#x27;s why we should have a second pair of our test suites that will check if the response schema has not changed surprisingly. What\u0026#x27;s important is that those specs should not break the regular pipeline and should not be run that frequently. Martin Fowler says that running such flow once per day should be enough but that\u0026#x27;s definitely something a team has to feel right.\u003c/p\u003e\u003cp\u003eFor typical partner relationships we may introduce Consumer Driven Contract. Which means only that both consumer and provider aka partner create API contracts you can test against and before introducing changes to the system you first need to update the contract. That way you can plan ahead features and modifications to your current branch and don\u0026#x27;t have to be worrying about the schema too much.\u003c/p\u003e\u003cimg src=\"https://cdn.dub.bridgeapp.com/512/1/uploads/c796e564-d019-4be8-8f34-5aae81ebc259.png?response-content-disposition=attachment%3Bfilename%3Dsummary.png\u0026amp;Expires=1625057765\u0026amp;Signature=PkPYH7y3brulVG~uK0zjOgNMII0KYu8DpaIu0so6XsVVQ8-VWrYMtGEkW9fo5561OUmAF39WKA~80-HhmQPIo8X0ECi2luVejXz6xNgbYoT5hKs9caRv60l9ekj6sjlCnIBd9kQdsk96TQnbW8MIhXtHNHWB58OwLW-5HWZ146ayRrB6PcEqQobYG~ndssP6lLGx-65sEFUWuwI5EehzfINh6LqJ9atCyULLFjHbopl3vr9eVdeZRfTsxcpnhqwPb3hK1CSqbdTyWr~7Hy9yc-QQT8mJecxd8vp4DyeeFvJbuuIO9f9T1lB1Hl~e~EI~1YSd3J8R1r6UrR7GyD31tg__\u0026amp;Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://martinfowler.com/articles/consumerDrivenContracts.html\"\u003ehttps://martinfowler.com/articles/consumerDrivenContracts.html\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://martinfowler.com/bliki/ContractTest.html\"\u003ehttps://martinfowler.com/bliki/ContractTest.html\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"ouod","text":"Usually you want to make sure the communication between your services and some 3rd party services is working as supposed. But what happens if the external system does not provide a sandbox environment you can test against or the environment is working slowly or even fails unexpectedly? There are a couple of solutions to this problem. None of them unfortunately is a silver bullet.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"323ps","text":"First of all we can create our own mock of that service that can be plugged into the services instead of using real connection. The purpose of doing that is not to confirm that the partner's service is working but that we are compliant with the given schema and that our recent changes didn't break a single test suite.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1npas","text":"We could also use VCR if you like to handling multiple files. It's definitely the easiest way to record the response body and headers and reuse it but it's not as customizable as the first one and it's harder to maintain.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c1snp","text":"But what next? What will happen if the partner's schema changes? That's why we should have a second pair of our test suites that will check if the response schema has not changed surprisingly. What's important is that those specs should not break the regular pipeline and should not be run that frequently. Martin Fowler says that running such flow once per day should be enough but that's definitely something a team has to feel right.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3s4rf","text":"For typical partner relationships we may introduce Consumer Driven Contract. Which means only that both consumer and provider aka partner create API contracts you can test against and before introducing changes to the system you first need to update the contract. That way you can plan ahead features and modifications to your current branch and don't have to be worrying about the schema too much.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7ocov","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"dgg2e","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1s8fh","text":"Read more","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"flaq8","text":"https://martinfowler.com/articles/consumerDrivenContracts.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":62,"key":1}],"data":{}},{"key":"d92gk","text":"https://martinfowler.com/bliki/ContractTest.html","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":48,"key":2}],"data":{}}],"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://cdn.dub.bridgeapp.com/512/1/uploads/c796e564-d019-4be8-8f34-5aae81ebc259.png?response-content-disposition=attachment%3Bfilename%3Dsummary.png\u0026Expires=1625057765\u0026Signature=PkPYH7y3brulVG~uK0zjOgNMII0KYu8DpaIu0so6XsVVQ8-VWrYMtGEkW9fo5561OUmAF39WKA~80-HhmQPIo8X0ECi2luVejXz6xNgbYoT5hKs9caRv60l9ekj6sjlCnIBd9kQdsk96TQnbW8MIhXtHNHWB58OwLW-5HWZ146ayRrB6PcEqQobYG~ndssP6lLGx-65sEFUWuwI5EehzfINh6LqJ9atCyULLFjHbopl3vr9eVdeZRfTsxcpnhqwPb3hK1CSqbdTyWr~7Hy9yc-QQT8mJecxd8vp4DyeeFvJbuuIO9f9T1lB1Hl~e~EI~1YSd3J8R1r6UrR7GyD31tg__\u0026Key-Pair-Id=APKAJXAC3ZZLINBJN2EQ","attachmentId":"3077"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://martinfowler.com/articles/consumerDrivenContracts.html","text":"https://martinfowler.com/articles/consumerDrivenContracts.html"}},"2":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://martinfowler.com/bliki/ContractTest.html","url":"https://martinfowler.com/bliki/ContractTest.html"}}}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":2,"attachments_count":1,"presentable":true,"external_id":null,"attachments":[{"id":3077,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/c796e564-d019-4be8-8f34-5aae81ebc259.png","duration":null,"name":"summary.png","learner_visible":true,"confirmed":false,"user_id":666,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2021-06-30T14:26:05.653+02:00","sources":[]}]},{"id":1835,"position":10,"new_position":10,"published_attributes":{"type":"slide","answers":[],"title":"Test Driven Development vs Test First Development","body":null,"serialized_body":"\u003cp\u003eTest-first development is an old concept that was rediscovered and documented by Kent Beck. Test-first development (TFD) is an approach to development in which developers do not write a single line of code until they have created the test cases needed to prove that unit of work solves the business problem and is technically correct at a unit-test level. Test driven development is test first development combined with design and code refactoring. Both test-first and test-driven development are useful for improving quality, morale and trust and even though both are related they are not the same.\u003c/p\u003e\u003cp\u003eTest-first development has a few basic steps.\u003c/p\u003e\u003col\u003e\u003cli\u003eThe developer accepts a unit of work and writes a set of tests that will prove that the code actually functions correctly at a unit level.\u003c/li\u003e\u003cli\u003eThey then run the tests. The tests should fail because the code to solve the business problem embedded in the unit of work has not been written. If the tests pass, rewrite them so that they fail (assuming someone else has not fixed the problem).\u003c/li\u003e\u003cli\u003eWrite the code needed to solve the problem. Remember that simplicity is king and only write enough code to solve the problem.\u003c/li\u003e\u003cli\u003eRun the test suite again. If the tests pass you are done; however, if ANY of the tests doesnt pass return to step three and correct the code. Repeat steps three and four until all tests pass.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eTest-driven development, TDD (also known as test-driven design) adds 5th \u0026quot;step\u0026quot; to the process after the unit tests.\u003c/p\u003e\u003cul\u003e\u003cli\u003eRefactor the code and design to make both as simple as possible and remove any possible duplication.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAs the code is written and refactored the design evolves based on the feedback gathered one story at a time. TDD integrates the practice of coding and unit testing with evolutionary design, breaking down the separation of roles that reduce collaboration and increase the cost of quality. A conceptual advance; however, there are organizations such as ATMs, automotive products and medical devices where the concept of evolutionary design is a bridge too far, leaving test first as their only option.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/\"\u003ehttps://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=UWtEVKVPBQ0\"\u003ehttps://www.youtube.com/watch?v=UWtEVKVPBQ0\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"1hd48","text":"Test-first development is an old concept that was rediscovered and documented by Kent Beck. Test-first development (TFD) is an approach to development in which developers do not write a single line of code until they have created the test cases needed to prove that unit of work solves the business problem and is technically correct at a unit-test level. Test driven development is test first development combined with design and code refactoring. Both test-first and test-driven development are useful for improving quality, morale and trust and even though both are related they are not the same.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f3oev","text":"Test-first development has a few basic steps.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3pen1","text":"The developer accepts a unit of work and writes a set of tests that will prove that the code actually functions correctly at a unit level.","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1undj","text":"They then run the tests. The tests should fail because the code to solve the business problem embedded in the unit of work has not been written. If the tests pass, rewrite them so that they fail (assuming someone else has not fixed the problem).","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"208i4","text":"Write the code needed to solve the problem. Remember that simplicity is king and only write enough code to solve the problem.","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9fokf","text":"Run the test suite again. If the tests pass you are done; however, if ANY of the tests doesnt pass return to step three and correct the code. Repeat steps three and four until all tests pass.","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fk55j","text":"Test-driven development, TDD (also known as test-driven design) adds 5th \"step\" to the process after the unit tests.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"84i1h","text":"Refactor the code and design to make both as simple as possible and remove any possible duplication.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3o0c2","text":"As the code is written and refactored the design evolves based on the feedback gathered one story at a time. TDD integrates the practice of coding and unit testing with evolutionary design, breaking down the separation of roles that reduce collaboration and increase the cost of quality. A conceptual advance; however, there are organizations such as ATMs, automotive products and medical devices where the concept of evolutionary design is a bridge too far, leaving test first as their only option.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5ist9","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ehsfd","text":"https://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":102,"key":0}],"data":{}},{"key":"dspqc","text":"https://www.youtube.com/watch?v=UWtEVKVPBQ0","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":43,"key":1}],"data":{}}],"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/","text":"https://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://www.youtube.com/watch?v=UWtEVKVPBQ0","text":"https://www.youtube.com/watch?v=UWtEVKVPBQ0"}}}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Test Driven Development vs Test First Development","body":null,"serialized_body":"\u003cp\u003eTest-first development is an old concept that was rediscovered and documented by Kent Beck. Test-first development (TFD) is an approach to development in which developers do not write a single line of code until they have created the test cases needed to prove that unit of work solves the business problem and is technically correct at a unit-test level. Test driven development is test first development combined with design and code refactoring. Both test-first and test-driven development are useful for improving quality, morale and trust and even though both are related they are not the same.\u003c/p\u003e\u003cp\u003eTest-first development has a few basic steps.\u003c/p\u003e\u003col\u003e\u003cli\u003eThe developer accepts a unit of work and writes a set of tests that will prove that the code actually functions correctly at a unit level.\u003c/li\u003e\u003cli\u003eThey then run the tests. The tests should fail because the code to solve the business problem embedded in the unit of work has not been written. If the tests pass, rewrite them so that they fail (assuming someone else has not fixed the problem).\u003c/li\u003e\u003cli\u003eWrite the code needed to solve the problem. Remember that simplicity is king and only write enough code to solve the problem.\u003c/li\u003e\u003cli\u003eRun the test suite again. If the tests pass you are done; however, if ANY of the tests doesnt pass return to step three and correct the code. Repeat steps three and four until all tests pass.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eTest-driven development, TDD (also known as test-driven design) adds 5th \u0026quot;step\u0026quot; to the process after the unit tests.\u003c/p\u003e\u003cul\u003e\u003cli\u003eRefactor the code and design to make both as simple as possible and remove any possible duplication.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAs the code is written and refactored the design evolves based on the feedback gathered one story at a time. TDD integrates the practice of coding and unit testing with evolutionary design, breaking down the separation of roles that reduce collaboration and increase the cost of quality. A conceptual advance; however, there are organizations such as ATMs, automotive products and medical devices where the concept of evolutionary design is a bridge too far, leaving test first as their only option.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/\"\u003ehttps://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=UWtEVKVPBQ0\"\u003ehttps://www.youtube.com/watch?v=UWtEVKVPBQ0\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"1hd48","text":"Test-first development is an old concept that was rediscovered and documented by Kent Beck. Test-first development (TFD) is an approach to development in which developers do not write a single line of code until they have created the test cases needed to prove that unit of work solves the business problem and is technically correct at a unit-test level. Test driven development is test first development combined with design and code refactoring. Both test-first and test-driven development are useful for improving quality, morale and trust and even though both are related they are not the same.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f3oev","text":"Test-first development has a few basic steps.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3pen1","text":"The developer accepts a unit of work and writes a set of tests that will prove that the code actually functions correctly at a unit level.","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1undj","text":"They then run the tests. The tests should fail because the code to solve the business problem embedded in the unit of work has not been written. If the tests pass, rewrite them so that they fail (assuming someone else has not fixed the problem).","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"208i4","text":"Write the code needed to solve the problem. Remember that simplicity is king and only write enough code to solve the problem.","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9fokf","text":"Run the test suite again. If the tests pass you are done; however, if ANY of the tests doesnt pass return to step three and correct the code. Repeat steps three and four until all tests pass.","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fk55j","text":"Test-driven development, TDD (also known as test-driven design) adds 5th \"step\" to the process after the unit tests.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"84i1h","text":"Refactor the code and design to make both as simple as possible and remove any possible duplication.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3o0c2","text":"As the code is written and refactored the design evolves based on the feedback gathered one story at a time. TDD integrates the practice of coding and unit testing with evolutionary design, breaking down the separation of roles that reduce collaboration and increase the cost of quality. A conceptual advance; however, there are organizations such as ATMs, automotive products and medical devices where the concept of evolutionary design is a bridge too far, leaving test first as their only option.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5ist9","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ehsfd","text":"https://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":102,"key":0}],"data":{}},{"key":"dspqc","text":"https://www.youtube.com/watch?v=UWtEVKVPBQ0","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":43,"key":1}],"data":{}}],"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/","text":"https://tcagley.wordpress.com/2016/07/26/test-first-and-test-driven-development-is-there-a-difference/"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://www.youtube.com/watch?v=UWtEVKVPBQ0","text":"https://www.youtube.com/watch?v=UWtEVKVPBQ0"}}}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":2,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":1836,"position":11,"new_position":11,"published_attributes":{"type":"slide","answers":[],"title":"Behaviour Driven Development","body":null,"serialized_body":"\u003cp\u003eThe BDD is a testing approach derived from the TDD but instead of focusing on detailed requirements it\u0026#x27;s used for defining systems behaviour. It\u0026#x27;s also a methodology that allows setting up criteria understood by all stakeholders that may not have a technical experience. Thanks to that both developers and business learn and work with ubiquitous language that becomes a part of software business domain. The tests are defined by simply using a Given-When-Then approach.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eGiven is a logged user\nAnd 10 apples on the store\nWhen user enters the market\nAnd clicks to buy an apple\nThen user sees shopping cart icon indicating 1 apple in the cart\nAnd 9 apples left on the store\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see the BBD will be useful whenever you have to work with an UI. The way we approach testing is very similar to the TDD:\u003c/p\u003e\u003cul\u003e\u003cli\u003eWrite a test\u003c/li\u003e\u003cli\u003eRun the test and watch it fails\u003c/li\u003e\u003cli\u003eImplement a solution\u003c/li\u003e\u003cli\u003eRun the test and watch it passes\u003c/li\u003e\u003cli\u003eRefactor\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eLook for Gherkin if you are interested in implementing tests with Given-When-Then syntax.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=9P5WG8CkPrQ\"\u003ehttps://www.youtube.com/watch?v=9P5WG8CkPrQ\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"t7s5","text":"The BDD is a testing approach derived from the TDD but instead of focusing on detailed requirements it's used for defining systems behaviour. It's also a methodology that allows setting up criteria understood by all stakeholders that may not have a technical experience. Thanks to that both developers and business learn and work with ubiquitous language that becomes a part of software business domain. The tests are defined by simply using a Given-When-Then approach.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6ufb5","text":"Given is a logged user\nAnd 10 apples on the store\nWhen user enters the market\nAnd clicks to buy an apple\nThen user sees shopping cart icon indicating 1 apple in the cart\nAnd 9 apples left on the store","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5tjeh","text":"As you can see the BBD will be useful whenever you have to work with an UI. The way we approach testing is very similar to the TDD:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4ndod","text":"Write a test","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c054u","text":"Run the test and watch it fails","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fa99j","text":"Implement a solution","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"93l9v","text":"Run the test and watch it passes","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fvp8","text":"Refactor","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fs8lc","text":"Look for Gherkin if you are interested in implementing tests with Given-When-Then syntax.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"56nau","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7d22b","text":"https://www.youtube.com/watch?v=9P5WG8CkPrQ","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":43,"key":0}],"data":{}}],"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://www.youtube.com/watch?v=9P5WG8CkPrQ","url":"https://www.youtube.com/watch?v=9P5WG8CkPrQ"}}}},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Behaviour Driven Development","body":null,"serialized_body":"\u003cp\u003eThe BDD is a testing approach derived from the TDD but instead of focusing on detailed requirements it\u0026#x27;s used for defining systems behaviour. It\u0026#x27;s also a methodology that allows setting up criteria understood by all stakeholders that may not have a technical experience. Thanks to that both developers and business learn and work with ubiquitous language that becomes a part of software business domain. The tests are defined by simply using a Given-When-Then approach.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eGiven is a logged user\nAnd 10 apples on the store\nWhen user enters the market\nAnd clicks to buy an apple\nThen user sees shopping cart icon indicating 1 apple in the cart\nAnd 9 apples left on the store\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see the BBD will be useful whenever you have to work with an UI. The way we approach testing is very similar to the TDD:\u003c/p\u003e\u003cul\u003e\u003cli\u003eWrite a test\u003c/li\u003e\u003cli\u003eRun the test and watch it fails\u003c/li\u003e\u003cli\u003eImplement a solution\u003c/li\u003e\u003cli\u003eRun the test and watch it passes\u003c/li\u003e\u003cli\u003eRefactor\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eLook for Gherkin if you are interested in implementing tests with Given-When-Then syntax.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRead more\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=9P5WG8CkPrQ\"\u003ehttps://www.youtube.com/watch?v=9P5WG8CkPrQ\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e","structured_body":{"blocks":[{"key":"t7s5","text":"The BDD is a testing approach derived from the TDD but instead of focusing on detailed requirements it's used for defining systems behaviour. It's also a methodology that allows setting up criteria understood by all stakeholders that may not have a technical experience. Thanks to that both developers and business learn and work with ubiquitous language that becomes a part of software business domain. The tests are defined by simply using a Given-When-Then approach.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6ufb5","text":"Given is a logged user\nAnd 10 apples on the store\nWhen user enters the market\nAnd clicks to buy an apple\nThen user sees shopping cart icon indicating 1 apple in the cart\nAnd 9 apples left on the store","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5tjeh","text":"As you can see the BBD will be useful whenever you have to work with an UI. The way we approach testing is very similar to the TDD:","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4ndod","text":"Write a test","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c054u","text":"Run the test and watch it fails","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fa99j","text":"Implement a solution","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"93l9v","text":"Run the test and watch it passes","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fvp8","text":"Refactor","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fs8lc","text":"Look for Gherkin if you are interested in implementing tests with Given-When-Then syntax.","type":"paragraph","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"56nau","text":"Read more","type":"paragraph","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7d22b","text":"https://www.youtube.com/watch?v=9P5WG8CkPrQ","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":43,"key":0}],"data":{}}],"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://www.youtube.com/watch?v=9P5WG8CkPrQ","url":"https://www.youtube.com/watch?v=9P5WG8CkPrQ"}}}},"feedback":null,"cover_slide_data":{}},"published_at":"2021-07-27T15:05:21.146+02:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]}],"attachments":[]}