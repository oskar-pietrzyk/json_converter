{"id":83,"title":"Test Driven Development on Android Platform","estimated_time":27,"user_id":null,"passing_threshold":80,"published_at":"2022-05-11T14:44:36.353+02:00","has_unpublished_changes":false,"has_certificate":true,"external_id":null,"draft_external_id":null,"external_status":"inapplicable","course_type":"bridge","enrollments_count":20,"domain_id":53,"sub_account_id":1,"open_book":false,"description":"","third_party_course_id":null,"external_course_id":null,"quizzes_count":0,"external_status_message":null,"manual_estimated_time":false,"show_correct_response":true,"max_quiz_attempts":null,"continuing_education_credits":null,"archived_at":null,"config":{},"unpublished_at":null,"external_learning_standard":null,"available_offline":false,"external_version":null,"ordered_slides":[{"id":779,"position":1,"new_position":1,"published_attributes":{"type":"slide","title":"Introduction","body":null,"serialized_body":"\u003cp\u003eTest Driven Development is a very effective programming strategy which aims to give you the best possible unit test coverage. It can also speed up your development process since ideally won\u0026#x27;t have to launch your application to check if the business logic is correct - you only need to run the tests. In this codelab, you will learn how to create Android applications using TDD.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eWhat is Test Driven Development?\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eTDD approach consists of the following steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eCreate new test\u003c/strong\u003e - Instead of starting by developing a feature, we\u0026#x27;re writing tests first. The tests should fail until you program the logic.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eWrite code to make the tests pass\u003c/strong\u003e - write the necessary code to make your test methods pass, do not write any additional code.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eRefactor your code\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eRepeat these steps until your feature is fully implemented.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eTDD on Android platform\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eThere is a problem with TDD on Android Platform - while some tests can be run on the JVM on your machine, some will have to be run on a virtual or physical device, making it more time consuming.\u003c/p\u003e\u003cp\u003eExpecting that you are going to use Clean Architecture in your application, your code will be split into layers. If so, the proper way of implementing TDD on android is as following:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eCreate new UI test, which covers all the layers\u003c/strong\u003e - you can use your preferred technology to do it. In this codelab we\u0026#x27;re going to use Espresso.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eFollow the steps mentioned earlier\u003c/strong\u003e to write code for every layer of your application\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCome back to your UI test\u003c/strong\u003e and add code required to make it pass\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn this codelab we\u0026#x27;re going to follow TDD to create a simple application, which will find a city in UK based on its latitude and longitude.\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"8mojb","text":"Test Driven Development is a very effective programming strategy which aims to give you the best possible unit test coverage. It can also speed up your development process since ideally won't have to launch your application to check if the business logic is correct - you only need to run the tests. In this codelab, you will learn how to create Android applications using TDD.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"59ose","text":"What is Test Driven Development?","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":32,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"79le5","text":"TDD approach consists of the following steps:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cvkf3","text":"Create new test - Instead of starting by developing a feature, we're writing tests first. The tests should fail until you program the logic.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"e98i2","text":"Write code to make the tests pass - write the necessary code to make your test methods pass, do not write any additional code.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":33,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fu9g5","text":"Refactor your code","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":18,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"61f7o","text":"Repeat these steps until your feature is fully implemented.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8lt0c","text":"TDD on Android platform","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"d2tlq","text":"There is a problem with TDD on Android Platform - while some tests can be run on the JVM on your machine, some will have to be run on a virtual or physical device, making it more time consuming.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9hfd3","text":"Expecting that you are going to use Clean Architecture in your application, your code will be split into layers. If so, the proper way of implementing TDD on android is as following:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5vuk6","text":"Create new UI test, which covers all the layers - you can use your preferred technology to do it. In this codelab we're going to use Espresso.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":47,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fleui","text":"Follow the steps mentioned earlier to write code for every layer of your application","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":34,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6rq11","text":"Come back to your UI test and add code required to make it pass","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":25,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3qhip","text":"In this codelab we're going to follow TDD to create a simple application, which will find a city in UK based on its latitude and longitude.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"answers":[],"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","title":"Introduction","body":null,"serialized_body":"\u003cp\u003eTest Driven Development is a very effective programming strategy which aims to give you the best possible unit test coverage. It can also speed up your development process since ideally won\u0026#x27;t have to launch your application to check if the business logic is correct - you only need to run the tests. In this codelab, you will learn how to create Android applications using TDD.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eWhat is Test Driven Development?\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eTDD approach consists of the following steps:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eCreate new test\u003c/strong\u003e - Instead of starting by developing a feature, we\u0026#x27;re writing tests first. The tests should fail until you program the logic.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eWrite code to make the tests pass\u003c/strong\u003e - write the necessary code to make your test methods pass, do not write any additional code.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eRefactor your code\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eRepeat these steps until your feature is fully implemented.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eTDD on Android platform\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eThere is a problem with TDD on Android Platform - while some tests can be run on the JVM on your machine, some will have to be run on a virtual or physical device, making it more time consuming.\u003c/p\u003e\u003cp\u003eExpecting that you are going to use Clean Architecture in your application, your code will be split into layers. If so, the proper way of implementing TDD on android is as following:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eCreate new UI test, which covers all the layers\u003c/strong\u003e - you can use your preferred technology to do it. In this codelab we\u0026#x27;re going to use Espresso.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eFollow the steps mentioned earlier\u003c/strong\u003e to write code for every layer of your application\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCome back to your UI test\u003c/strong\u003e and add code required to make it pass\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn this codelab we\u0026#x27;re going to follow TDD to create a simple application, which will find a city in UK based on its latitude and longitude.\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"8mojb","text":"Test Driven Development is a very effective programming strategy which aims to give you the best possible unit test coverage. It can also speed up your development process since ideally won't have to launch your application to check if the business logic is correct - you only need to run the tests. In this codelab, you will learn how to create Android applications using TDD.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"59ose","text":"What is Test Driven Development?","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":32,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"79le5","text":"TDD approach consists of the following steps:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cvkf3","text":"Create new test - Instead of starting by developing a feature, we're writing tests first. The tests should fail until you program the logic.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"e98i2","text":"Write code to make the tests pass - write the necessary code to make your test methods pass, do not write any additional code.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":33,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fu9g5","text":"Refactor your code","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":18,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"61f7o","text":"Repeat these steps until your feature is fully implemented.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8lt0c","text":"TDD on Android platform","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"d2tlq","text":"There is a problem with TDD on Android Platform - while some tests can be run on the JVM on your machine, some will have to be run on a virtual or physical device, making it more time consuming.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9hfd3","text":"Expecting that you are going to use Clean Architecture in your application, your code will be split into layers. If so, the proper way of implementing TDD on android is as following:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5vuk6","text":"Create new UI test, which covers all the layers - you can use your preferred technology to do it. In this codelab we're going to use Espresso.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":47,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fleui","text":"Follow the steps mentioned earlier to write code for every layer of your application","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":34,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6rq11","text":"Come back to your UI test and add code required to make it pass","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":25,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3qhip","text":"In this codelab we're going to follow TDD to create a simple application, which will find a city in UK based on its latitude and longitude.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"answers":[],"feedback":null,"cover_slide_data":{}},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":2,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":780,"position":2,"new_position":2,"published_attributes":{"type":"slide","answers":[],"title":"Step 1: Getting started","body":null,"serialized_body":"\u003ch2\u003e\u003cstrong\u003eCreate new project\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eLet\u0026#x27;s start with creating a new project. Open your Android Studio and select: \u003cstrong\u003eFile -\u0026gt; New -\u0026gt; New Project.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eInsert your own domain and project names. Make sure to include Kotlin support - \u003cstrong\u003eall code snippets in this codelab are written in Kotlin\u003c/strong\u003e. Target your application to Phones and Tablets, and select \u003cstrong\u003eAPI level 23\u003c/strong\u003e as minimum SDK. Then select \u003cstrong\u003eEmpty Activity\u003c/strong\u003e and create your project with activity name - MainActivity and layout name - activity_main. Check both \u003cstrong\u003eBackwards Compatibility\u003c/strong\u003e and \u003cstrong\u003eGenerate Layout File\u003c/strong\u003e options and press \u003cstrong\u003eFinish\u003c/strong\u003e.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eDraw your layout\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eBefore we start using TDD, you need to draw your layout. As you probably know, we are not testing XML files, so at this point we\u0026#x27;re not using \u003cstrong\u003eTest Driven Development\u003c/strong\u003e yet.\u003c/p\u003e\u003cp\u003eThe layout should include 4 views - 2 \u003cstrong\u003eEditTexts\u003c/strong\u003e to allow user to type the text for coordinates, a \u003cstrong\u003eButton\u003c/strong\u003e to trigger action and a \u003cstrong\u003eTextView\u003c/strong\u003e to display the result. You can lay them out however you like, but the simplest way to to it is using a LinearLayout.\u003c/p\u003e\u003cp\u003eOpen your \u003cstrong\u003eactivity_main.xml\u003c/strong\u003e file and modify it to use Linear Layout:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\n\u003c/span\u003e\u0026lt;LinearLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\n    xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\n    android:layout_width=\u0026quot;match_parent\u0026quot;\n    android:layout_height=\u0026quot;match_parent\u0026quot;\n    android:orientation=\u0026quot;vertical\u0026quot;\n    tools:context=\u0026quot;.MainActivity\u0026quot;\u0026gt;\n\n    \u0026lt;EditText\n        android:id=\u0026quot;@+id/latInput\u0026quot;\n        android:layout_width=\u0026quot;match_parent\u0026quot;\n        android:layout_height=\u0026quot;wrap_content\u0026quot;\n        android:hint=\u0026quot;@string/lat_hint\u0026quot;\n        android:inputType=\u0026quot;text\u0026quot; /\u0026gt;\n\n    \u0026lt;EditText\n        android:id=\u0026quot;@+id/lonInput\u0026quot;\n        android:layout_width=\u0026quot;match_parent\u0026quot;\n        android:layout_height=\u0026quot;wrap_content\u0026quot;\n        android:hint=\u0026quot;@string/lon_hint\u0026quot;\n        android:inputType=\u0026quot;text\u0026quot; /\u0026gt;\n\n    \u0026lt;Button\n        android:id=\u0026quot;@+id/findCityButton\u0026quot;\n        android:layout_width=\u0026quot;match_parent\u0026quot;\n        android:layout_height=\u0026quot;wrap_content\u0026quot;\n        android:layout_marginHorizontal=\u0026quot;16dp\u0026quot;\n        android:text=\u0026quot;@string/find_city\u0026quot; /\u0026gt;\n\n    \u0026lt;TextView\n        android:id=\u0026quot;@+id/cityResult\u0026quot;\n        android:layout_width=\u0026quot;wrap_content\u0026quot;\n        android:layout_height=\u0026quot;wrap_content\u0026quot; /\u0026gt;\n\n\u0026lt;/LinearLayout\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAdd any strings resources to your \u003cstrong\u003estrings.xml\u003c/strong\u003e file:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e\u0026lt;resources\u0026gt;\n   \u003c/span\u003e\u0026lt;string name=\u0026quot;app_name\u0026quot;\u0026gt;City Finder\u0026lt;/string\u0026gt;\n   \u0026lt;string name=\u0026quot;lat_hint\u0026quot;\u0026gt;Type latitude\u0026lt;/string\u0026gt;\n   \u0026lt;string name=\u0026quot;lon_hint\u0026quot;\u0026gt;Type longitude\u0026lt;/string\u0026gt;\n   \u0026lt;string name=\u0026quot;find_city\u0026quot;\u0026gt;Find\u0026lt;/string\u0026gt;\u003cspan\u003e\n\u0026lt;/resources\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe result should be similar to this:\u003c/p\u003e\u003cimg src=\"https://filestore.prod-dub.bridgeapp.com/512/1/uploads/dc1b6d29-2c0d-4e71-bb7e-08d297ca9b8c.png?response-content-disposition=attachment%3Bfilename%3DScreenshot%2B2022-03-29%2Bat%2B15.21.59.png\u0026amp;Expires=1648561951\u0026amp;Signature=HiMXnU8l8QtRKXDT~mpyqMK42fdApYnjcmONdIryLpJyNGyCYZSwb~iyAbA1upB7tYAQF-cMEr3YuTfiodEA7kNAOm2KV39W76wnwT8im4ZdnBlzY51XvzkoUgbrB2RD7uIwRfwTOu7yVRpJqnVsPL7ZZw4itajsMJi0DATB8C2TzGlypQyhJjLA4TJbHJqzR0dmfnBV9Tk2H3DKMgrNCHAI0sR1OidwWyj0aeOV89pdNoakJ91nGYp5T-Eya0gmn-iAtbXPwqfg7a5LRK3avHdyjUz0c6hSuFgqUvoUxa9AJwaiSmGCKVoMZCxJRuzkxjWLH00IGaf7lPKrPH-ePg__\u0026amp;Key-Pair-Id=KPI636NEHUJCD\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003c/p\u003e","structured_body":{"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://filestore.prod-dub.bridgeapp.com/512/1/uploads/dc1b6d29-2c0d-4e71-bb7e-08d297ca9b8c.png?response-content-disposition=attachment%3Bfilename%3DScreenshot%2B2022-03-29%2Bat%2B15.21.59.png\u0026Expires=1648561951\u0026Signature=HiMXnU8l8QtRKXDT~mpyqMK42fdApYnjcmONdIryLpJyNGyCYZSwb~iyAbA1upB7tYAQF-cMEr3YuTfiodEA7kNAOm2KV39W76wnwT8im4ZdnBlzY51XvzkoUgbrB2RD7uIwRfwTOu7yVRpJqnVsPL7ZZw4itajsMJi0DATB8C2TzGlypQyhJjLA4TJbHJqzR0dmfnBV9Tk2H3DKMgrNCHAI0sR1OidwWyj0aeOV89pdNoakJ91nGYp5T-Eya0gmn-iAtbXPwqfg7a5LRK3avHdyjUz0c6hSuFgqUvoUxa9AJwaiSmGCKVoMZCxJRuzkxjWLH00IGaf7lPKrPH-ePg__\u0026Key-Pair-Id=KPI636NEHUJCD","attachmentId":"3506"}}},"blocks":[{"key":"21vq","text":"Create new project","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":18,"style":"BOLD"}],"entityRanges":[],"data":{"entityRefreshHax":1}},{"key":"67bhd","text":"Let's start with creating a new project. Open your Android Studio and select: File -\u003e New -\u003e New Project.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":78,"length":27,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ad2g4","text":"Insert your own domain and project names. Make sure to include Kotlin support - all code snippets in this codelab are written in Kotlin. Target your application to Phones and Tablets, and select API level 23 as minimum SDK. Then select Empty Activity and create your project with activity name - MainActivity and layout name - activity_main. Check both Backwards Compatibility and Generate Layout File options and press Finish.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":80,"length":55,"style":"BOLD"},{"offset":195,"length":12,"style":"BOLD"},{"offset":236,"length":14,"style":"BOLD"},{"offset":353,"length":23,"style":"BOLD"},{"offset":381,"length":20,"style":"BOLD"},{"offset":420,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"23fvk","text":"Draw your layout","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":16,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"br1ki","text":"Before we start using TDD, you need to draw your layout. As you probably know, we are not testing XML files, so at this point we're not using Test Driven Development yet.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":142,"length":23,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"c6orm","text":"The layout should include 4 views - 2 EditTexts to allow user to type the text for coordinates, a Button to trigger action and a TextView to display the result. You can lay them out however you like, but the simplest way to to it is using a LinearLayout.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":38,"length":9,"style":"BOLD"},{"offset":98,"length":6,"style":"BOLD"},{"offset":129,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6fra","text":"Open your activity_main.xml file and modify it to use Linear Layout:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":10,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9bpl4","text":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\".MainActivity\"\u003e\n\n    \u003cEditText\n        android:id=\"@+id/latInput\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"@string/lat_hint\"\n        android:inputType=\"text\" /\u003e\n\n    \u003cEditText\n        android:id=\"@+id/lonInput\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"@string/lon_hint\"\n        android:inputType=\"text\" /\u003e\n\n    \u003cButton\n        android:id=\"@+id/findCityButton\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginHorizontal=\"16dp\"\n        android:text=\"@string/find_city\" /\u003e\n\n    \u003cTextView\n        android:id=\"@+id/cityResult\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" /\u003e\n\n\u003c/LinearLayout\u003e","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":39,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"f3n9u","text":"Add any strings resources to your strings.xml file:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":34,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bleht","text":"\u003cresources\u003e\n   \u003cstring name=\"app_name\"\u003eCity Finder\u003c/string\u003e\n   \u003cstring name=\"lat_hint\"\u003eType latitude\u003c/string\u003e\n   \u003cstring name=\"lon_hint\"\u003eType longitude\u003c/string\u003e\n   \u003cstring name=\"find_city\"\u003eFind\u003c/string\u003e\n\u003c/resources\u003e","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"CODE"},{"offset":202,"length":13,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"3c3rk","text":"The result should be similar to this:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fll9s","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"dt0bq","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dr1eb","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8mfck","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 1: Getting started","body":null,"serialized_body":"\u003ch2\u003e\u003cstrong\u003eCreate new project\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eLet\u0026#x27;s start with creating a new project. Open your Android Studio and select: \u003cstrong\u003eFile -\u0026gt; New -\u0026gt; New Project.\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eInsert your own domain and project names. Make sure to include Kotlin support - \u003cstrong\u003eall code snippets in this codelab are written in Kotlin\u003c/strong\u003e. Target your application to Phones and Tablets, and select \u003cstrong\u003eAPI level 23\u003c/strong\u003e as minimum SDK. Then select \u003cstrong\u003eEmpty Activity\u003c/strong\u003e and create your project with activity name - MainActivity and layout name - activity_main. Check both \u003cstrong\u003eBackwards Compatibility\u003c/strong\u003e and \u003cstrong\u003eGenerate Layout File\u003c/strong\u003e options and press \u003cstrong\u003eFinish\u003c/strong\u003e.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eDraw your layout\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eBefore we start using TDD, you need to draw your layout. As you probably know, we are not testing XML files, so at this point we\u0026#x27;re not using \u003cstrong\u003eTest Driven Development\u003c/strong\u003e yet.\u003c/p\u003e\u003cp\u003eThe layout should include 4 views - 2 \u003cstrong\u003eEditTexts\u003c/strong\u003e to allow user to type the text for coordinates, a \u003cstrong\u003eButton\u003c/strong\u003e to trigger action and a \u003cstrong\u003eTextView\u003c/strong\u003e to display the result. You can lay them out however you like, but the simplest way to to it is using a LinearLayout.\u003c/p\u003e\u003cp\u003eOpen your \u003cstrong\u003eactivity_main.xml\u003c/strong\u003e file and modify it to use Linear Layout:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\n\u003c/span\u003e\u0026lt;LinearLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\n    xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\n    android:layout_width=\u0026quot;match_parent\u0026quot;\n    android:layout_height=\u0026quot;match_parent\u0026quot;\n    android:orientation=\u0026quot;vertical\u0026quot;\n    tools:context=\u0026quot;.MainActivity\u0026quot;\u0026gt;\n\n    \u0026lt;EditText\n        android:id=\u0026quot;@+id/latInput\u0026quot;\n        android:layout_width=\u0026quot;match_parent\u0026quot;\n        android:layout_height=\u0026quot;wrap_content\u0026quot;\n        android:hint=\u0026quot;@string/lat_hint\u0026quot;\n        android:inputType=\u0026quot;text\u0026quot; /\u0026gt;\n\n    \u0026lt;EditText\n        android:id=\u0026quot;@+id/lonInput\u0026quot;\n        android:layout_width=\u0026quot;match_parent\u0026quot;\n        android:layout_height=\u0026quot;wrap_content\u0026quot;\n        android:hint=\u0026quot;@string/lon_hint\u0026quot;\n        android:inputType=\u0026quot;text\u0026quot; /\u0026gt;\n\n    \u0026lt;Button\n        android:id=\u0026quot;@+id/findCityButton\u0026quot;\n        android:layout_width=\u0026quot;match_parent\u0026quot;\n        android:layout_height=\u0026quot;wrap_content\u0026quot;\n        android:layout_marginHorizontal=\u0026quot;16dp\u0026quot;\n        android:text=\u0026quot;@string/find_city\u0026quot; /\u0026gt;\n\n    \u0026lt;TextView\n        android:id=\u0026quot;@+id/cityResult\u0026quot;\n        android:layout_width=\u0026quot;wrap_content\u0026quot;\n        android:layout_height=\u0026quot;wrap_content\u0026quot; /\u0026gt;\n\n\u0026lt;/LinearLayout\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAdd any strings resources to your \u003cstrong\u003estrings.xml\u003c/strong\u003e file:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e\u0026lt;resources\u0026gt;\n   \u003c/span\u003e\u0026lt;string name=\u0026quot;app_name\u0026quot;\u0026gt;City Finder\u0026lt;/string\u0026gt;\n   \u0026lt;string name=\u0026quot;lat_hint\u0026quot;\u0026gt;Type latitude\u0026lt;/string\u0026gt;\n   \u0026lt;string name=\u0026quot;lon_hint\u0026quot;\u0026gt;Type longitude\u0026lt;/string\u0026gt;\n   \u0026lt;string name=\u0026quot;find_city\u0026quot;\u0026gt;Find\u0026lt;/string\u0026gt;\u003cspan\u003e\n\u0026lt;/resources\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe result should be similar to this:\u003c/p\u003e\u003cimg src=\"https://filestore.prod-dub.bridgeapp.com/512/1/uploads/dc1b6d29-2c0d-4e71-bb7e-08d297ca9b8c.png?response-content-disposition=attachment%3Bfilename%3DScreenshot%2B2022-03-29%2Bat%2B15.21.59.png\u0026amp;Expires=1648561951\u0026amp;Signature=HiMXnU8l8QtRKXDT~mpyqMK42fdApYnjcmONdIryLpJyNGyCYZSwb~iyAbA1upB7tYAQF-cMEr3YuTfiodEA7kNAOm2KV39W76wnwT8im4ZdnBlzY51XvzkoUgbrB2RD7uIwRfwTOu7yVRpJqnVsPL7ZZw4itajsMJi0DATB8C2TzGlypQyhJjLA4TJbHJqzR0dmfnBV9Tk2H3DKMgrNCHAI0sR1OidwWyj0aeOV89pdNoakJ91nGYp5T-Eya0gmn-iAtbXPwqfg7a5LRK3avHdyjUz0c6hSuFgqUvoUxa9AJwaiSmGCKVoMZCxJRuzkxjWLH00IGaf7lPKrPH-ePg__\u0026amp;Key-Pair-Id=KPI636NEHUJCD\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003c/p\u003e","structured_body":{"entityMap":{"0":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://filestore.prod-dub.bridgeapp.com/512/1/uploads/dc1b6d29-2c0d-4e71-bb7e-08d297ca9b8c.png?response-content-disposition=attachment%3Bfilename%3DScreenshot%2B2022-03-29%2Bat%2B15.21.59.png\u0026Expires=1648561951\u0026Signature=HiMXnU8l8QtRKXDT~mpyqMK42fdApYnjcmONdIryLpJyNGyCYZSwb~iyAbA1upB7tYAQF-cMEr3YuTfiodEA7kNAOm2KV39W76wnwT8im4ZdnBlzY51XvzkoUgbrB2RD7uIwRfwTOu7yVRpJqnVsPL7ZZw4itajsMJi0DATB8C2TzGlypQyhJjLA4TJbHJqzR0dmfnBV9Tk2H3DKMgrNCHAI0sR1OidwWyj0aeOV89pdNoakJ91nGYp5T-Eya0gmn-iAtbXPwqfg7a5LRK3avHdyjUz0c6hSuFgqUvoUxa9AJwaiSmGCKVoMZCxJRuzkxjWLH00IGaf7lPKrPH-ePg__\u0026Key-Pair-Id=KPI636NEHUJCD","attachmentId":"3506"}}},"blocks":[{"key":"21vq","text":"Create new project","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":18,"style":"BOLD"}],"entityRanges":[],"data":{"entityRefreshHax":1}},{"key":"67bhd","text":"Let's start with creating a new project. Open your Android Studio and select: File -\u003e New -\u003e New Project.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":78,"length":27,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ad2g4","text":"Insert your own domain and project names. Make sure to include Kotlin support - all code snippets in this codelab are written in Kotlin. Target your application to Phones and Tablets, and select API level 23 as minimum SDK. Then select Empty Activity and create your project with activity name - MainActivity and layout name - activity_main. Check both Backwards Compatibility and Generate Layout File options and press Finish.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":80,"length":55,"style":"BOLD"},{"offset":195,"length":12,"style":"BOLD"},{"offset":236,"length":14,"style":"BOLD"},{"offset":353,"length":23,"style":"BOLD"},{"offset":381,"length":20,"style":"BOLD"},{"offset":420,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"23fvk","text":"Draw your layout","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":16,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"br1ki","text":"Before we start using TDD, you need to draw your layout. As you probably know, we are not testing XML files, so at this point we're not using Test Driven Development yet.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":142,"length":23,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"c6orm","text":"The layout should include 4 views - 2 EditTexts to allow user to type the text for coordinates, a Button to trigger action and a TextView to display the result. You can lay them out however you like, but the simplest way to to it is using a LinearLayout.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":38,"length":9,"style":"BOLD"},{"offset":98,"length":6,"style":"BOLD"},{"offset":129,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6fra","text":"Open your activity_main.xml file and modify it to use Linear Layout:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":10,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9bpl4","text":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\".MainActivity\"\u003e\n\n    \u003cEditText\n        android:id=\"@+id/latInput\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"@string/lat_hint\"\n        android:inputType=\"text\" /\u003e\n\n    \u003cEditText\n        android:id=\"@+id/lonInput\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"@string/lon_hint\"\n        android:inputType=\"text\" /\u003e\n\n    \u003cButton\n        android:id=\"@+id/findCityButton\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginHorizontal=\"16dp\"\n        android:text=\"@string/find_city\" /\u003e\n\n    \u003cTextView\n        android:id=\"@+id/cityResult\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" /\u003e\n\n\u003c/LinearLayout\u003e","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":39,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"f3n9u","text":"Add any strings resources to your strings.xml file:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":34,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bleht","text":"\u003cresources\u003e\n   \u003cstring name=\"app_name\"\u003eCity Finder\u003c/string\u003e\n   \u003cstring name=\"lat_hint\"\u003eType latitude\u003c/string\u003e\n   \u003cstring name=\"lon_hint\"\u003eType longitude\u003c/string\u003e\n   \u003cstring name=\"find_city\"\u003eFind\u003c/string\u003e\n\u003c/resources\u003e","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"CODE"},{"offset":202,"length":13,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"3c3rk","text":"The result should be similar to this:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fll9s","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{}},{"key":"dt0bq","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dr1eb","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8mfck","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":2,"attachments_count":5,"presentable":true,"external_id":null,"attachments":[{"id":3506,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/dc1b6d29-2c0d-4e71-bb7e-08d297ca9b8c.png","duration":null,"name":"Screenshot 2022-03-29 at 15.21.59.png","learner_visible":true,"confirmed":false,"user_id":179,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2022-03-29T15:22:31.204+02:00","sources":[]},{"id":3505,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/00a31eed-5730-4f4d-b1a2-1ebb5a7bf628.png","duration":null,"name":"Screenshot 2022-03-29 at 14.34.55.png","learner_visible":true,"confirmed":false,"user_id":179,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2022-03-29T14:36:20.669+02:00","sources":[]},{"id":3504,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/640452ab-c179-45d1-9c62-707be0f2ab69.png","duration":null,"name":"Screenshot 2022-03-29 at 14.34.55.png","learner_visible":true,"confirmed":false,"user_id":179,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2022-03-29T14:35:25.902+02:00","sources":[]},{"id":1742,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/23cb1ec1-73c1-4131-bc95-369670d2e7b1.png","duration":null,"name":"pasted image 0.png","learner_visible":true,"confirmed":false,"user_id":184,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":null,"sources":[]},{"id":1743,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/5c1f57b1-393c-4a49-8b75-7009a18cadae.png","duration":null,"name":"pasted image 0 (1).png","learner_visible":true,"confirmed":false,"user_id":184,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":null,"sources":[]}]},{"id":781,"position":3,"new_position":3,"published_attributes":{"type":"slide","answers":[],"title":"Step 2: Create the UI Test","body":null,"serialized_body":"\u003ch2\u003e\u003cstrong\u003eCheck required dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eAs mentioned before, the first step of using TDD on Android platform is to create UI Test. We\u0026#x27;re going to use Espresso. Open your \u003cstrong\u003eapp/build.gradle\u003c/strong\u003e file and check if espresso dependencies are added (should be added by default):\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edependencies {\n   ...\n \u003c/span\u003eandroidTestImplementation \u0026#x27;androidx.test:core-ktx:1.4.0\u0026#x27;\nandroidTestImplementation \u0026#x27;androidx.test.ext:junit:1.1.3\u0026#x27;\nandroidTestImplementation \u0026#x27;androidx.test:runner:1.4.0\u0026#x27;\nandroidTestImplementation \u0026#x27;androidx.test.espresso:espresso-core:3.4.0\u0026#x27;\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eCreate Acceptance test\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eLet\u0026#x27;s start creating our tests. Navigate to your \u003cstrong\u003esrc/androidTest\u003c/strong\u003e folder (if there are any files in this folder, feel free to remove them) and create a new File named \u003cstrong\u003eCityFinderAcceptanceTest.kt\u003c/strong\u003e. Create a class with required annotation and empty test method:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@RunWith(AndroidJUnit4::class)\nclass \u003c/span\u003eCityFinderAcceptanceTest\u003cspan\u003e {\n\n   @Test\n   fun verifyCity() {\n\n   }\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOk, now let\u0026#x27;s write the body of the empty test method. We are going to check if our TextView is displaying proper city name for selected coordinates. With Espresso, this test will look like this:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@RunWith(AndroidJUnit4::class)\nclass \u003c/span\u003eCityFinderAcceptanceTest\u003cspan\u003e {\n\n\u003c/span\u003e    @Test\n    fun verifyCity() {\n        \u003cem\u003elaunchActivity\u003c/em\u003e\u0026lt;MainActivity\u0026gt;().\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e     \u003c/strong\u003e    \u003cstrong\u003e   \u003c/strong\u003e//given\n            onView(withId(R.id.\u003cem\u003elatInput\u003c/em\u003e))\n                .perform(typeText(\u0026quot;55.946\u0026quot;))\n\n            onView(withId(R.id.\u003cem\u003elonInput\u003c/em\u003e))\n                .perform(\n                    typeText(\u0026quot;-3.2012\u0026quot;),\n                    closeSoftKeyboard()\n                )\n            //when\n            onView(withId(R.id.\u003cem\u003efindCityButton\u003c/em\u003e))\n                .perform(click())\n\n            //then\n            onView(withId(R.id.\u003cem\u003ecityResult\u003c/em\u003e))\n                .check(\n                    matches(\n                        withText(\u0026quot;City of Edinburgh\u0026quot;)\n                    )\n                )\n        \u003cstrong\u003e}\u003c/strong\u003e\n    }\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun the test. \u003cstrong\u003eIt should fail at this point\u003c/strong\u003e. We will refactor it at the end of this codelab.\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"82js2","text":"Check required dependencies","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":27,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1ns6b","text":"As mentioned before, the first step of using TDD on Android platform is to create UI Test. We're going to use Espresso. Open your app/build.gradle file and check if espresso dependencies are added (should be added by default):","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":130,"length":16,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6ke7i","text":"dependencies {\n   ...\n androidTestImplementation 'androidx.test:core-ktx:1.4.0'\nandroidTestImplementation 'androidx.test.ext:junit:1.1.3'\nandroidTestImplementation 'androidx.test:runner:1.4.0'\nandroidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"CODE"},{"offset":263,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"18vas","text":"Create Acceptance test","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4lk9s","text":"Let's start creating our tests. Navigate to your src/androidTest folder (if there are any files in this folder, feel free to remove them) and create a new File named CityFinderAcceptanceTest.kt. Create a class with required annotation and empty test method:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":49,"length":15,"style":"BOLD"},{"offset":166,"length":27,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bodv1","text":"@RunWith(AndroidJUnit4::class)\nclass CityFinderAcceptanceTest {\n\n   @Test\n   fun verifyCity() {\n\n   }\n}\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":37,"style":"CODE"},{"offset":61,"length":43,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"4otl5","text":"Ok, now let's write the body of the empty test method. We are going to check if our TextView is displaying proper city name for selected coordinates. With Espresso, this test will look like this:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5igve","text":"@RunWith(AndroidJUnit4::class)\nclass CityFinderAcceptanceTest {\n\n    @Test\n    fun verifyCity() {\n        launchActivity\u003cMainActivity\u003e().use {\n            //given\n            onView(withId(R.id.latInput))\n                .perform(typeText(\"55.946\"))\n\n            onView(withId(R.id.lonInput))\n                .perform(\n                    typeText(\"-3.2012\"),\n                    closeSoftKeyboard()\n                )\n            //when\n            onView(withId(R.id.findCityButton))\n                .perform(click())\n\n            //then\n            onView(withId(R.id.cityResult))\n                .check(\n                    matches(\n                        withText(\"City of Edinburgh\")\n                    )\n                )\n        }\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":37,"style":"CODE"},{"offset":61,"length":4,"style":"CODE"},{"offset":745,"length":2,"style":"CODE"},{"offset":106,"length":14,"style":"ITALIC"},{"offset":137,"length":4,"style":"ITALIC"},{"offset":194,"length":8,"style":"ITALIC"},{"offset":282,"length":8,"style":"ITALIC"},{"offset":468,"length":14,"style":"ITALIC"},{"offset":570,"length":10,"style":"ITALIC"},{"offset":141,"length":1,"style":"BOLD"},{"offset":143,"length":5,"style":"BOLD"},{"offset":152,"length":3,"style":"BOLD"},{"offset":738,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"93ijl","text":"Run the test. It should fail at this point. We will refactor it at the end of this codelab.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":14,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 2: Create the UI Test","body":null,"serialized_body":"\u003ch2\u003e\u003cstrong\u003eCheck required dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eAs mentioned before, the first step of using TDD on Android platform is to create UI Test. We\u0026#x27;re going to use Espresso. Open your \u003cstrong\u003eapp/build.gradle\u003c/strong\u003e file and check if espresso dependencies are added (should be added by default):\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edependencies {\n   ...\n \u003c/span\u003eandroidTestImplementation \u0026#x27;androidx.test:core-ktx:1.4.0\u0026#x27;\nandroidTestImplementation \u0026#x27;androidx.test.ext:junit:1.1.3\u0026#x27;\nandroidTestImplementation \u0026#x27;androidx.test:runner:1.4.0\u0026#x27;\nandroidTestImplementation \u0026#x27;androidx.test.espresso:espresso-core:3.4.0\u0026#x27;\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eCreate Acceptance test\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eLet\u0026#x27;s start creating our tests. Navigate to your \u003cstrong\u003esrc/androidTest\u003c/strong\u003e folder (if there are any files in this folder, feel free to remove them) and create a new File named \u003cstrong\u003eCityFinderAcceptanceTest.kt\u003c/strong\u003e. Create a class with required annotation and empty test method:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@RunWith(AndroidJUnit4::class)\nclass \u003c/span\u003eCityFinderAcceptanceTest\u003cspan\u003e {\n\n   @Test\n   fun verifyCity() {\n\n   }\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOk, now let\u0026#x27;s write the body of the empty test method. We are going to check if our TextView is displaying proper city name for selected coordinates. With Espresso, this test will look like this:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@RunWith(AndroidJUnit4::class)\nclass \u003c/span\u003eCityFinderAcceptanceTest\u003cspan\u003e {\n\n\u003c/span\u003e    @Test\n    fun verifyCity() {\n        \u003cem\u003elaunchActivity\u003c/em\u003e\u0026lt;MainActivity\u0026gt;().\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e     \u003c/strong\u003e    \u003cstrong\u003e   \u003c/strong\u003e//given\n            onView(withId(R.id.\u003cem\u003elatInput\u003c/em\u003e))\n                .perform(typeText(\u0026quot;55.946\u0026quot;))\n\n            onView(withId(R.id.\u003cem\u003elonInput\u003c/em\u003e))\n                .perform(\n                    typeText(\u0026quot;-3.2012\u0026quot;),\n                    closeSoftKeyboard()\n                )\n            //when\n            onView(withId(R.id.\u003cem\u003efindCityButton\u003c/em\u003e))\n                .perform(click())\n\n            //then\n            onView(withId(R.id.\u003cem\u003ecityResult\u003c/em\u003e))\n                .check(\n                    matches(\n                        withText(\u0026quot;City of Edinburgh\u0026quot;)\n                    )\n                )\n        \u003cstrong\u003e}\u003c/strong\u003e\n    }\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun the test. \u003cstrong\u003eIt should fail at this point\u003c/strong\u003e. We will refactor it at the end of this codelab.\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"82js2","text":"Check required dependencies","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":27,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1ns6b","text":"As mentioned before, the first step of using TDD on Android platform is to create UI Test. We're going to use Espresso. Open your app/build.gradle file and check if espresso dependencies are added (should be added by default):","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":130,"length":16,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6ke7i","text":"dependencies {\n   ...\n androidTestImplementation 'androidx.test:core-ktx:1.4.0'\nandroidTestImplementation 'androidx.test.ext:junit:1.1.3'\nandroidTestImplementation 'androidx.test:runner:1.4.0'\nandroidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"CODE"},{"offset":263,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"18vas","text":"Create Acceptance test","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4lk9s","text":"Let's start creating our tests. Navigate to your src/androidTest folder (if there are any files in this folder, feel free to remove them) and create a new File named CityFinderAcceptanceTest.kt. Create a class with required annotation and empty test method:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":49,"length":15,"style":"BOLD"},{"offset":166,"length":27,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bodv1","text":"@RunWith(AndroidJUnit4::class)\nclass CityFinderAcceptanceTest {\n\n   @Test\n   fun verifyCity() {\n\n   }\n}\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":37,"style":"CODE"},{"offset":61,"length":43,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"4otl5","text":"Ok, now let's write the body of the empty test method. We are going to check if our TextView is displaying proper city name for selected coordinates. With Espresso, this test will look like this:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5igve","text":"@RunWith(AndroidJUnit4::class)\nclass CityFinderAcceptanceTest {\n\n    @Test\n    fun verifyCity() {\n        launchActivity\u003cMainActivity\u003e().use {\n            //given\n            onView(withId(R.id.latInput))\n                .perform(typeText(\"55.946\"))\n\n            onView(withId(R.id.lonInput))\n                .perform(\n                    typeText(\"-3.2012\"),\n                    closeSoftKeyboard()\n                )\n            //when\n            onView(withId(R.id.findCityButton))\n                .perform(click())\n\n            //then\n            onView(withId(R.id.cityResult))\n                .check(\n                    matches(\n                        withText(\"City of Edinburgh\")\n                    )\n                )\n        }\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":37,"style":"CODE"},{"offset":61,"length":4,"style":"CODE"},{"offset":745,"length":2,"style":"CODE"},{"offset":106,"length":14,"style":"ITALIC"},{"offset":137,"length":4,"style":"ITALIC"},{"offset":194,"length":8,"style":"ITALIC"},{"offset":282,"length":8,"style":"ITALIC"},{"offset":468,"length":14,"style":"ITALIC"},{"offset":570,"length":10,"style":"ITALIC"},{"offset":141,"length":1,"style":"BOLD"},{"offset":143,"length":5,"style":"BOLD"},{"offset":152,"length":3,"style":"BOLD"},{"offset":738,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"93ijl","text":"Run the test. It should fail at this point. We will refactor it at the end of this codelab.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":14,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":1,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":782,"position":4,"new_position":4,"published_attributes":{"type":"slide","answers":[],"title":"Step 3: Setup your network layer","body":null,"serialized_body":"\u003ch2\u003e\u003cstrong\u003eAdd required dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eAt the beginning of this step, we are going to add required dependencies to our application. We will use them later in this step.\u003c/p\u003e\u003cp\u003eOpen your \u003cstrong\u003ebuild.gradle\u003c/strong\u003e and add the following dependencies:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003edef okhttp_version = \u0026quot;4.9.3\u0026quot;\ndef coroutines_version = \u0026quot;1.6.0\u0026quot;\ndef kotlin_version = \u0026quot;1.6.10\u0026quot;\n\nimplementation \u0026quot;com.squareup.okhttp3:okhttp:$okhttp_version\u0026quot;\nimplementation \u0026#x27;com.squareup.retrofit2:retrofit:2.9.0\u0026#x27;\nimplementation \u0026#x27;com.squareup.retrofit2:converter-moshi:2.9.0\u0026#x27;\nimplementation \u0026#x27;com.squareup.moshi:moshi-kotlin:1.13.0\u0026#x27;\nimplementation \u0026quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version\u0026quot;\n\ntestImplementation \u0026quot;com.squareup.okhttp3:mockwebserver:$okhttp_version\u0026quot;\ntestImplementation \u0026quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version\u0026quot;\ntestImplementation \u0026quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version\u0026quot;\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eTest your network using curl\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eBefore we start testing our network layer, we need to get an example response from our server. We are going to use \u003ca href=\"https://postcodes.io/\"\u003ePost Codes API\u003c/a\u003e to receive city name. Use curl to test it and see an example response. Type in your terminal:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003ecurl -X GET -H \u0026quot;Accept: application/json\u0026quot; \u0026quot;https://api.postcodes.io/postcodes?lon=-3.2012\u0026amp;lat=55.946\u0026amp;limit=1\u0026quot;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou should receive a response in the JSON format. Save it somewhere - we\u0026#x27;re going to need it shortly.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eGenerate you model data\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eTo create our test, we will need some model objects. We are going to generate model classes with \u003ca href=\"https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-\"\u003eJsonToKotlinClass\u003c/a\u003e plugin to make it easier. If you do not have it installed yet, do it right now. It is Android Studio plugin which can generate model classes from your json string.\u003c/p\u003e\u003cp\u003eCreate new package named \u003cstrong\u003edata.remote.model\u003c/strong\u003e, create a Kotlin file named  \u003cstrong\u003eCityResponse\u003c/strong\u003e and inside it use \u003cstrong\u003eOption+K\u003c/strong\u003e shortcut to open the plugin pop-up. Fill the \u003cstrong\u003ecopy json here\u003c/strong\u003e text area with previously received response. Name your root class: \u003cstrong\u003eCityResponse\u003c/strong\u003e.\u003c/p\u003e\u003cimg src=\"https://filestore.prod-dub.bridgeapp.com/512/1/uploads/1b6e0c42-991e-4249-8ec0-4c6ee471c2e8.png?response-content-disposition=attachment%3Bfilename%3DScreenshot%2B2022-04-05%2Bat%2B14.17.37.png\u0026amp;Expires=1649162937\u0026amp;Signature=jUDiS~NR1sRjfcjEpZY91li1OL2kHZRDgDY8Xoe6Mrv22RaD~DueC0ZTvJTbYz7Y6PrYyj89BP1hjZJqXJHk2nZsSIXBb0BS9XdHo0r3d0uv1cv9EUJLFRrVdJgomJNB39JH8khf19n0JbnRNLrsQThk5DS2AUyVs-LWFX4B~mfPz0JoyH03ymgNcpr5YuodnMg6cZRenItvVkEAfwl5Z9baNRKppaXebL6F8NKR~a7KUOxBBNSsfZqiddxVZtPONtn3WoGokCeN3UzdmrdstkzeXEP8h1nMsQpDWIkg~bMW23LE7AxkaaBHSfrCRUsjqp74AiJUoPavsDLHkSGxnQ__\u0026amp;Key-Pair-Id=KPI636NEHUJCD\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003eSelect \u003cstrong\u003eMoshi (codegen)\u003c/strong\u003e annotations style in the \u003cstrong\u003eAdvanced\u003c/strong\u003e settings and click \u003cstrong\u003egenerate\u003c/strong\u003e.\nThe generated result object has a lot of properties, but we will be interested only in one - \u003cstrong\u003eadminDistrict\u003c/strong\u003e, as it\u0026#x27;s the property carrying a city name, or a city district if a city is very large (like London). You can remove all other fields. We can also rename the generated \u003cstrong\u003eResult\u003c/strong\u003e class into more meaningful \u003cstrong\u003eCityInfo\u003c/strong\u003e.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eCreating JUnit tests\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eTime to create some unit tests with JUnit. Under \u003cstrong\u003esrc-\u0026gt;test\u003c/strong\u003e create new directory named \u003cstrong\u003eresources\u003c/strong\u003e. Inside this folder create a file named \u003cstrong\u003eresponse.json\u003c/strong\u003e and paste the response you have previously received from \u003cstrong\u003ePost Codes API\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eUnder \u003cstrong\u003eremote \u003c/strong\u003epackage\u003cstrong\u003e \u003c/strong\u003efolder create a new interface named \u003cstrong\u003eFindCityService\u003c/strong\u003e and add a simple method declaration:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003einterface FindCityService {\n    suspend fun findCity(\n        latitude: String,\n        longitude: String,\n        limit: Int = 1\n    ): CityResponse\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFinally, it\u0026#x27;s time to create the unit test. Inside the src/test/your_package/data/remote folder create a new class named \u003cstrong\u003eApiConfigurationTest.\u003c/strong\u003e\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eMake your test fail\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eAs you may have noticed, we are not going to create any rest client code - the networking will be handled by the \u003cstrong\u003eRetrofit\u003c/strong\u003e library. The goal is to check whether implemented retrofit configuration is correct (maybe it is not so necessary for this API, but it is very important for more complex requests). To do it, we are going to use the \u003cstrong\u003eMockWebServer\u003c/strong\u003e library.\u003c/p\u003e\u003cp\u003eAt the bottom of the created test class add a method to read the JSON file from resources into a String object:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate fun readFile(path: String) = \n    \u003cem\u003ejavaClass\u003c/em\u003e.\u003cem\u003eclassLoader\u003c/em\u003e?.getResourceAsStream(path)\n        ?.\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ it\u003c/strong\u003e.\u003cem\u003ebufferedReader\u003c/em\u003e().\u003cem\u003ereadText\u003c/em\u003e() \u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, come back to the \u003cstrong\u003eApiConfigurationTest\u003c/strong\u003e file and add the following code to the class:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass ApiConfigurationTest {\n    private val server = MockWebServer()\n\n    @After\n    fun clear() {\n        server.shutdown()\n    }\n\n    @Test\n    fun `verify findCity api call`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e    val latitude = \u0026quot;1.0\u0026quot;\n        val longitude = \u0026quot;2.0\u0026quot;\n        val responseJson = readFile(\u0026quot;response.json\u0026quot;)\n            .\u003cem\u003eorEmpty\u003c/em\u003e()\n        val response = MockResponse()                             \n            .setBody(responseJson)\n            .setResponseCode(200)         \n        \n        server.enqueue(response)\n        \u003cem\u003efail\u003c/em\u003e()\n        // rest of the test will be added later\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor now, we can only prepare the mock response to be returned from the server, as the rest of the test will require configuring the DI layer. We will come back to it later.\u003c/p\u003e","structured_body":{"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://postcodes.io/","text":"Post Codes API"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-","text":"JsonToKotlinClass"}},"2":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://filestore.prod-dub.bridgeapp.com/512/1/uploads/1b6e0c42-991e-4249-8ec0-4c6ee471c2e8.png?response-content-disposition=attachment%3Bfilename%3DScreenshot%2B2022-04-05%2Bat%2B14.17.37.png\u0026Expires=1649162937\u0026Signature=jUDiS~NR1sRjfcjEpZY91li1OL2kHZRDgDY8Xoe6Mrv22RaD~DueC0ZTvJTbYz7Y6PrYyj89BP1hjZJqXJHk2nZsSIXBb0BS9XdHo0r3d0uv1cv9EUJLFRrVdJgomJNB39JH8khf19n0JbnRNLrsQThk5DS2AUyVs-LWFX4B~mfPz0JoyH03ymgNcpr5YuodnMg6cZRenItvVkEAfwl5Z9baNRKppaXebL6F8NKR~a7KUOxBBNSsfZqiddxVZtPONtn3WoGokCeN3UzdmrdstkzeXEP8h1nMsQpDWIkg~bMW23LE7AxkaaBHSfrCRUsjqp74AiJUoPavsDLHkSGxnQ__\u0026Key-Pair-Id=KPI636NEHUJCD","attachmentId":"3509"}}},"blocks":[{"key":"43dnn","text":"Add required dependencies","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":25,"style":"BOLD"}],"entityRanges":[],"data":{"entityRefreshHax":1}},{"key":"aag47","text":"At the beginning of this step, we are going to add required dependencies to our application. We will use them later in this step.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fru36","text":"Open your build.gradle and add the following dependencies:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":10,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5plom","text":"def okhttp_version = \"4.9.3\"\ndef coroutines_version = \"1.6.0\"\ndef kotlin_version = \"1.6.10\"\n\nimplementation \"com.squareup.okhttp3:okhttp:$okhttp_version\"\nimplementation 'com.squareup.retrofit2:retrofit:2.9.0'\nimplementation 'com.squareup.retrofit2:converter-moshi:2.9.0'\nimplementation 'com.squareup.moshi:moshi-kotlin:1.13.0'\nimplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version\"\n\ntestImplementation \"com.squareup.okhttp3:mockwebserver:$okhttp_version\"\ntestImplementation \"org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version\"\ntestImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version\"","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9saq6","text":"Test your network using curl","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6e8vf","text":"Before we start testing our network layer, we need to get an example response from our server. We are going to use Post Codes API to receive city name. Use curl to test it and see an example response. Type in your terminal:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":115,"length":14,"key":0}],"data":{}},{"key":"e8g3q","text":"curl -X GET -H \"Accept: application/json\" \"https://api.postcodes.io/postcodes?lon=-3.2012\u0026lat=55.946\u0026limit=1\"","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9r3uk","text":"You should receive a response in the JSON format. Save it somewhere - we're going to need it shortly.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"tnlm","text":"Generate you model data","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2ock7","text":"To create our test, we will need some model objects. We are going to generate model classes with JsonToKotlinClass plugin to make it easier. If you do not have it installed yet, do it right now. It is Android Studio plugin which can generate model classes from your json string.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":97,"length":17,"key":1}],"data":{}},{"key":"8mao3","text":"Create new package named data.remote.model, create a Kotlin file named  CityResponse and inside it use Option+K shortcut to open the plugin pop-up. Fill the copy json here text area with previously received response. Name your root class: CityResponse.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":25,"length":17,"style":"BOLD"},{"offset":72,"length":12,"style":"BOLD"},{"offset":103,"length":8,"style":"BOLD"},{"offset":157,"length":14,"style":"BOLD"},{"offset":239,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"anl6o","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":2}],"data":{}},{"key":"519ck","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"oim1","text":"Select Moshi (codegen) annotations style in the Advanced settings and click generate.\nThe generated result object has a lot of properties, but we will be interested only in one - adminDistrict, as it's the property carrying a city name, or a city district if a city is very large (like London). You can remove all other fields. We can also rename the generated Result class into more meaningful CityInfo.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":7,"length":15,"style":"BOLD"},{"offset":48,"length":8,"style":"BOLD"},{"offset":76,"length":8,"style":"BOLD"},{"offset":179,"length":13,"style":"BOLD"},{"offset":361,"length":6,"style":"BOLD"},{"offset":395,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"67fui","text":"Creating JUnit tests","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"elo1i","text":"Time to create some unit tests with JUnit. Under src-\u003etest create new directory named resources. Inside this folder create a file named response.json and paste the response you have previously received from Post Codes API.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":49,"length":9,"style":"BOLD"},{"offset":86,"length":9,"style":"BOLD"},{"offset":136,"length":13,"style":"BOLD"},{"offset":207,"length":14,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"837r8","text":"Under remote package folder create a new interface named FindCityService and add a simple method declaration:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":6,"length":7,"style":"BOLD"},{"offset":20,"length":1,"style":"BOLD"},{"offset":57,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"c4e3d","text":"interface FindCityService {\n    suspend fun findCity(\n        latitude: String,\n        longitude: String,\n        limit: Int = 1\n    ): CityResponse\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"boi0f","text":"Finally, it's time to create the unit test. Inside the src/test/your_package/data/remote folder create a new class named ApiConfigurationTest.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":121,"length":21,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1i5g1","text":"Make your test fail","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"flfab","text":"As you may have noticed, we are not going to create any rest client code - the networking will be handled by the Retrofit library. The goal is to check whether implemented retrofit configuration is correct (maybe it is not so necessary for this API, but it is very important for more complex requests). To do it, we are going to use the MockWebServer library.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":113,"length":8,"style":"BOLD"},{"offset":337,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6j8o1","text":"At the bottom of the created test class add a method to read the JSON file from resources into a String object:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9kcek","text":"private fun readFile(path: String) = \n    javaClass.classLoader?.getResourceAsStream(path)\n        ?.use { it.bufferedReader().readText() }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":42,"length":9,"style":"ITALIC"},{"offset":52,"length":11,"style":"ITALIC"},{"offset":101,"length":4,"style":"ITALIC"},{"offset":110,"length":14,"style":"ITALIC"},{"offset":127,"length":8,"style":"ITALIC"},{"offset":105,"length":4,"style":"BOLD"},{"offset":138,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7av21","text":"Then, come back to the ApiConfigurationTest file and add the following code to the class:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":23,"length":20,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4ullp","text":"class ApiConfigurationTest {\n    private val server = MockWebServer()\n\n    @After\n    fun clear() {\n        server.shutdown()\n    }\n\n    @Test\n    fun `verify findCity api call`() = runTest {\n        val latitude = \"1.0\"\n        val longitude = \"2.0\"\n        val responseJson = readFile(\"response.json\")\n            .orEmpty()\n        val response = MockResponse()                             \n            .setBody(responseJson)\n            .setResponseCode(200)         \n        \n        server.enqueue(response)\n        fail()\n        // rest of the test will be added later\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":182,"length":8,"style":"ITALIC"},{"offset":317,"length":7,"style":"ITALIC"},{"offset":522,"length":4,"style":"ITALIC"},{"offset":190,"length":1,"style":"BOLD"},{"offset":192,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"64agm","text":"For now, we can only prepare the mock response to be returned from the server, as the rest of the test will require configuring the DI layer. We will come back to it later.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 3: Setup your network layer","body":null,"serialized_body":"\u003ch2\u003e\u003cstrong\u003eAdd required dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eAt the beginning of this step, we are going to add required dependencies to our application. We will use them later in this step.\u003c/p\u003e\u003cp\u003eOpen your \u003cstrong\u003ebuild.gradle\u003c/strong\u003e and add the following dependencies:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003edef okhttp_version = \u0026quot;4.9.3\u0026quot;\ndef coroutines_version = \u0026quot;1.6.0\u0026quot;\ndef kotlin_version = \u0026quot;1.6.10\u0026quot;\n\nimplementation \u0026quot;com.squareup.okhttp3:okhttp:$okhttp_version\u0026quot;\nimplementation \u0026#x27;com.squareup.retrofit2:retrofit:2.9.0\u0026#x27;\nimplementation \u0026#x27;com.squareup.retrofit2:converter-moshi:2.9.0\u0026#x27;\nimplementation \u0026#x27;com.squareup.moshi:moshi-kotlin:1.13.0\u0026#x27;\nimplementation \u0026quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version\u0026quot;\n\ntestImplementation \u0026quot;com.squareup.okhttp3:mockwebserver:$okhttp_version\u0026quot;\ntestImplementation \u0026quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version\u0026quot;\ntestImplementation \u0026quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version\u0026quot;\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eTest your network using curl\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eBefore we start testing our network layer, we need to get an example response from our server. We are going to use \u003ca href=\"https://postcodes.io/\"\u003ePost Codes API\u003c/a\u003e to receive city name. Use curl to test it and see an example response. Type in your terminal:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003ecurl -X GET -H \u0026quot;Accept: application/json\u0026quot; \u0026quot;https://api.postcodes.io/postcodes?lon=-3.2012\u0026amp;lat=55.946\u0026amp;limit=1\u0026quot;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou should receive a response in the JSON format. Save it somewhere - we\u0026#x27;re going to need it shortly.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eGenerate you model data\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eTo create our test, we will need some model objects. We are going to generate model classes with \u003ca href=\"https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-\"\u003eJsonToKotlinClass\u003c/a\u003e plugin to make it easier. If you do not have it installed yet, do it right now. It is Android Studio plugin which can generate model classes from your json string.\u003c/p\u003e\u003cp\u003eCreate new package named \u003cstrong\u003edata.remote.model\u003c/strong\u003e, create a Kotlin file named  \u003cstrong\u003eCityResponse\u003c/strong\u003e and inside it use \u003cstrong\u003eOption+K\u003c/strong\u003e shortcut to open the plugin pop-up. Fill the \u003cstrong\u003ecopy json here\u003c/strong\u003e text area with previously received response. Name your root class: \u003cstrong\u003eCityResponse\u003c/strong\u003e.\u003c/p\u003e\u003cimg src=\"https://filestore.prod-dub.bridgeapp.com/512/1/uploads/1b6e0c42-991e-4249-8ec0-4c6ee471c2e8.png?response-content-disposition=attachment%3Bfilename%3DScreenshot%2B2022-04-05%2Bat%2B14.17.37.png\u0026amp;Expires=1649162937\u0026amp;Signature=jUDiS~NR1sRjfcjEpZY91li1OL2kHZRDgDY8Xoe6Mrv22RaD~DueC0ZTvJTbYz7Y6PrYyj89BP1hjZJqXJHk2nZsSIXBb0BS9XdHo0r3d0uv1cv9EUJLFRrVdJgomJNB39JH8khf19n0JbnRNLrsQThk5DS2AUyVs-LWFX4B~mfPz0JoyH03ymgNcpr5YuodnMg6cZRenItvVkEAfwl5Z9baNRKppaXebL6F8NKR~a7KUOxBBNSsfZqiddxVZtPONtn3WoGokCeN3UzdmrdstkzeXEP8h1nMsQpDWIkg~bMW23LE7AxkaaBHSfrCRUsjqp74AiJUoPavsDLHkSGxnQ__\u0026amp;Key-Pair-Id=KPI636NEHUJCD\"/\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003eSelect \u003cstrong\u003eMoshi (codegen)\u003c/strong\u003e annotations style in the \u003cstrong\u003eAdvanced\u003c/strong\u003e settings and click \u003cstrong\u003egenerate\u003c/strong\u003e.\nThe generated result object has a lot of properties, but we will be interested only in one - \u003cstrong\u003eadminDistrict\u003c/strong\u003e, as it\u0026#x27;s the property carrying a city name, or a city district if a city is very large (like London). You can remove all other fields. We can also rename the generated \u003cstrong\u003eResult\u003c/strong\u003e class into more meaningful \u003cstrong\u003eCityInfo\u003c/strong\u003e.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eCreating JUnit tests\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eTime to create some unit tests with JUnit. Under \u003cstrong\u003esrc-\u0026gt;test\u003c/strong\u003e create new directory named \u003cstrong\u003eresources\u003c/strong\u003e. Inside this folder create a file named \u003cstrong\u003eresponse.json\u003c/strong\u003e and paste the response you have previously received from \u003cstrong\u003ePost Codes API\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eUnder \u003cstrong\u003eremote \u003c/strong\u003epackage\u003cstrong\u003e \u003c/strong\u003efolder create a new interface named \u003cstrong\u003eFindCityService\u003c/strong\u003e and add a simple method declaration:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003einterface FindCityService {\n    suspend fun findCity(\n        latitude: String,\n        longitude: String,\n        limit: Int = 1\n    ): CityResponse\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFinally, it\u0026#x27;s time to create the unit test. Inside the src/test/your_package/data/remote folder create a new class named \u003cstrong\u003eApiConfigurationTest.\u003c/strong\u003e\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eMake your test fail\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eAs you may have noticed, we are not going to create any rest client code - the networking will be handled by the \u003cstrong\u003eRetrofit\u003c/strong\u003e library. The goal is to check whether implemented retrofit configuration is correct (maybe it is not so necessary for this API, but it is very important for more complex requests). To do it, we are going to use the \u003cstrong\u003eMockWebServer\u003c/strong\u003e library.\u003c/p\u003e\u003cp\u003eAt the bottom of the created test class add a method to read the JSON file from resources into a String object:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate fun readFile(path: String) = \n    \u003cem\u003ejavaClass\u003c/em\u003e.\u003cem\u003eclassLoader\u003c/em\u003e?.getResourceAsStream(path)\n        ?.\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ it\u003c/strong\u003e.\u003cem\u003ebufferedReader\u003c/em\u003e().\u003cem\u003ereadText\u003c/em\u003e() \u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, come back to the \u003cstrong\u003eApiConfigurationTest\u003c/strong\u003e file and add the following code to the class:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass ApiConfigurationTest {\n    private val server = MockWebServer()\n\n    @After\n    fun clear() {\n        server.shutdown()\n    }\n\n    @Test\n    fun `verify findCity api call`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e    val latitude = \u0026quot;1.0\u0026quot;\n        val longitude = \u0026quot;2.0\u0026quot;\n        val responseJson = readFile(\u0026quot;response.json\u0026quot;)\n            .\u003cem\u003eorEmpty\u003c/em\u003e()\n        val response = MockResponse()                             \n            .setBody(responseJson)\n            .setResponseCode(200)         \n        \n        server.enqueue(response)\n        \u003cem\u003efail\u003c/em\u003e()\n        // rest of the test will be added later\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor now, we can only prepare the mock response to be returned from the server, as the rest of the test will require configuring the DI layer. We will come back to it later.\u003c/p\u003e","structured_body":{"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://postcodes.io/","text":"Post Codes API"}},"1":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-","text":"JsonToKotlinClass"}},"2":{"type":"image","mutability":"IMMUTABLE","data":{"uploadId":null,"src":"https://filestore.prod-dub.bridgeapp.com/512/1/uploads/1b6e0c42-991e-4249-8ec0-4c6ee471c2e8.png?response-content-disposition=attachment%3Bfilename%3DScreenshot%2B2022-04-05%2Bat%2B14.17.37.png\u0026Expires=1649162937\u0026Signature=jUDiS~NR1sRjfcjEpZY91li1OL2kHZRDgDY8Xoe6Mrv22RaD~DueC0ZTvJTbYz7Y6PrYyj89BP1hjZJqXJHk2nZsSIXBb0BS9XdHo0r3d0uv1cv9EUJLFRrVdJgomJNB39JH8khf19n0JbnRNLrsQThk5DS2AUyVs-LWFX4B~mfPz0JoyH03ymgNcpr5YuodnMg6cZRenItvVkEAfwl5Z9baNRKppaXebL6F8NKR~a7KUOxBBNSsfZqiddxVZtPONtn3WoGokCeN3UzdmrdstkzeXEP8h1nMsQpDWIkg~bMW23LE7AxkaaBHSfrCRUsjqp74AiJUoPavsDLHkSGxnQ__\u0026Key-Pair-Id=KPI636NEHUJCD","attachmentId":"3509"}}},"blocks":[{"key":"43dnn","text":"Add required dependencies","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":25,"style":"BOLD"}],"entityRanges":[],"data":{"entityRefreshHax":1}},{"key":"aag47","text":"At the beginning of this step, we are going to add required dependencies to our application. We will use them later in this step.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fru36","text":"Open your build.gradle and add the following dependencies:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":10,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5plom","text":"def okhttp_version = \"4.9.3\"\ndef coroutines_version = \"1.6.0\"\ndef kotlin_version = \"1.6.10\"\n\nimplementation \"com.squareup.okhttp3:okhttp:$okhttp_version\"\nimplementation 'com.squareup.retrofit2:retrofit:2.9.0'\nimplementation 'com.squareup.retrofit2:converter-moshi:2.9.0'\nimplementation 'com.squareup.moshi:moshi-kotlin:1.13.0'\nimplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutines_version\"\n\ntestImplementation \"com.squareup.okhttp3:mockwebserver:$okhttp_version\"\ntestImplementation \"org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version\"\ntestImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version\"","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9saq6","text":"Test your network using curl","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6e8vf","text":"Before we start testing our network layer, we need to get an example response from our server. We are going to use Post Codes API to receive city name. Use curl to test it and see an example response. Type in your terminal:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":115,"length":14,"key":0}],"data":{}},{"key":"e8g3q","text":"curl -X GET -H \"Accept: application/json\" \"https://api.postcodes.io/postcodes?lon=-3.2012\u0026lat=55.946\u0026limit=1\"","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9r3uk","text":"You should receive a response in the JSON format. Save it somewhere - we're going to need it shortly.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"tnlm","text":"Generate you model data","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2ock7","text":"To create our test, we will need some model objects. We are going to generate model classes with JsonToKotlinClass plugin to make it easier. If you do not have it installed yet, do it right now. It is Android Studio plugin which can generate model classes from your json string.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":97,"length":17,"key":1}],"data":{}},{"key":"8mao3","text":"Create new package named data.remote.model, create a Kotlin file named  CityResponse and inside it use Option+K shortcut to open the plugin pop-up. Fill the copy json here text area with previously received response. Name your root class: CityResponse.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":25,"length":17,"style":"BOLD"},{"offset":72,"length":12,"style":"BOLD"},{"offset":103,"length":8,"style":"BOLD"},{"offset":157,"length":14,"style":"BOLD"},{"offset":239,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"anl6o","text":" ","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":2}],"data":{}},{"key":"519ck","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"oim1","text":"Select Moshi (codegen) annotations style in the Advanced settings and click generate.\nThe generated result object has a lot of properties, but we will be interested only in one - adminDistrict, as it's the property carrying a city name, or a city district if a city is very large (like London). You can remove all other fields. We can also rename the generated Result class into more meaningful CityInfo.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":7,"length":15,"style":"BOLD"},{"offset":48,"length":8,"style":"BOLD"},{"offset":76,"length":8,"style":"BOLD"},{"offset":179,"length":13,"style":"BOLD"},{"offset":361,"length":6,"style":"BOLD"},{"offset":395,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"67fui","text":"Creating JUnit tests","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"elo1i","text":"Time to create some unit tests with JUnit. Under src-\u003etest create new directory named resources. Inside this folder create a file named response.json and paste the response you have previously received from Post Codes API.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":49,"length":9,"style":"BOLD"},{"offset":86,"length":9,"style":"BOLD"},{"offset":136,"length":13,"style":"BOLD"},{"offset":207,"length":14,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"837r8","text":"Under remote package folder create a new interface named FindCityService and add a simple method declaration:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":6,"length":7,"style":"BOLD"},{"offset":20,"length":1,"style":"BOLD"},{"offset":57,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"c4e3d","text":"interface FindCityService {\n    suspend fun findCity(\n        latitude: String,\n        longitude: String,\n        limit: Int = 1\n    ): CityResponse\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"boi0f","text":"Finally, it's time to create the unit test. Inside the src/test/your_package/data/remote folder create a new class named ApiConfigurationTest.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":121,"length":21,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1i5g1","text":"Make your test fail","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"flfab","text":"As you may have noticed, we are not going to create any rest client code - the networking will be handled by the Retrofit library. The goal is to check whether implemented retrofit configuration is correct (maybe it is not so necessary for this API, but it is very important for more complex requests). To do it, we are going to use the MockWebServer library.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":113,"length":8,"style":"BOLD"},{"offset":337,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6j8o1","text":"At the bottom of the created test class add a method to read the JSON file from resources into a String object:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9kcek","text":"private fun readFile(path: String) = \n    javaClass.classLoader?.getResourceAsStream(path)\n        ?.use { it.bufferedReader().readText() }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":42,"length":9,"style":"ITALIC"},{"offset":52,"length":11,"style":"ITALIC"},{"offset":101,"length":4,"style":"ITALIC"},{"offset":110,"length":14,"style":"ITALIC"},{"offset":127,"length":8,"style":"ITALIC"},{"offset":105,"length":4,"style":"BOLD"},{"offset":138,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7av21","text":"Then, come back to the ApiConfigurationTest file and add the following code to the class:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":23,"length":20,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4ullp","text":"class ApiConfigurationTest {\n    private val server = MockWebServer()\n\n    @After\n    fun clear() {\n        server.shutdown()\n    }\n\n    @Test\n    fun `verify findCity api call`() = runTest {\n        val latitude = \"1.0\"\n        val longitude = \"2.0\"\n        val responseJson = readFile(\"response.json\")\n            .orEmpty()\n        val response = MockResponse()                             \n            .setBody(responseJson)\n            .setResponseCode(200)         \n        \n        server.enqueue(response)\n        fail()\n        // rest of the test will be added later\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":182,"length":8,"style":"ITALIC"},{"offset":317,"length":7,"style":"ITALIC"},{"offset":522,"length":4,"style":"ITALIC"},{"offset":190,"length":1,"style":"BOLD"},{"offset":192,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"64agm","text":"For now, we can only prepare the mock response to be returned from the server, as the rest of the test will require configuring the DI layer. We will come back to it later.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":3,"attachments_count":4,"presentable":true,"external_id":null,"attachments":[{"id":3509,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/1b6e0c42-991e-4249-8ec0-4c6ee471c2e8.png","duration":null,"name":"Screenshot 2022-04-05 at 14.17.37.png","learner_visible":true,"confirmed":false,"user_id":179,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2022-04-05T14:18:57.310+02:00","sources":[]},{"id":3507,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/9dc2f2a4-e508-4aae-bae0-243c78703693.png","duration":null,"name":"Screenshot 2022-03-29 at 15.31.37.png","learner_visible":true,"confirmed":false,"user_id":179,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":"2022-03-29T15:32:20.761+02:00","sources":[]},{"id":1744,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/d82bb413-8033-4dcc-9c8f-34f28961defc.png","duration":null,"name":"pasted image 0 (2).png","learner_visible":true,"confirmed":false,"user_id":184,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":null,"sources":[]},{"id":1745,"notorious_id":null,"location":"https://s3-eu-west-1.amazonaws.com/bridge-learn-file-store-prod-dub/512/1/uploads/c571cfe7-3100-448c-a4f3-b2a641190ddf.png","duration":null,"name":"pasted image 0 (3).png","learner_visible":true,"confirmed":false,"user_id":184,"context_type":"Slide","content_type":"image/png","file_modified_at":null,"availability":"complete","media":null,"migrated_at":null,"sources":[]}]},{"id":783,"position":5,"new_position":5,"published_attributes":{"type":"slide","answers":[],"title":"Step 4: Testing the database","body":null,"serialized_body":"\u003ch2\u003e\u003cstrong\u003eTesting the database\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWe will be using repository pattern, so we need a database to store any received data. Just like we didn\u0026#x27;t write any networking code apart from the Retrofit configuration, we\u0026#x27;re not going to hard code any queries but instead use \u003cstrong\u003eRoom\u003c/strong\u003e that handles data persistence similar to how Retrofit handles networking.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eAdding required dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eStart with adding Room dependencies:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eplugins \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eid \u0026#x27;com.android.application\u0026#x27;\n    id \u0026#x27;org.jetbrains.kotlin.android\u0026#x27;\n    id \u0026#x27;kotlin-kapt\u0026#x27;\n\u003cstrong\u003e}\u003c/strong\u003e\u003cspan\u003e\n\n    ...\n\ndependencies {\n    ...\u003c/span\u003e\n    def room_version = \u0026quot;2.4.2\u0026quot;\u003cspan\u003e\n    \u003c/span\u003eimplementation \u0026quot;androidx.room:room-ktx:$room_version\u0026quot;\n    kapt \u0026quot;androidx.room:room-compiler:$room_version\u0026quot;\n\n    androidTestImplementation \u0026quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version\u0026quot;\n    androidTestImplementation \u0026quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version\u0026quot;\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eCreating Dao\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWe need class for holding data in database. Create a new package named \u003cstrong\u003edata.local\u003c/strong\u003e and define a class named \u003cstrong\u003eCityEntity\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edata class CityEntity(\n\u003c/span\u003e    \u003cspan\u003eval latitude: String,\n\u003c/span\u003e    val longitude: String,\u003cspan\u003e\n\u003c/span\u003e    \u003cspan\u003eval cityName: String\n)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, in the same package, declare an interface named \u003cstrong\u003eCityDao\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003einterface CitiesDao {\n\u003c/span\u003e    suspend \u003cspan\u003efun insertCity(\n\u003c/span\u003e        \u003cspan\u003eentity: CityEntity\n\u003c/span\u003e    \u003cspan\u003e)\n\u003c/span\u003e    suspend \u003cspan\u003efun getCityName(\n\u003c/span\u003e        \u003cspan\u003elatitude: String,\n\u003c/span\u003e        longitude: String\u003cspan\u003e\n\u003c/span\u003e    \u003cspan\u003e): String\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote, that now we are partially breaking the rules of TDD because we are not creating the DAO implementation but instead we let \u003cstrong\u003eRoom\u003c/strong\u003e generate it, and we only need to check if the configuration is correct.\u003c/p\u003e\u003cp\u003eThe last step before we create and compile our tests, is to create database interface and add proper annotations, to make it possible for Room to generate the implementation.\u003c/p\u003e\u003cp\u003eCreate another class, named \u003cstrong\u003eCitiesDatabase\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@Database(\n\u003c/span\u003e    \u003cspan\u003eentities = [CityEntity::class],\n\u003c/span\u003e    \u003cspan\u003eversion = 1\n)\n\nabstract class CitiesDatabase: RoomDatabase() {\n\u003c/span\u003e    abstract \u003cspan\u003efun citiesDao(): CitiesDao\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAdd required annotations to \u003cstrong\u003eCitiesDao\u003c/strong\u003e and \u003cstrong\u003eCityEntity\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@Entity(tableName = \u0026quot;cities\u0026quot;)\n\u003c/span\u003edata class CityEntity(\n    val latitude: String,\n    val longitude: String,\n    val cityName: String\n) {\u003cspan\u003e\n    @PrimaryKey(autoGenerate = true)\n    var id: Long = 0\n}\n\n....\n\n@Dao\ninterface CitiesDao {\n ...\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eTesting our Dao\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eCreate a new \u003cstrong\u003edatabase\u003c/strong\u003e package in \u003cstrong\u003eandroidTest\u003c/strong\u003e source directory, and create a new test class named \u003cstrong\u003eCitiesDaoTest.kt.\u003c/strong\u003e Before running our tests we need to create a new database instance and close it after:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@RunWith(AndroidJUnit4::class)\nclass CitiesDaoTest {\n    private val context = ApplicationProvider\n        .getApplicationContext\u0026lt;Context\u0026gt;()\n\n    private lateinit var database: CitiesDatabase\n\n    @Before\n    fun setup() {\n        database = Room.inMemoryDatabaseBuilder(\n            context,\n            CitiesDatabase::class.\u003cem\u003ejava\n\u003c/em\u003e        ).build()\n    }\n\n    @After\n    fun clear() {\n        database.close()\n    }\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCreate the test method:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e   \u003c/span\u003e@Test\nfun shouldStoreDataAndReturnCorrectValue() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e//given\n    val latitude = \u0026quot;1.0\u0026quot;\n    val longitude = \u0026quot;2.0\u0026quot;\n    val cityName = \u0026quot;London\u0026quot;\n    val entity = CityEntity(\n       latitude,\n       longitude,\n       cityName\n    )\n    val dao = database.citiesDao()\n\n    //when\n    dao.insertCity(entity)\n\n    //then\n    val result = dao.getCityName(latitude, longitude)\n    \u003cem\u003eassertEquals\u003c/em\u003e(cityName, result)\n\u003cstrong\u003e}\u003c/strong\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt this time we cannot compile our test yet. We need to add the necessary annotations to the methods of the \u003cstrong\u003eTranslationDao\u003c/strong\u003e class\u003cstrong\u003e:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@Dao\ninterface \u003c/span\u003eCitiesDao\u003cspan\u003e {\n\u003c/span\u003e    @Insert(onConflict = OnConflictStrategy.\u003cem\u003eREPLACE\u003c/em\u003e)\n    suspend fun insertCity(entity: CityEntity)\n\n    @Query(\u0026quot;SELECT cityName FROM cities WHERE latitude = :latitude AND longitude = :longitude LIMIT 1\u0026quot;)\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBuild and run your test again - now everything is passing.\u003c/p\u003e\u003cp\u003eWe will also need a method to detect if the translation exists in our database. Let\u0026#x27;s start with creating test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun shouldReturnTrueIfValueExists() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e//given\n    val latitude = \u0026quot;1.0\u0026quot;\n    val longitude = \u0026quot;2.0\u0026quot;\n    val cityName = \u0026quot;London\u0026quot;\n    val entity = CityEntity(\n        latitude,\n        longitude, \n        cityName\n    )\n    val dao = database.citiesDao()\n\n    //when\n    dao.insertCity(entity)\n\n    //then\n    \u003cem\u003eassertTrue\u003c/em\u003e(\n        dao.checkIfCityExists(\n            latitude,\n            longitude\n        )\n    )\n    \u003cem\u003eassertFalse\u003c/em\u003e(\n        dao.checkIfCityExists(\u0026quot;111\u0026quot;, \u0026quot;123\u0026quot;)\n    )\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo fix this test and make it compilable, add the following method to \u003cstrong\u003eCitiesDao\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Query(\u0026quot;SELECT EXISTS(SELECT cityName FROM cities WHERE latitude = :latitude AND longitude = :longitude LIMIT 1)\u0026quot;)\nfun checkIfCityExists(\n    latitude: String,\n    longitude: String\n)\u003cspan\u003e: Boolean\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun the test, it should pass now.\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"416si","text":"Testing the database","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4ic8l","text":"We will be using repository pattern, so we need a database to store any received data. Just like we didn't write any networking code apart from the Retrofit configuration, we're not going to hard code any queries but instead use Room that handles data persistence similar to how Retrofit handles networking.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":229,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"396tu","text":"Adding required dependencies","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bjofj","text":"Start with adding Room dependencies:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cuql0","text":"plugins {\n    id 'com.android.application'\n    id 'org.jetbrains.kotlin.android'\n    id 'kotlin-kapt'\n}\n\n    ...\n\ndependencies {\n    ...\n    def room_version = \"2.4.2\"\n    implementation \"androidx.room:room-ktx:$room_version\"\n    kapt \"androidx.room:room-compiler:$room_version\"\n\n    androidTestImplementation \"org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version\"\n    androidTestImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version\"\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":8,"length":1,"style":"BOLD"},{"offset":10,"length":4,"style":"BOLD"},{"offset":102,"length":1,"style":"BOLD"},{"offset":103,"length":33,"style":"CODE"},{"offset":167,"length":5,"style":"CODE"},{"offset":464,"length":1,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"8k4vf","text":"Creating Dao","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"28hc4","text":"We need class for holding data in database. Create a new package named data.local and define a class named CityEntity:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":71,"length":10,"style":"BOLD"},{"offset":107,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9evd4","text":"data class CityEntity(\n    val latitude: String,\n    val longitude: String,\n    val cityName: String\n)","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"CODE"},{"offset":27,"length":22,"style":"CODE"},{"offset":75,"length":1,"style":"CODE"},{"offset":80,"length":22,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"eovvu","text":"Then, in the same package, declare an interface named CityDao:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":54,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1mdkq","text":"interface CitiesDao {\n    suspend fun insertCity(\n        entity: CityEntity\n    )\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"CODE"},{"offset":34,"length":16,"style":"CODE"},{"offset":58,"length":19,"style":"CODE"},{"offset":81,"length":2,"style":"CODE"},{"offset":95,"length":17,"style":"CODE"},{"offset":120,"length":18,"style":"CODE"},{"offset":163,"length":1,"style":"CODE"},{"offset":168,"length":11,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"22pc1","text":"Note, that now we are partially breaking the rules of TDD because we are not creating the DAO implementation but instead we let Room generate it, and we only need to check if the configuration is correct.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":128,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5g0u6","text":"The last step before we create and compile our tests, is to create database interface and add proper annotations, to make it possible for Room to generate the implementation.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3f85e","text":"Create another class, named CitiesDatabase:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":28,"length":14,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"adtu","text":"@Database(\n    entities = [CityEntity::class],\n    version = 1\n)\n\nabstract class CitiesDatabase: RoomDatabase() {\n    abstract fun citiesDao(): CitiesDao\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":11,"style":"CODE"},{"offset":15,"length":32,"style":"CODE"},{"offset":51,"length":63,"style":"CODE"},{"offset":127,"length":28,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"16lma","text":"Add required annotations to CitiesDao and CityEntity:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":28,"length":9,"style":"BOLD"},{"offset":42,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"37qvc","text":"@Entity(tableName = \"cities\")\ndata class CityEntity(\n    val latitude: String,\n    val longitude: String,\n    val cityName: String\n) {\n    @PrimaryKey(autoGenerate = true)\n    var id: Long = 0\n}\n\n....\n\n@Dao\ninterface CitiesDao {\n ...","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":30,"style":"CODE"},{"offset":134,"length":99,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"c716d","text":"Testing our Dao","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9dkea","text":"Create a new database package in androidTest source directory, and create a new test class named CitiesDaoTest.kt. Before running our tests we need to create a new database instance and close it after:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":13,"length":8,"style":"BOLD"},{"offset":33,"length":11,"style":"BOLD"},{"offset":97,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5thjs","text":"@RunWith(AndroidJUnit4::class)\nclass CitiesDaoTest {\n    private val context = ApplicationProvider\n        .getApplicationContext\u003cContext\u003e()\n\n    private lateinit var database: CitiesDatabase\n\n    @Before\n    fun setup() {\n        database = Room.inMemoryDatabaseBuilder(\n            context,\n            CitiesDatabase::class.java\n        ).build()\n    }\n\n    @After\n    fun clear() {\n        database.close()\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":327,"length":5,"style":"ITALIC"},{"offset":416,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"a9svs","text":"Create the test method:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3ue45","text":"   @Test\nfun shouldStoreDataAndReturnCorrectValue() = runTest {\n    //given\n    val latitude = \"1.0\"\n    val longitude = \"2.0\"\n    val cityName = \"London\"\n    val entity = CityEntity(\n       latitude,\n       longitude,\n       cityName\n    )\n    val dao = database.citiesDao()\n\n    //when\n    dao.insertCity(entity)\n\n    //then\n    val result = dao.getCityName(latitude, longitude)\n    assertEquals(cityName, result)\n}\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"CODE"},{"offset":417,"length":1,"style":"CODE"},{"offset":54,"length":8,"style":"ITALIC"},{"offset":385,"length":12,"style":"ITALIC"},{"offset":62,"length":1,"style":"BOLD"},{"offset":64,"length":4,"style":"BOLD"},{"offset":416,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3sfsb","text":"At this time we cannot compile our test yet. We need to add the necessary annotations to the methods of the TranslationDao class:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":108,"length":14,"style":"BOLD"},{"offset":128,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ftt7b","text":"@Dao\ninterface CitiesDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertCity(entity: CityEntity)\n\n    @Query(\"SELECT cityName FROM cities WHERE latitude = :latitude AND longitude = :longitude LIMIT 1\")\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"CODE"},{"offset":24,"length":3,"style":"CODE"},{"offset":326,"length":2,"style":"CODE"},{"offset":71,"length":7,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"amijs","text":"Build and run your test again - now everything is passing.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1th4s","text":"We will also need a method to detect if the translation exists in our database. Let's start with creating test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aco8k","text":"@Test\nfun shouldReturnTrueIfValueExists() = runTest {\n    //given\n    val latitude = \"1.0\"\n    val longitude = \"2.0\"\n    val cityName = \"London\"\n    val entity = CityEntity(\n        latitude,\n        longitude, \n        cityName\n    )\n    val dao = database.citiesDao()\n\n    //when\n    dao.insertCity(entity)\n\n    //then\n    assertTrue(\n        dao.checkIfCityExists(\n            latitude,\n            longitude\n        )\n    )\n    assertFalse(\n        dao.checkIfCityExists(\"111\", \"123\")\n    )\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":44,"length":8,"style":"ITALIC"},{"offset":325,"length":10,"style":"ITALIC"},{"offset":432,"length":11,"style":"ITALIC"},{"offset":52,"length":1,"style":"BOLD"},{"offset":54,"length":4,"style":"BOLD"},{"offset":495,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3upqm","text":"To fix this test and make it compilable, add the following method to CitiesDao:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":69,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"aki88","text":"@Query(\"SELECT EXISTS(SELECT cityName FROM cities WHERE latitude = :latitude AND longitude = :longitude LIMIT 1)\")\nfun checkIfCityExists(\n    latitude: String,\n    longitude: String\n): Boolean","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":183,"length":9,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"evejq","text":"Run the test, it should pass now.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 4: Testing the database","body":null,"serialized_body":"\u003ch2\u003e\u003cstrong\u003eTesting the database\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWe will be using repository pattern, so we need a database to store any received data. Just like we didn\u0026#x27;t write any networking code apart from the Retrofit configuration, we\u0026#x27;re not going to hard code any queries but instead use \u003cstrong\u003eRoom\u003c/strong\u003e that handles data persistence similar to how Retrofit handles networking.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eAdding required dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eStart with adding Room dependencies:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eplugins \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eid \u0026#x27;com.android.application\u0026#x27;\n    id \u0026#x27;org.jetbrains.kotlin.android\u0026#x27;\n    id \u0026#x27;kotlin-kapt\u0026#x27;\n\u003cstrong\u003e}\u003c/strong\u003e\u003cspan\u003e\n\n    ...\n\ndependencies {\n    ...\u003c/span\u003e\n    def room_version = \u0026quot;2.4.2\u0026quot;\u003cspan\u003e\n    \u003c/span\u003eimplementation \u0026quot;androidx.room:room-ktx:$room_version\u0026quot;\n    kapt \u0026quot;androidx.room:room-compiler:$room_version\u0026quot;\n\n    androidTestImplementation \u0026quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version\u0026quot;\n    androidTestImplementation \u0026quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version\u0026quot;\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eCreating Dao\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWe need class for holding data in database. Create a new package named \u003cstrong\u003edata.local\u003c/strong\u003e and define a class named \u003cstrong\u003eCityEntity\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edata class CityEntity(\n\u003c/span\u003e    \u003cspan\u003eval latitude: String,\n\u003c/span\u003e    val longitude: String,\u003cspan\u003e\n\u003c/span\u003e    \u003cspan\u003eval cityName: String\n)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen, in the same package, declare an interface named \u003cstrong\u003eCityDao\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003einterface CitiesDao {\n\u003c/span\u003e    suspend \u003cspan\u003efun insertCity(\n\u003c/span\u003e        \u003cspan\u003eentity: CityEntity\n\u003c/span\u003e    \u003cspan\u003e)\n\u003c/span\u003e    suspend \u003cspan\u003efun getCityName(\n\u003c/span\u003e        \u003cspan\u003elatitude: String,\n\u003c/span\u003e        longitude: String\u003cspan\u003e\n\u003c/span\u003e    \u003cspan\u003e): String\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote, that now we are partially breaking the rules of TDD because we are not creating the DAO implementation but instead we let \u003cstrong\u003eRoom\u003c/strong\u003e generate it, and we only need to check if the configuration is correct.\u003c/p\u003e\u003cp\u003eThe last step before we create and compile our tests, is to create database interface and add proper annotations, to make it possible for Room to generate the implementation.\u003c/p\u003e\u003cp\u003eCreate another class, named \u003cstrong\u003eCitiesDatabase\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@Database(\n\u003c/span\u003e    \u003cspan\u003eentities = [CityEntity::class],\n\u003c/span\u003e    \u003cspan\u003eversion = 1\n)\n\nabstract class CitiesDatabase: RoomDatabase() {\n\u003c/span\u003e    abstract \u003cspan\u003efun citiesDao(): CitiesDao\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAdd required annotations to \u003cstrong\u003eCitiesDao\u003c/strong\u003e and \u003cstrong\u003eCityEntity\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@Entity(tableName = \u0026quot;cities\u0026quot;)\n\u003c/span\u003edata class CityEntity(\n    val latitude: String,\n    val longitude: String,\n    val cityName: String\n) {\u003cspan\u003e\n    @PrimaryKey(autoGenerate = true)\n    var id: Long = 0\n}\n\n....\n\n@Dao\ninterface CitiesDao {\n ...\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eTesting our Dao\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eCreate a new \u003cstrong\u003edatabase\u003c/strong\u003e package in \u003cstrong\u003eandroidTest\u003c/strong\u003e source directory, and create a new test class named \u003cstrong\u003eCitiesDaoTest.kt.\u003c/strong\u003e Before running our tests we need to create a new database instance and close it after:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@RunWith(AndroidJUnit4::class)\nclass CitiesDaoTest {\n    private val context = ApplicationProvider\n        .getApplicationContext\u0026lt;Context\u0026gt;()\n\n    private lateinit var database: CitiesDatabase\n\n    @Before\n    fun setup() {\n        database = Room.inMemoryDatabaseBuilder(\n            context,\n            CitiesDatabase::class.\u003cem\u003ejava\n\u003c/em\u003e        ).build()\n    }\n\n    @After\n    fun clear() {\n        database.close()\n    }\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCreate the test method:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e   \u003c/span\u003e@Test\nfun shouldStoreDataAndReturnCorrectValue() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e//given\n    val latitude = \u0026quot;1.0\u0026quot;\n    val longitude = \u0026quot;2.0\u0026quot;\n    val cityName = \u0026quot;London\u0026quot;\n    val entity = CityEntity(\n       latitude,\n       longitude,\n       cityName\n    )\n    val dao = database.citiesDao()\n\n    //when\n    dao.insertCity(entity)\n\n    //then\n    val result = dao.getCityName(latitude, longitude)\n    \u003cem\u003eassertEquals\u003c/em\u003e(cityName, result)\n\u003cstrong\u003e}\u003c/strong\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt this time we cannot compile our test yet. We need to add the necessary annotations to the methods of the \u003cstrong\u003eTranslationDao\u003c/strong\u003e class\u003cstrong\u003e:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e@Dao\ninterface \u003c/span\u003eCitiesDao\u003cspan\u003e {\n\u003c/span\u003e    @Insert(onConflict = OnConflictStrategy.\u003cem\u003eREPLACE\u003c/em\u003e)\n    suspend fun insertCity(entity: CityEntity)\n\n    @Query(\u0026quot;SELECT cityName FROM cities WHERE latitude = :latitude AND longitude = :longitude LIMIT 1\u0026quot;)\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBuild and run your test again - now everything is passing.\u003c/p\u003e\u003cp\u003eWe will also need a method to detect if the translation exists in our database. Let\u0026#x27;s start with creating test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun shouldReturnTrueIfValueExists() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e//given\n    val latitude = \u0026quot;1.0\u0026quot;\n    val longitude = \u0026quot;2.0\u0026quot;\n    val cityName = \u0026quot;London\u0026quot;\n    val entity = CityEntity(\n        latitude,\n        longitude, \n        cityName\n    )\n    val dao = database.citiesDao()\n\n    //when\n    dao.insertCity(entity)\n\n    //then\n    \u003cem\u003eassertTrue\u003c/em\u003e(\n        dao.checkIfCityExists(\n            latitude,\n            longitude\n        )\n    )\n    \u003cem\u003eassertFalse\u003c/em\u003e(\n        dao.checkIfCityExists(\u0026quot;111\u0026quot;, \u0026quot;123\u0026quot;)\n    )\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo fix this test and make it compilable, add the following method to \u003cstrong\u003eCitiesDao\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Query(\u0026quot;SELECT EXISTS(SELECT cityName FROM cities WHERE latitude = :latitude AND longitude = :longitude LIMIT 1)\u0026quot;)\nfun checkIfCityExists(\n    latitude: String,\n    longitude: String\n)\u003cspan\u003e: Boolean\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun the test, it should pass now.\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"416si","text":"Testing the database","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4ic8l","text":"We will be using repository pattern, so we need a database to store any received data. Just like we didn't write any networking code apart from the Retrofit configuration, we're not going to hard code any queries but instead use Room that handles data persistence similar to how Retrofit handles networking.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":229,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"396tu","text":"Adding required dependencies","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bjofj","text":"Start with adding Room dependencies:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cuql0","text":"plugins {\n    id 'com.android.application'\n    id 'org.jetbrains.kotlin.android'\n    id 'kotlin-kapt'\n}\n\n    ...\n\ndependencies {\n    ...\n    def room_version = \"2.4.2\"\n    implementation \"androidx.room:room-ktx:$room_version\"\n    kapt \"androidx.room:room-compiler:$room_version\"\n\n    androidTestImplementation \"org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version\"\n    androidTestImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutines_version\"\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":8,"length":1,"style":"BOLD"},{"offset":10,"length":4,"style":"BOLD"},{"offset":102,"length":1,"style":"BOLD"},{"offset":103,"length":33,"style":"CODE"},{"offset":167,"length":5,"style":"CODE"},{"offset":464,"length":1,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"8k4vf","text":"Creating Dao","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"28hc4","text":"We need class for holding data in database. Create a new package named data.local and define a class named CityEntity:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":71,"length":10,"style":"BOLD"},{"offset":107,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9evd4","text":"data class CityEntity(\n    val latitude: String,\n    val longitude: String,\n    val cityName: String\n)","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"CODE"},{"offset":27,"length":22,"style":"CODE"},{"offset":75,"length":1,"style":"CODE"},{"offset":80,"length":22,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"eovvu","text":"Then, in the same package, declare an interface named CityDao:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":54,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1mdkq","text":"interface CitiesDao {\n    suspend fun insertCity(\n        entity: CityEntity\n    )\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"CODE"},{"offset":34,"length":16,"style":"CODE"},{"offset":58,"length":19,"style":"CODE"},{"offset":81,"length":2,"style":"CODE"},{"offset":95,"length":17,"style":"CODE"},{"offset":120,"length":18,"style":"CODE"},{"offset":163,"length":1,"style":"CODE"},{"offset":168,"length":11,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"22pc1","text":"Note, that now we are partially breaking the rules of TDD because we are not creating the DAO implementation but instead we let Room generate it, and we only need to check if the configuration is correct.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":128,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5g0u6","text":"The last step before we create and compile our tests, is to create database interface and add proper annotations, to make it possible for Room to generate the implementation.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3f85e","text":"Create another class, named CitiesDatabase:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":28,"length":14,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"adtu","text":"@Database(\n    entities = [CityEntity::class],\n    version = 1\n)\n\nabstract class CitiesDatabase: RoomDatabase() {\n    abstract fun citiesDao(): CitiesDao\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":11,"style":"CODE"},{"offset":15,"length":32,"style":"CODE"},{"offset":51,"length":63,"style":"CODE"},{"offset":127,"length":28,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"16lma","text":"Add required annotations to CitiesDao and CityEntity:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":28,"length":9,"style":"BOLD"},{"offset":42,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"37qvc","text":"@Entity(tableName = \"cities\")\ndata class CityEntity(\n    val latitude: String,\n    val longitude: String,\n    val cityName: String\n) {\n    @PrimaryKey(autoGenerate = true)\n    var id: Long = 0\n}\n\n....\n\n@Dao\ninterface CitiesDao {\n ...","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":30,"style":"CODE"},{"offset":134,"length":99,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"c716d","text":"Testing our Dao","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9dkea","text":"Create a new database package in androidTest source directory, and create a new test class named CitiesDaoTest.kt. Before running our tests we need to create a new database instance and close it after:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":13,"length":8,"style":"BOLD"},{"offset":33,"length":11,"style":"BOLD"},{"offset":97,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5thjs","text":"@RunWith(AndroidJUnit4::class)\nclass CitiesDaoTest {\n    private val context = ApplicationProvider\n        .getApplicationContext\u003cContext\u003e()\n\n    private lateinit var database: CitiesDatabase\n\n    @Before\n    fun setup() {\n        database = Room.inMemoryDatabaseBuilder(\n            context,\n            CitiesDatabase::class.java\n        ).build()\n    }\n\n    @After\n    fun clear() {\n        database.close()\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":327,"length":5,"style":"ITALIC"},{"offset":416,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"a9svs","text":"Create the test method:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3ue45","text":"   @Test\nfun shouldStoreDataAndReturnCorrectValue() = runTest {\n    //given\n    val latitude = \"1.0\"\n    val longitude = \"2.0\"\n    val cityName = \"London\"\n    val entity = CityEntity(\n       latitude,\n       longitude,\n       cityName\n    )\n    val dao = database.citiesDao()\n\n    //when\n    dao.insertCity(entity)\n\n    //then\n    val result = dao.getCityName(latitude, longitude)\n    assertEquals(cityName, result)\n}\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"CODE"},{"offset":417,"length":1,"style":"CODE"},{"offset":54,"length":8,"style":"ITALIC"},{"offset":385,"length":12,"style":"ITALIC"},{"offset":62,"length":1,"style":"BOLD"},{"offset":64,"length":4,"style":"BOLD"},{"offset":416,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3sfsb","text":"At this time we cannot compile our test yet. We need to add the necessary annotations to the methods of the TranslationDao class:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":108,"length":14,"style":"BOLD"},{"offset":128,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ftt7b","text":"@Dao\ninterface CitiesDao {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertCity(entity: CityEntity)\n\n    @Query(\"SELECT cityName FROM cities WHERE latitude = :latitude AND longitude = :longitude LIMIT 1\")\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"CODE"},{"offset":24,"length":3,"style":"CODE"},{"offset":326,"length":2,"style":"CODE"},{"offset":71,"length":7,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"amijs","text":"Build and run your test again - now everything is passing.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1th4s","text":"We will also need a method to detect if the translation exists in our database. Let's start with creating test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aco8k","text":"@Test\nfun shouldReturnTrueIfValueExists() = runTest {\n    //given\n    val latitude = \"1.0\"\n    val longitude = \"2.0\"\n    val cityName = \"London\"\n    val entity = CityEntity(\n        latitude,\n        longitude, \n        cityName\n    )\n    val dao = database.citiesDao()\n\n    //when\n    dao.insertCity(entity)\n\n    //then\n    assertTrue(\n        dao.checkIfCityExists(\n            latitude,\n            longitude\n        )\n    )\n    assertFalse(\n        dao.checkIfCityExists(\"111\", \"123\")\n    )\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":44,"length":8,"style":"ITALIC"},{"offset":325,"length":10,"style":"ITALIC"},{"offset":432,"length":11,"style":"ITALIC"},{"offset":52,"length":1,"style":"BOLD"},{"offset":54,"length":4,"style":"BOLD"},{"offset":495,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3upqm","text":"To fix this test and make it compilable, add the following method to CitiesDao:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":69,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"aki88","text":"@Query(\"SELECT EXISTS(SELECT cityName FROM cities WHERE latitude = :latitude AND longitude = :longitude LIMIT 1)\")\nfun checkIfCityExists(\n    latitude: String,\n    longitude: String\n): Boolean","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":183,"length":9,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"evejq","text":"Run the test, it should pass now.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":2,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":784,"position":6,"new_position":6,"published_attributes":{"type":"slide","answers":[],"title":"Step 5: Creating repository","body":null,"serialized_body":"\u003cp\u003eIn this step we are going to implement a repository pattern using a pure TDD.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s start by adding dependencies to mocking libraries, which will help us simulate the responses. The two most popular are \u003cstrong\u003emockito-kotlin\u003c/strong\u003e and \u003cstrong\u003emockk. \u003c/strong\u003eThe former is a wrapper over regular \u003cstrong\u003emockito\u003c/strong\u003e library, which was designed for Java, so it doesn\u0026#x27;t cover some of Kotlin-specific features, like mocking companion objects, as well as global and extension functions. \u003cstrong\u003eMockk \u003c/strong\u003ewas designed specially for Kotlin, so it is much more flexible, offers more features and has better support for coroutines. \nHowever,  the choice of the library is up to you. The course will show implementation using both of them.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003etestImplementation \u0026#x27;org.mockito:mockito-inline:4.2.0\u0026#x27;\ntestImplementation \u0026#x27;org.mockito.kotlin:mockito-kotlin:4.0.0\u0026#x27;\ntestImplementation \u0026#x27;io.mockk:mockk:1.12.3\u0026#x27;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003emockito-inline \u003c/strong\u003edependency is also required. Without it \u003cstrong\u003eMockito\u003c/strong\u003e won\u0026#x27;t know how to mock Kotlin classes, which are final by default.\u003c/p\u003e\u003cp\u003eThen, let\u0026#x27;s create a \u003cstrong\u003eCitiesRepository\u003c/strong\u003e class in the \u003cstrong\u003edata\u003c/strong\u003e package:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepository(\n    val dao: CitiesDao,\n    val service: FindCityService\n)\u003cspan\u003e {\n    \u003c/span\u003esuspend fun getCityName(\n        latitude: String,\n        longitude: String\n    )\u003cspan\u003e = \u0026quot;\u0026quot;\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBefore we start testing we also need to create an empty test class and set it up properly. Create a \u003cstrong\u003eCitiesRepositoryTest\u003c/strong\u003e class in the \u003cstrong\u003erepository\u003c/strong\u003e package under the \u003cstrong\u003etest\u003c/strong\u003e source set.\nA setup with \u003cstrong\u003emockito-kotlin \u003c/strong\u003emay look as follows:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepositoryTest {\n    private val dao = \u003cem\u003emock\u003c/em\u003e\u0026lt;CitiesDao\u0026gt;()\n    private val service = \u003cem\u003emock\u003c/em\u003e\u0026lt;FindCityService\u0026gt;()\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd with \u003cstrong\u003emockk\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepositoryTest {\n    private val dao = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CitiesDao\u0026gt;()\n    private val service = \u003cem\u003emockk\u003c/em\u003e\u0026lt;FindCityService\u0026gt;()\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eTesting our repository\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eOk, now we can start testing the repository. Let\u0026#x27;s create a test for fetching data from the internet and returning it.\u003c/p\u003e\u003cp\u003eFirst, let\u0026#x27;s set the mock response:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate val latitude = \u0026quot;1.0\u0026quot;\nprivate val longitude = \u0026quot;2.0\u0026quot;\nprivate val cityName = \u0026quot;London\u0026quot;\nprivate val cityInfo = \u003cem\u003emock\u003c/em\u003e\u0026lt;CityInfo\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eon \u003cstrong\u003e{ \u003c/strong\u003eadminDistrict \u003cstrong\u003e} \u003c/strong\u003e\u003cem\u003edoReturn \u003c/em\u003ecityName\n\u003cstrong\u003e}\u003c/strong\u003e\nprivate val response = \u003cem\u003emock\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eon \u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003e\u003cem\u003edoReturn listOf\u003c/em\u003e(cityInfo)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd for\u003cstrong\u003e mockk:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate val latitude = \u0026quot;1.0\u0026quot;\nprivate val longitude = \u0026quot;2.0\u0026quot;\nprivate val cityName = \u0026quot;London\u0026quot;\nprivate val cityInfo = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityInfo\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eadminDistrict \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n\u003cstrong\u003e}\u003c/strong\u003e\nprivate val response = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003elistOf\u003c/em\u003e(cityInfo)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, the test itself:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e   \u003c/span\u003e@Test\nfun `calling getCity should call findCity endpoint`() =\n    \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e    // given\n        \u003cem\u003ewhenever\u003c/em\u003e(\n            service.findCity(latitude, longitude)\n        ) \u003cem\u003edoReturn \u003c/em\u003eresponse\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003everify\u003c/em\u003e(service).findCity(latitude, longitude)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe same test in \u003cstrong\u003emockk \u003c/strong\u003elooks as follows:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should call findCity endpoint`()= \n    \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e    // given\n        \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{\n \u003c/strong\u003e           service.findCity(latitude, longitude)\n        \u003cstrong\u003e} \u003c/strong\u003ereturns response\n\u003cstrong\u003e    \u003c/strong\u003e    val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003ecoVerify \u003c/em\u003e\u003cstrong\u003e{\n\u003c/strong\u003e            service.findCity(latitude, longitude)\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see, tests using both libraries look very similar, only syntax is as bit different. \n\u003cstrong\u003eMockk\u003c/strong\u003e adds \u003cstrong\u003e\u003cem\u003eco-\u003c/em\u003e\u003c/strong\u003e prefix to the methods that call suspend functions inside, because they must be called only from the other coroutine body. So for example, instead of normal \u003cstrong\u003everify\u003c/strong\u003e block, we use, \u003cstrong\u003ecoVerify\u003c/strong\u003e which stands for \u003cstrong\u003ecoroutineVerify\u003c/strong\u003e. The same applies to \u003cstrong\u003eevery\u003c/strong\u003e and \u003cstrong\u003ecoEvery\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eBuild and run the test. It should fail. Now we are going to fix it.\u003c/p\u003e\u003cp\u003eGo back to the repository class and implement the feature to make the test pass:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepository(\n    val dao: CitiesDao,\n    val service: FindCityService\n) {\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String? = service.findCity(\n          latitude,\n          longitude\n        ).result.\u003cem\u003efirstOrNull\u003c/em\u003e()\n            ?.adminDistrict\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun your test again. It should pass. But it is not the end. The next thing to test is whether the returned value is being stored in database.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should store response city in database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ewhenever\u003c/em\u003e(\n        service.findCity(latitude, longitude)\n    ) \u003cem\u003edoReturn \u003c/em\u003eresponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    val captor = \u003cem\u003eargumentCaptor\u003c/em\u003e\u0026lt;CityEntity\u0026gt;()\n    \u003cem\u003everify\u003c/em\u003e(dao.insertCity(captor.capture()))\n        \n    val entity = captor.firstValue\n    \u003cem\u003eassertEquals\u003c/em\u003e(cityName, entity.cityName)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003eargumentCaptor \u003c/strong\u003eallows us to store the argument passed to the \u003cstrong\u003einsertCity \u003c/strong\u003emethod invoked in the repository and then do assertions based on the stored value.\nIn \u003cstrong\u003emockk\u003c/strong\u003e we don\u0026#x27;t need this captor object, we can do it more simple: \u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should store response city in database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003ereturns response\n    \u003cem\u003ecoJustRun \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003ecoVerify \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003edao.insertCity(\n            withArg \u003cstrong\u003e{ \u003c/strong\u003eentity \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e                \u003c/strong\u003e\u003cem\u003eassertEquals\u003c/em\u003e(cityName, entity.cityName)\n            \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e)\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eInside the \u003cstrong\u003ewithArg\u003c/strong\u003e function we have access to the argument passed to the \u003cstrong\u003einsertCity\u003c/strong\u003e method.\nWe also need to add \u003cstrong\u003ecoJustRun\u003c/strong\u003e function to mock the invocation to that method. Without it, \u003cstrong\u003emockk\u003c/strong\u003e would throw an exception saying that no answer was found. \nWe also use \u003cstrong\u003eany()\u003c/strong\u003e matcher there which means, that this mock should be valid for any argument value, unlike the mock above which explicitly sets the mock to work only for a given latitude and longitude.\n\nRemember to also add this line to the previous test, otherwise it will start to fail once the \u003cstrong\u003edao\u003c/strong\u003e interaction was added to the feature implementation.\n\nWe can also achieve the same behaviour, by just adding \u003cstrong\u003erelaxed\u003c/strong\u003e parameter to the mock definition. Then we don\u0026#x27;t need this \u003cstrong\u003ejustRun\u003c/strong\u003e at all. \u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eval dao = mockk\u0026lt;CitiesDao\u0026gt;(relaxed = true)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt this point those tests should fail. To fix it, go back to the repository class and implement the feature.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003esuspend fun getCityName(\n    latitude: String,\n    longitude: String\n) = service.findCity(latitude, longitude)\n        .result.\u003cem\u003efirstOrNull\u003c/em\u003e()\n        ?.adminDistrict\n        ?.\u003cem\u003ealso \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003ecityName \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003edao.insertCity(\n                CityEntity(\n                    latitude, \n                    longitude, \n                    cityName\n                )\n            )\n        \u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe test should pass now, but there is an additional scenario we should test - when the list is empty and the null-safe calls are not invoked. In this scenario the \u003cstrong\u003einsertCity\u003c/strong\u003e should not be invoked at all.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should not store response city in database when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    val emptyResponse = \u003cem\u003emock\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eon \u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003e\u003cem\u003edoReturn emptyList\u003c/em\u003e()\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ewhenever\u003c/em\u003e(\n        service.findCity(latitude, longitude)\n    ) \u003cem\u003edoReturn \u003c/em\u003eemptyResponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003everify\u003c/em\u003e(dao, \u003cem\u003enever\u003c/em\u003e()).insertCity(\u003cem\u003eany\u003c/em\u003e())\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003enever()\u003c/strong\u003e is a verification mode which says that we are checking that this method was not called at all during the test.\u003c/p\u003e\u003cp\u003eIn \u003cstrong\u003emockk\u003c/strong\u003e it\u0026#x27;s even shorter:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should not store response city in database when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    val emptyResponse = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003eemptyList\u003c/em\u003e()\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003ecoVerify\u003c/em\u003e(exactly = 0) \u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow run all repository tests. All of them should pass.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eAdding more tests\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWe are still testing our repository. Now we need to test, if the repository is returning a result from the database. \nFrom now on, the course will show only \u003cstrong\u003emockk\u003c/strong\u003e code.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should return proper city name`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns response\n    \u003cem\u003ecoJustRun \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    val result = repository.getCityName(\n        latitude,\n        longitude\n    )\n\n    // then\n    \u003cem\u003eassertEquals\u003c/em\u003e(cityName, result)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe next step will be checking that in case of an empty response list, we receive a null value:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should return null when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    val emptyResponse = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003eemptyList\u003c/em\u003e()\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003ereturns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    val result = repository\n        .getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003eassertNull\u003c/em\u003e(result)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn case of some network error, the code in the repository will throw an exception, because that\u0026#x27;s the way coroutines signal errors in execution. \nLet\u0026#x27;s verify this behaviour:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test(expected = RuntimeException::class)\nfun `calling getCity should throw exception when request fails`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003eanswers \u003cstrong\u003e{ \u003c/strong\u003ethrow RuntimeException() \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then \n    // exception\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time we are using \u003cstrong\u003eanswers\u003c/strong\u003e instead of \u003cstrong\u003ereturns\u003c/strong\u003e, in order to throw the exception inside the lambda. Also, we need to add an expected exception class to the \u003cstrong\u003e@Test\u003c/strong\u003e annotation. \nAs you can see, there\u0026#x27;s no assertion at the end of the test, because the \u003cstrong\u003eexpected\u003c/strong\u003e parameter in the annotation took its job.\u003c/p\u003e\u003cp\u003e\nThe last step is to ensure that we are not calling our service when a given city is already stored in the database. Start with creating a test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should not call api when there is a value in the database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns response\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        dao.checkIfCityExists(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns true\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        dao.getCityName(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n    \u003cem\u003ecoJustRun \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003everify \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eservice \u003cem\u003ewasNot \u003c/em\u003ecalled \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003ewasNot called\u003c/strong\u003e expression is a part of \u003cstrong\u003emockk\u003c/strong\u003e DSL for checking if there were no interactions with a given object.\n\nNext, implement the feature to make it pass:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003esuspend fun getCityName(\n    latitude: String,\n    longitude: String\n) =\n    if (dao.checkIfCityExists(latitude, longitude)) {\n        dao.getCityName(latitude, longitude)\n    } else {\n        service.findCity(latitude, longitude)\n            .result.\u003cem\u003efirstOrNull\u003c/em\u003e()\n            ?.adminDistrict\n            ?.\u003cem\u003ealso \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003ecityName \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e                \u003c/strong\u003edao.insertCity(\n                    CityEntity(\n                        latitude,\n                        longitude, \n                        cityName\n                    )\n                )\n            \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun all tests for the repository. You should notice that this test is passing, but all others are failing now. \nAdd a mock response for \u003cstrong\u003echeckIfCityExists\u003c/strong\u003e to them method to make them pass again.\nAs you can see, the number of \u003cstrong\u003eevery\u003c/strong\u003e invocations is increasing together with the implementation complexity. It\u0026#x27;s worth considering adding a default response to the mocked methods during the mock declaration (just like with the \u003cstrong\u003eresponse\u003c/strong\u003e mock) to avoid writing them in every single test.\u003c/p\u003e\u003cp\u003eYou can reference the full test class below with the mentioned adjustments below:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepositoryTest {\n    private val latitude = \u0026quot;1.0\u0026quot;\n    private val longitude = \u0026quot;2.0\u0026quot;\n    private val cityName = \u0026quot;London\u0026quot;\n    private val cityInfo = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityInfo\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eadminDistrict \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eprivate val response = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003elistOf\u003c/em\u003e(cityInfo)\n    \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eprivate val dao = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CitiesDao\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n        \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003einsertCity(any()) \u003cstrong\u003e} \u003c/strong\u003e\u003cem\u003ejust \u003c/em\u003eruns\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            getCityName(latitude, longitude)\n        \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n        \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            checkIfCityExists(latitude, longitude) \n        \u003cstrong\u003e} \u003c/strong\u003ereturns false\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eprivate val service = \u003cem\u003emockk\u003c/em\u003e\u0026lt;FindCityService\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            findCity(latitude, longitude) \n        \u003cstrong\u003e} \u003c/strong\u003ereturns response\n    \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should call api`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003ecoVerify \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            service.findCity(latitude, longitude) \n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should store response city in database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003ecoVerify \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003edao.insertCity(\n                withArg \u003cstrong\u003e{ \u003c/strong\u003eentity \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e                    \u003c/strong\u003e\u003cem\u003eassertEquals\u003c/em\u003e(\n                        cityName,\n                        entity.cityName\n                    )\n                \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e)\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should not store response city in database when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        val emptyResponse = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003eemptyList\u003c/em\u003e()\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            service.findCity(latitude, longitude) \n        \u003cstrong\u003e} \u003c/strong\u003ereturns emptyResponse\n\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003ecoVerify\u003c/em\u003e(exactly = 0) \u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should return proper city name`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        val repository = createRepository()\n\n        // when\n        val result = repository.getCityName(\n            latitude,\n            longitude\n        )\n\n        // then\n        \u003cem\u003eassertEquals\u003c/em\u003e(cityName, result)\n    \u003cstrong\u003e}\n\n\u003c/strong\u003e    @Test\nfun `calling getCity should return null when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    val emptyResponse = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003eemptyList\u003c/em\u003e()\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003ereturns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    val result = repository\n        .getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003eassertNull\u003c/em\u003e(result)\n\u003cstrong\u003e}\u003c/strong\u003e\n\n@Test(expected = RuntimeException::class)\nfun `calling getCity should throw exception when request fails`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003eanswers \u003cstrong\u003e{ \u003c/strong\u003ethrow RuntimeException() \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    // exception\n\u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should not call api when there is a value in the database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            dao.checkIfCityExists(\n                latitude,\n                longitude\n            )\n        \u003cstrong\u003e} \u003c/strong\u003ereturns true\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003everify \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eservice \u003cem\u003ewasNot \u003c/em\u003ecalled \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eprivate fun createRepository() =\n        CitiesRepository(dao, service)\n}\u003c/code\u003e\u003c/pre\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"915f3","text":"In this step we are going to implement a repository pattern using a pure TDD.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bg5ah","text":"Let's start by adding dependencies to mocking libraries, which will help us simulate the responses. The two most popular are mockito-kotlin and mockk. The former is a wrapper over regular mockito library, which was designed for Java, so it doesn't cover some of Kotlin-specific features, like mocking companion objects, as well as global and extension functions. Mockk was designed specially for Kotlin, so it is much more flexible, offers more features and has better support for coroutines. \nHowever,  the choice of the library is up to you. The course will show implementation using both of them.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":125,"length":14,"style":"BOLD"},{"offset":144,"length":7,"style":"BOLD"},{"offset":188,"length":7,"style":"BOLD"},{"offset":363,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"euj9n","text":"testImplementation 'org.mockito:mockito-inline:4.2.0'\ntestImplementation 'org.mockito.kotlin:mockito-kotlin:4.0.0'\ntestImplementation 'io.mockk:mockk:1.12.3'","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8hsti","text":"The mockito-inline dependency is also required. Without it Mockito won't know how to mock Kotlin classes, which are final by default.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":15,"style":"BOLD"},{"offset":59,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"frvji","text":"Then, let's create a CitiesRepository class in the data package:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":21,"length":16,"style":"BOLD"},{"offset":51,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9h4uj","text":"class CitiesRepository(\n    val dao: CitiesDao,\n    val service: FindCityService\n) {\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ) = \"\"\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":82,"length":7,"style":"CODE"},{"offset":171,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"ek4m9","text":"Before we start testing we also need to create an empty test class and set it up properly. Create a CitiesRepositoryTest class in the repository package under the test source set.\nA setup with mockito-kotlin may look as follows:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":100,"length":20,"style":"BOLD"},{"offset":134,"length":10,"style":"BOLD"},{"offset":163,"length":4,"style":"BOLD"},{"offset":193,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ennjb","text":"class CitiesRepositoryTest {\n    private val dao = mock\u003cCitiesDao\u003e()\n    private val service = mock\u003cFindCityService\u003e()\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":51,"length":4,"style":"ITALIC"},{"offset":95,"length":4,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"2cr92","text":"And with mockk:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":9,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a40ck","text":"class CitiesRepositoryTest {\n    private val dao = mockk\u003cCitiesDao\u003e()\n    private val service = mockk\u003cFindCityService\u003e()\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":51,"length":5,"style":"ITALIC"},{"offset":96,"length":5,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"1uujj","text":"Testing our repository","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9qff8","text":"Ok, now we can start testing the repository. Let's create a test for fetching data from the internet and returning it.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5bblv","text":"First, let's set the mock response:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5nce9","text":"private val latitude = \"1.0\"\nprivate val longitude = \"2.0\"\nprivate val cityName = \"London\"\nprivate val cityInfo = mock\u003cCityInfo\u003e {\n    on { adminDistrict } doReturn cityName\n}\nprivate val response = mock\u003cCityResponse\u003e {\n    on { result } doReturn listOf(cityInfo)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":114,"length":4,"style":"ITALIC"},{"offset":156,"length":9,"style":"ITALIC"},{"offset":199,"length":4,"style":"ITALIC"},{"offset":238,"length":15,"style":"ITALIC"},{"offset":129,"length":1,"style":"BOLD"},{"offset":131,"length":4,"style":"BOLD"},{"offset":138,"length":2,"style":"BOLD"},{"offset":154,"length":2,"style":"BOLD"},{"offset":174,"length":1,"style":"BOLD"},{"offset":218,"length":1,"style":"BOLD"},{"offset":220,"length":4,"style":"BOLD"},{"offset":227,"length":2,"style":"BOLD"},{"offset":236,"length":2,"style":"BOLD"},{"offset":264,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dvnl1","text":"And for mockk:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":7,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"60f01","text":"private val latitude = \"1.0\"\nprivate val longitude = \"2.0\"\nprivate val cityName = \"London\"\nprivate val cityInfo = mockk\u003cCityInfo\u003e {\n    every { adminDistrict } returns cityName\n}\nprivate val response = mockk\u003cCityResponse\u003e {\n    every { result } returns listOf(cityInfo)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":114,"length":5,"style":"ITALIC"},{"offset":136,"length":6,"style":"ITALIC"},{"offset":202,"length":5,"style":"ITALIC"},{"offset":228,"length":6,"style":"ITALIC"},{"offset":253,"length":6,"style":"ITALIC"},{"offset":130,"length":1,"style":"BOLD"},{"offset":132,"length":4,"style":"BOLD"},{"offset":142,"length":2,"style":"BOLD"},{"offset":158,"length":2,"style":"BOLD"},{"offset":177,"length":1,"style":"BOLD"},{"offset":222,"length":1,"style":"BOLD"},{"offset":224,"length":4,"style":"BOLD"},{"offset":234,"length":2,"style":"BOLD"},{"offset":243,"length":2,"style":"BOLD"},{"offset":270,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"brpt5","text":"Now, the test itself:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3dqrl","text":"   @Test\nfun `calling getCity should call findCity endpoint`() =\n    runTest {\n        // given\n        whenever(\n            service.findCity(latitude, longitude)\n        ) doReturn response\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        verify(service).findCity(latitude, longitude)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"CODE"},{"offset":69,"length":8,"style":"ITALIC"},{"offset":104,"length":8,"style":"ITALIC"},{"offset":174,"length":9,"style":"ITALIC"},{"offset":330,"length":6,"style":"ITALIC"},{"offset":77,"length":1,"style":"BOLD"},{"offset":79,"length":4,"style":"BOLD"},{"offset":376,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2fuuj","text":"The same test in mockk looks as follows:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":17,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ccjpk","text":"@Test\nfun `calling getCity should call findCity endpoint`()= \n    runTest {\n        // given\n        coEvery {\n            service.findCity(latitude, longitude)\n        } returns response\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        coVerify {\n            service.findCity(latitude, longitude)\n        }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":66,"length":8,"style":"ITALIC"},{"offset":101,"length":8,"style":"ITALIC"},{"offset":326,"length":9,"style":"ITALIC"},{"offset":74,"length":1,"style":"BOLD"},{"offset":76,"length":4,"style":"BOLD"},{"offset":109,"length":3,"style":"BOLD"},{"offset":169,"length":2,"style":"BOLD"},{"offset":188,"length":4,"style":"BOLD"},{"offset":335,"length":2,"style":"BOLD"},{"offset":395,"length":1,"style":"BOLD"},{"offset":397,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5seub","text":"As you can see, tests using both libraries look very similar, only syntax is as bit different. \nMockk adds co- prefix to the methods that call suspend functions inside, because they must be called only from the other coroutine body. So for example, instead of normal verify block, we use, coVerify which stands for coroutineVerify. The same applies to every and coEvery.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":96,"length":5,"style":"BOLD"},{"offset":107,"length":3,"style":"BOLD"},{"offset":267,"length":6,"style":"BOLD"},{"offset":289,"length":8,"style":"BOLD"},{"offset":315,"length":15,"style":"BOLD"},{"offset":352,"length":5,"style":"BOLD"},{"offset":362,"length":7,"style":"BOLD"},{"offset":107,"length":3,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"b6mfc","text":"Build and run the test. It should fail. Now we are going to fix it.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1mmc8","text":"Go back to the repository class and implement the feature to make the test pass:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aj920","text":"class CitiesRepository(\n    val dao: CitiesDao,\n    val service: FindCityService\n) {\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String? = service.findCity(\n          latitude,\n          longitude\n        ).result.firstOrNull()\n            ?.adminDistrict\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":258,"length":11,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"4eb3f","text":"Run your test again. It should pass. But it is not the end. The next thing to test is whether the returned value is being stored in database.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9h9le","text":"@Test\nfun `calling getCity should store response city in database`() = runTest {\n    // given\n    whenever(\n        service.findCity(latitude, longitude)\n    ) doReturn response\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    val captor = argumentCaptor\u003cCityEntity\u003e()\n    verify(dao.insertCity(captor.capture()))\n        \n    val entity = captor.firstValue\n    assertEquals(cityName, entity.cityName)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":71,"length":8,"style":"ITALIC"},{"offset":98,"length":8,"style":"ITALIC"},{"offset":160,"length":9,"style":"ITALIC"},{"offset":310,"length":14,"style":"ITALIC"},{"offset":343,"length":6,"style":"ITALIC"},{"offset":432,"length":12,"style":"ITALIC"},{"offset":79,"length":1,"style":"BOLD"},{"offset":81,"length":4,"style":"BOLD"},{"offset":472,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dg8u4","text":"The argumentCaptor allows us to store the argument passed to the insertCity method invoked in the repository and then do assertions based on the stored value.\nIn mockk we don't need this captor object, we can do it more simple: ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":15,"style":"BOLD"},{"offset":65,"length":11,"style":"BOLD"},{"offset":162,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fnjk3","text":"@Test\nfun `calling getCity should store response city in database`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude) \n    } returns response\n    coJustRun { dao.insertCity(any()) }\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    coVerify {\n        dao.insertCity(\n            withArg { entity -\u003e\n                assertEquals(cityName, entity.cityName)\n            }\n        )\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":71,"length":8,"style":"ITALIC"},{"offset":98,"length":8,"style":"ITALIC"},{"offset":183,"length":10,"style":"ITALIC"},{"offset":338,"length":9,"style":"ITALIC"},{"offset":421,"length":12,"style":"ITALIC"},{"offset":79,"length":1,"style":"BOLD"},{"offset":81,"length":4,"style":"BOLD"},{"offset":106,"length":3,"style":"BOLD"},{"offset":160,"length":2,"style":"BOLD"},{"offset":193,"length":2,"style":"BOLD"},{"offset":217,"length":1,"style":"BOLD"},{"offset":220,"length":4,"style":"BOLD"},{"offset":347,"length":1,"style":"BOLD"},{"offset":349,"length":8,"style":"BOLD"},{"offset":393,"length":2,"style":"BOLD"},{"offset":402,"length":2,"style":"BOLD"},{"offset":405,"length":16,"style":"BOLD"},{"offset":473,"length":1,"style":"BOLD"},{"offset":475,"length":8,"style":"BOLD"},{"offset":489,"length":1,"style":"BOLD"},{"offset":491,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3ormh","text":"Inside the withArg function we have access to the argument passed to the insertCity method.\nWe also need to add coJustRun function to mock the invocation to that method. Without it, mockk would throw an exception saying that no answer was found. \nWe also use any() matcher there which means, that this mock should be valid for any argument value, unlike the mock above which explicitly sets the mock to work only for a given latitude and longitude.\n\nRemember to also add this line to the previous test, otherwise it will start to fail once the dao interaction was added to the feature implementation.\n\nWe can also achieve the same behaviour, by just adding relaxed parameter to the mock definition. Then we don't need this justRun at all. ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":11,"length":7,"style":"BOLD"},{"offset":73,"length":10,"style":"BOLD"},{"offset":112,"length":9,"style":"BOLD"},{"offset":182,"length":5,"style":"BOLD"},{"offset":259,"length":5,"style":"BOLD"},{"offset":544,"length":3,"style":"BOLD"},{"offset":657,"length":7,"style":"BOLD"},{"offset":723,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bvi0","text":"val dao = mockk\u003cCitiesDao\u003e(relaxed = true)","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"af2b6","text":"At this point those tests should fail. To fix it, go back to the repository class and implement the feature.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9jimb","text":"suspend fun getCityName(\n    latitude: String,\n    longitude: String\n) = service.findCity(latitude, longitude)\n        .result.firstOrNull()\n        ?.adminDistrict\n        ?.also { cityName -\u003e\n            dao.insertCity(\n                CityEntity(\n                    latitude, \n                    longitude, \n                    cityName\n                )\n            )\n        }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":127,"length":11,"style":"ITALIC"},{"offset":175,"length":5,"style":"ITALIC"},{"offset":180,"length":2,"style":"BOLD"},{"offset":191,"length":2,"style":"BOLD"},{"offset":194,"length":12,"style":"BOLD"},{"offset":382,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1gfe6","text":"The test should pass now, but there is an additional scenario we should test - when the list is empty and the null-safe calls are not invoked. In this scenario the insertCity should not be invoked at all.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":164,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fndv2","text":"@Test\nfun `calling getCity should not store response city in database when result list is empty`() = runTest {\n    // given\n    val emptyResponse = mock\u003cCityResponse\u003e {\n        on { result } doReturn emptyList()\n    }\n    whenever(\n        service.findCity(latitude, longitude)\n    ) doReturn emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    verify(dao, never()).insertCity(any())\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":101,"length":8,"style":"ITALIC"},{"offset":148,"length":4,"style":"ITALIC"},{"offset":191,"length":18,"style":"ITALIC"},{"offset":222,"length":8,"style":"ITALIC"},{"offset":284,"length":9,"style":"ITALIC"},{"offset":426,"length":6,"style":"ITALIC"},{"offset":438,"length":5,"style":"ITALIC"},{"offset":458,"length":3,"style":"ITALIC"},{"offset":109,"length":1,"style":"BOLD"},{"offset":111,"length":4,"style":"BOLD"},{"offset":167,"length":1,"style":"BOLD"},{"offset":169,"length":8,"style":"BOLD"},{"offset":180,"length":2,"style":"BOLD"},{"offset":189,"length":2,"style":"BOLD"},{"offset":216,"length":1,"style":"BOLD"},{"offset":218,"length":4,"style":"BOLD"},{"offset":465,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ea3q0","text":"never() is a verification mode which says that we are checking that this method was not called at all during the test.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6c4dn","text":"In mockk it's even shorter:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":3,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"f3p4k","text":"@Test\nfun `calling getCity should not store response city in database when result list is empty`() = runTest {\n    // given\n    val emptyResponse = mockk\u003cCityResponse\u003e {\n        every { result } returns emptyList()\n    }\n    coEvery { \n        service.findCity(latitude, longitude)\n    } returns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    coVerify(exactly = 0) { dao.insertCity(any()) }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":101,"length":8,"style":"ITALIC"},{"offset":148,"length":5,"style":"ITALIC"},{"offset":178,"length":6,"style":"ITALIC"},{"offset":203,"length":9,"style":"ITALIC"},{"offset":225,"length":8,"style":"ITALIC"},{"offset":429,"length":8,"style":"ITALIC"},{"offset":109,"length":1,"style":"BOLD"},{"offset":111,"length":4,"style":"BOLD"},{"offset":168,"length":1,"style":"BOLD"},{"offset":170,"length":8,"style":"BOLD"},{"offset":184,"length":2,"style":"BOLD"},{"offset":193,"length":2,"style":"BOLD"},{"offset":219,"length":1,"style":"BOLD"},{"offset":221,"length":4,"style":"BOLD"},{"offset":233,"length":3,"style":"BOLD"},{"offset":286,"length":2,"style":"BOLD"},{"offset":451,"length":2,"style":"BOLD"},{"offset":475,"length":1,"style":"BOLD"},{"offset":477,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bj0lk","text":"Now run all repository tests. All of them should pass.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3sbts","text":"Adding more tests","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ebsvu","text":"We are still testing our repository. Now we need to test, if the repository is returning a result from the database. \nFrom now on, the course will show only mockk code.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":157,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ccd0d","text":"@Test\nfun `calling getCity should return proper city name`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude)\n    } returns response\n    coJustRun { dao.insertCity(any()) }\n\n    val repository = createRepository()\n\n    // when\n    val result = repository.getCityName(\n        latitude,\n        longitude\n    )\n\n    // then\n    assertEquals(cityName, result)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":63,"length":8,"style":"ITALIC"},{"offset":90,"length":8,"style":"ITALIC"},{"offset":174,"length":10,"style":"ITALIC"},{"offset":364,"length":12,"style":"ITALIC"},{"offset":71,"length":1,"style":"BOLD"},{"offset":73,"length":4,"style":"BOLD"},{"offset":98,"length":3,"style":"BOLD"},{"offset":151,"length":2,"style":"BOLD"},{"offset":184,"length":2,"style":"BOLD"},{"offset":208,"length":1,"style":"BOLD"},{"offset":211,"length":4,"style":"BOLD"},{"offset":395,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a7q35","text":"The next step will be checking that in case of an empty response list, we receive a null value:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ae32t","text":"@Test\nfun `calling getCity should return null when result list is empty`() = runTest {\n    // given\n    val emptyResponse = mockk\u003cCityResponse\u003e {\n        every { result } returns emptyList()\n    }\n    coEvery { \n        service.findCity(latitude, longitude) \n    } returns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    val result = repository\n        .getCityName(latitude, longitude)\n\n    // then\n    assertNull(result)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":77,"length":8,"style":"ITALIC"},{"offset":124,"length":5,"style":"ITALIC"},{"offset":154,"length":6,"style":"ITALIC"},{"offset":179,"length":9,"style":"ITALIC"},{"offset":201,"length":8,"style":"ITALIC"},{"offset":428,"length":10,"style":"ITALIC"},{"offset":85,"length":1,"style":"BOLD"},{"offset":87,"length":4,"style":"BOLD"},{"offset":144,"length":1,"style":"BOLD"},{"offset":146,"length":8,"style":"BOLD"},{"offset":160,"length":2,"style":"BOLD"},{"offset":169,"length":2,"style":"BOLD"},{"offset":195,"length":1,"style":"BOLD"},{"offset":197,"length":4,"style":"BOLD"},{"offset":209,"length":3,"style":"BOLD"},{"offset":263,"length":2,"style":"BOLD"},{"offset":447,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"du416","text":"In case of some network error, the code in the repository will throw an exception, because that's the way coroutines signal errors in execution. \nLet's verify this behaviour:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5civj","text":"@Test(expected = RuntimeException::class)\nfun `calling getCity should throw exception when request fails`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude) \n    } answers { throw RuntimeException() }\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then \n    // exception\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":110,"length":8,"style":"ITALIC"},{"offset":137,"length":8,"style":"ITALIC"},{"offset":118,"length":1,"style":"BOLD"},{"offset":120,"length":4,"style":"BOLD"},{"offset":145,"length":3,"style":"BOLD"},{"offset":199,"length":2,"style":"BOLD"},{"offset":209,"length":2,"style":"BOLD"},{"offset":236,"length":1,"style":"BOLD"},{"offset":239,"length":4,"style":"BOLD"},{"offset":371,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1ceh4","text":"This time we are using answers instead of returns, in order to throw the exception inside the lambda. Also, we need to add an expected exception class to the @Test annotation. \nAs you can see, there's no assertion at the end of the test, because the expected parameter in the annotation took its job.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":23,"length":7,"style":"BOLD"},{"offset":42,"length":7,"style":"BOLD"},{"offset":158,"length":5,"style":"BOLD"},{"offset":250,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bteve","text":"\nThe last step is to ensure that we are not calling our service when a given city is already stored in the database. Start with creating a test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6tf2r","text":"@Test\nfun `calling getCity should not call api when there is a value in the database`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude)\n    } returns response\n    coEvery { \n        dao.checkIfCityExists(latitude, longitude)\n    } returns true\n    coEvery { \n        dao.getCityName(latitude, longitude)\n    } returns cityName\n    coJustRun { dao.insertCity(any()) }\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    verify { service wasNot called }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":90,"length":8,"style":"ITALIC"},{"offset":117,"length":8,"style":"ITALIC"},{"offset":201,"length":8,"style":"ITALIC"},{"offset":286,"length":8,"style":"ITALIC"},{"offset":369,"length":10,"style":"ITALIC"},{"offset":524,"length":7,"style":"ITALIC"},{"offset":541,"length":7,"style":"ITALIC"},{"offset":98,"length":1,"style":"BOLD"},{"offset":100,"length":4,"style":"BOLD"},{"offset":125,"length":3,"style":"BOLD"},{"offset":178,"length":2,"style":"BOLD"},{"offset":209,"length":3,"style":"BOLD"},{"offset":267,"length":2,"style":"BOLD"},{"offset":294,"length":3,"style":"BOLD"},{"offset":346,"length":2,"style":"BOLD"},{"offset":379,"length":2,"style":"BOLD"},{"offset":403,"length":1,"style":"BOLD"},{"offset":406,"length":4,"style":"BOLD"},{"offset":531,"length":2,"style":"BOLD"},{"offset":555,"length":1,"style":"BOLD"},{"offset":557,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ftrj2","text":"The wasNot called expression is a part of mockk DSL for checking if there were no interactions with a given object.\n\nNext, implement the feature to make it pass:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":13,"style":"BOLD"},{"offset":42,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2ds03","text":"suspend fun getCityName(\n    latitude: String,\n    longitude: String\n) =\n    if (dao.checkIfCityExists(latitude, longitude)) {\n        dao.getCityName(latitude, longitude)\n    } else {\n        service.findCity(latitude, longitude)\n            .result.firstOrNull()\n            ?.adminDistrict\n            ?.also { cityName -\u003e\n                dao.insertCity(\n                    CityEntity(\n                        latitude,\n                        longitude, \n                        cityName\n                    )\n                )\n            }\n    }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":251,"length":11,"style":"ITALIC"},{"offset":307,"length":5,"style":"ITALIC"},{"offset":312,"length":2,"style":"BOLD"},{"offset":323,"length":2,"style":"BOLD"},{"offset":326,"length":16,"style":"BOLD"},{"offset":545,"length":1,"style":"BOLD"},{"offset":547,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"d2ns6","text":"Run all tests for the repository. You should notice that this test is passing, but all others are failing now. \nAdd a mock response for checkIfCityExists to them method to make them pass again.\nAs you can see, the number of every invocations is increasing together with the implementation complexity. It's worth considering adding a default response to the mocked methods during the mock declaration (just like with the response mock) to avoid writing them in every single test.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":136,"length":17,"style":"BOLD"},{"offset":224,"length":5,"style":"BOLD"},{"offset":420,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3o3nk","text":"You can reference the full test class below with the mentioned adjustments below:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"blcqg","text":"class CitiesRepositoryTest {\n    private val latitude = \"1.0\"\n    private val longitude = \"2.0\"\n    private val cityName = \"London\"\n    private val cityInfo = mockk\u003cCityInfo\u003e {\n        every { adminDistrict } returns cityName\n    }\n    private val response = mockk\u003cCityResponse\u003e {\n        every { result } returns listOf(cityInfo)\n    }\n\n    private val dao = mockk\u003cCitiesDao\u003e {\n        coEvery { insertCity(any()) } just runs\n        coEvery { \n            getCityName(latitude, longitude)\n        } returns cityName\n        coEvery { \n            checkIfCityExists(latitude, longitude) \n        } returns false\n    }\n    private val service = mockk\u003cFindCityService\u003e {\n        coEvery { \n            findCity(latitude, longitude) \n        } returns response\n    }\n\n    @Test\n    fun `calling getCity should call api`() = runTest {\n        // given\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        coVerify { \n            service.findCity(latitude, longitude) \n        }\n    }\n\n    @Test\n    fun `calling getCity should store response city in database`() = runTest {\n        // given\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        coVerify {\n            dao.insertCity(\n                withArg { entity -\u003e\n                    assertEquals(\n                        cityName,\n                        entity.cityName\n                    )\n                }\n            )\n        }\n    }\n\n    @Test\n    fun `calling getCity should not store response city in database when result list is empty`() = runTest {\n        // given\n        val emptyResponse = mockk\u003cCityResponse\u003e {\n            every { result } returns emptyList()\n        }\n        coEvery { \n            service.findCity(latitude, longitude) \n        } returns emptyResponse\n\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        coVerify(exactly = 0) { dao.insertCity(any()) }\n    }\n\n    @Test\n    fun `calling getCity should return proper city name`() = runTest {\n        // given\n        val repository = createRepository()\n\n        // when\n        val result = repository.getCityName(\n            latitude,\n            longitude\n        )\n\n        // then\n        assertEquals(cityName, result)\n    }\n\n    @Test\nfun `calling getCity should return null when result list is empty`() = runTest {\n    // given\n    val emptyResponse = mockk\u003cCityResponse\u003e {\n        every { result } returns emptyList()\n    }\n    coEvery { \n        service.findCity(latitude, longitude) \n    } returns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    val result = repository\n        .getCityName(latitude, longitude)\n\n    // then\n    assertNull(result)\n}\n\n@Test(expected = RuntimeException::class)\nfun `calling getCity should throw exception when request fails`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude) \n    } answers { throw RuntimeException() }\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    // exception\n}\n\n    @Test\n    fun `calling getCity should not call api when there is a value in the database`() = runTest {\n        // given\n        coEvery { \n            dao.checkIfCityExists(\n                latitude,\n                longitude\n            )\n        } returns true\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        verify { service wasNot called }\n    }\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":159,"length":5,"style":"ITALIC"},{"offset":185,"length":6,"style":"ITALIC"},{"offset":259,"length":5,"style":"ITALIC"},{"offset":289,"length":6,"style":"ITALIC"},{"offset":314,"length":6,"style":"ITALIC"},{"offset":360,"length":5,"style":"ITALIC"},{"offset":387,"length":8,"style":"ITALIC"},{"offset":417,"length":5,"style":"ITALIC"},{"offset":435,"length":8,"style":"ITALIC"},{"offset":526,"length":8,"style":"ITALIC"},{"offset":645,"length":5,"style":"ITALIC"},{"offset":678,"length":8,"style":"ITALIC"},{"offset":822,"length":8,"style":"ITALIC"},{"offset":987,"length":9,"style":"ITALIC"},{"offset":1146,"length":8,"style":"ITALIC"},{"offset":1311,"length":9,"style":"ITALIC"},{"offset":1406,"length":12,"style":"ITALIC"},{"offset":1674,"length":8,"style":"ITALIC"},{"offset":1729,"length":5,"style":"ITALIC"},{"offset":1763,"length":6,"style":"ITALIC"},{"offset":1788,"length":9,"style":"ITALIC"},{"offset":1818,"length":8,"style":"ITALIC"},{"offset":2051,"length":8,"style":"ITALIC"},{"offset":2177,"length":8,"style":"ITALIC"},{"offset":2389,"length":12,"style":"ITALIC"},{"offset":2508,"length":8,"style":"ITALIC"},{"offset":2555,"length":5,"style":"ITALIC"},{"offset":2585,"length":6,"style":"ITALIC"},{"offset":2610,"length":9,"style":"ITALIC"},{"offset":2632,"length":8,"style":"ITALIC"},{"offset":2859,"length":10,"style":"ITALIC"},{"offset":2991,"length":8,"style":"ITALIC"},{"offset":3018,"length":8,"style":"ITALIC"},{"offset":3352,"length":8,"style":"ITALIC"},{"offset":3387,"length":8,"style":"ITALIC"},{"offset":3660,"length":7,"style":"ITALIC"},{"offset":3677,"length":7,"style":"ITALIC"},{"offset":175,"length":1,"style":"BOLD"},{"offset":177,"length":8,"style":"BOLD"},{"offset":191,"length":2,"style":"BOLD"},{"offset":207,"length":2,"style":"BOLD"},{"offset":230,"length":1,"style":"BOLD"},{"offset":232,"length":4,"style":"BOLD"},{"offset":279,"length":1,"style":"BOLD"},{"offset":281,"length":8,"style":"BOLD"},{"offset":295,"length":2,"style":"BOLD"},{"offset":304,"length":2,"style":"BOLD"},{"offset":335,"length":1,"style":"BOLD"},{"offset":338,"length":4,"style":"BOLD"},{"offset":377,"length":1,"style":"BOLD"},{"offset":395,"length":2,"style":"BOLD"},{"offset":415,"length":2,"style":"BOLD"},{"offset":427,"length":8,"style":"BOLD"},{"offset":443,"length":3,"style":"BOLD"},{"offset":499,"length":2,"style":"BOLD"},{"offset":534,"length":3,"style":"BOLD"},{"offset":597,"length":2,"style":"BOLD"},{"offset":617,"length":1,"style":"BOLD"},{"offset":619,"length":4,"style":"BOLD"},{"offset":668,"length":1,"style":"BOLD"},{"offset":670,"length":8,"style":"BOLD"},{"offset":686,"length":3,"style":"BOLD"},{"offset":740,"length":2,"style":"BOLD"},{"offset":763,"length":1,"style":"BOLD"},{"offset":766,"length":4,"style":"BOLD"},{"offset":830,"length":1,"style":"BOLD"},{"offset":832,"length":8,"style":"BOLD"},{"offset":996,"length":3,"style":"BOLD"},{"offset":1058,"length":1,"style":"BOLD"},{"offset":1060,"length":5,"style":"BOLD"},{"offset":1067,"length":4,"style":"BOLD"},{"offset":1154,"length":1,"style":"BOLD"},{"offset":1156,"length":8,"style":"BOLD"},{"offset":1320,"length":1,"style":"BOLD"},{"offset":1322,"length":12,"style":"BOLD"},{"offset":1374,"length":2,"style":"BOLD"},{"offset":1383,"length":2,"style":"BOLD"},{"offset":1386,"length":20,"style":"BOLD"},{"offset":1532,"length":1,"style":"BOLD"},{"offset":1534,"length":12,"style":"BOLD"},{"offset":1556,"length":1,"style":"BOLD"},{"offset":1558,"length":5,"style":"BOLD"},{"offset":1565,"length":4,"style":"BOLD"},{"offset":1682,"length":1,"style":"BOLD"},{"offset":1684,"length":8,"style":"BOLD"},{"offset":1749,"length":1,"style":"BOLD"},{"offset":1751,"length":12,"style":"BOLD"},{"offset":1769,"length":2,"style":"BOLD"},{"offset":1778,"length":2,"style":"BOLD"},{"offset":1808,"length":1,"style":"BOLD"},{"offset":1810,"length":8,"style":"BOLD"},{"offset":1826,"length":3,"style":"BOLD"},{"offset":1888,"length":2,"style":"BOLD"},{"offset":2073,"length":2,"style":"BOLD"},{"offset":2097,"length":1,"style":"BOLD"},{"offset":2099,"length":5,"style":"BOLD"},{"offset":2106,"length":4,"style":"BOLD"},{"offset":2185,"length":1,"style":"BOLD"},{"offset":2187,"length":8,"style":"BOLD"},{"offset":2424,"length":3,"style":"BOLD"},{"offset":2516,"length":1,"style":"BOLD"},{"offset":2518,"length":4,"style":"BOLD"},{"offset":2575,"length":1,"style":"BOLD"},{"offset":2577,"length":8,"style":"BOLD"},{"offset":2591,"length":2,"style":"BOLD"},{"offset":2600,"length":2,"style":"BOLD"},{"offset":2626,"length":1,"style":"BOLD"},{"offset":2628,"length":4,"style":"BOLD"},{"offset":2640,"length":3,"style":"BOLD"},{"offset":2694,"length":2,"style":"BOLD"},{"offset":2878,"length":1,"style":"BOLD"},{"offset":2999,"length":1,"style":"BOLD"},{"offset":3001,"length":4,"style":"BOLD"},{"offset":3026,"length":3,"style":"BOLD"},{"offset":3080,"length":2,"style":"BOLD"},{"offset":3090,"length":2,"style":"BOLD"},{"offset":3117,"length":1,"style":"BOLD"},{"offset":3120,"length":4,"style":"BOLD"},{"offset":3251,"length":1,"style":"BOLD"},{"offset":3254,"length":4,"style":"BOLD"},{"offset":3360,"length":1,"style":"BOLD"},{"offset":3362,"length":8,"style":"BOLD"},{"offset":3395,"length":3,"style":"BOLD"},{"offset":3507,"length":2,"style":"BOLD"},{"offset":3667,"length":2,"style":"BOLD"},{"offset":3691,"length":1,"style":"BOLD"},{"offset":3693,"length":5,"style":"BOLD"},{"offset":3700,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{},"allow_comments":true},"draft_attributes":{"type":"slide","answers":[],"title":"Step 5: Creating repository","body":null,"serialized_body":"\u003cp\u003eIn this step we are going to implement a repository pattern using a pure TDD.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s start by adding dependencies to mocking libraries, which will help us simulate the responses. The two most popular are \u003cstrong\u003emockito-kotlin\u003c/strong\u003e and \u003cstrong\u003emockk. \u003c/strong\u003eThe former is a wrapper over regular \u003cstrong\u003emockito\u003c/strong\u003e library, which was designed for Java, so it doesn\u0026#x27;t cover some of Kotlin-specific features, like mocking companion objects, as well as global and extension functions. \u003cstrong\u003eMockk \u003c/strong\u003ewas designed specially for Kotlin, so it is much more flexible, offers more features and has better support for coroutines. \nHowever,  the choice of the library is up to you. The course will show implementation using both of them.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003etestImplementation \u0026#x27;org.mockito:mockito-inline:4.2.0\u0026#x27;\ntestImplementation \u0026#x27;org.mockito.kotlin:mockito-kotlin:4.0.0\u0026#x27;\ntestImplementation \u0026#x27;io.mockk:mockk:1.12.3\u0026#x27;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003emockito-inline \u003c/strong\u003edependency is also required. Without it \u003cstrong\u003eMockito\u003c/strong\u003e won\u0026#x27;t know how to mock Kotlin classes, which are final by default.\u003c/p\u003e\u003cp\u003eThen, let\u0026#x27;s create a \u003cstrong\u003eCitiesRepository\u003c/strong\u003e class in the \u003cstrong\u003edata\u003c/strong\u003e package:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepository(\n    val dao: CitiesDao,\n    val service: FindCityService\n)\u003cspan\u003e {\n    \u003c/span\u003esuspend fun getCityName(\n        latitude: String,\n        longitude: String\n    )\u003cspan\u003e = \u0026quot;\u0026quot;\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBefore we start testing we also need to create an empty test class and set it up properly. Create a \u003cstrong\u003eCitiesRepositoryTest\u003c/strong\u003e class in the \u003cstrong\u003erepository\u003c/strong\u003e package under the \u003cstrong\u003etest\u003c/strong\u003e source set.\nA setup with \u003cstrong\u003emockito-kotlin \u003c/strong\u003emay look as follows:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepositoryTest {\n    private val dao = \u003cem\u003emock\u003c/em\u003e\u0026lt;CitiesDao\u0026gt;()\n    private val service = \u003cem\u003emock\u003c/em\u003e\u0026lt;FindCityService\u0026gt;()\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd with \u003cstrong\u003emockk\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepositoryTest {\n    private val dao = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CitiesDao\u0026gt;()\n    private val service = \u003cem\u003emockk\u003c/em\u003e\u0026lt;FindCityService\u0026gt;()\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eTesting our repository\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eOk, now we can start testing the repository. Let\u0026#x27;s create a test for fetching data from the internet and returning it.\u003c/p\u003e\u003cp\u003eFirst, let\u0026#x27;s set the mock response:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate val latitude = \u0026quot;1.0\u0026quot;\nprivate val longitude = \u0026quot;2.0\u0026quot;\nprivate val cityName = \u0026quot;London\u0026quot;\nprivate val cityInfo = \u003cem\u003emock\u003c/em\u003e\u0026lt;CityInfo\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eon \u003cstrong\u003e{ \u003c/strong\u003eadminDistrict \u003cstrong\u003e} \u003c/strong\u003e\u003cem\u003edoReturn \u003c/em\u003ecityName\n\u003cstrong\u003e}\u003c/strong\u003e\nprivate val response = \u003cem\u003emock\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eon \u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003e\u003cem\u003edoReturn listOf\u003c/em\u003e(cityInfo)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd for\u003cstrong\u003e mockk:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate val latitude = \u0026quot;1.0\u0026quot;\nprivate val longitude = \u0026quot;2.0\u0026quot;\nprivate val cityName = \u0026quot;London\u0026quot;\nprivate val cityInfo = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityInfo\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eadminDistrict \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n\u003cstrong\u003e}\u003c/strong\u003e\nprivate val response = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003elistOf\u003c/em\u003e(cityInfo)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, the test itself:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003e   \u003c/span\u003e@Test\nfun `calling getCity should call findCity endpoint`() =\n    \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e    // given\n        \u003cem\u003ewhenever\u003c/em\u003e(\n            service.findCity(latitude, longitude)\n        ) \u003cem\u003edoReturn \u003c/em\u003eresponse\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003everify\u003c/em\u003e(service).findCity(latitude, longitude)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe same test in \u003cstrong\u003emockk \u003c/strong\u003elooks as follows:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should call findCity endpoint`()= \n    \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e    // given\n        \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{\n \u003c/strong\u003e           service.findCity(latitude, longitude)\n        \u003cstrong\u003e} \u003c/strong\u003ereturns response\n\u003cstrong\u003e    \u003c/strong\u003e    val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003ecoVerify \u003c/em\u003e\u003cstrong\u003e{\n\u003c/strong\u003e            service.findCity(latitude, longitude)\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs you can see, tests using both libraries look very similar, only syntax is as bit different. \n\u003cstrong\u003eMockk\u003c/strong\u003e adds \u003cstrong\u003e\u003cem\u003eco-\u003c/em\u003e\u003c/strong\u003e prefix to the methods that call suspend functions inside, because they must be called only from the other coroutine body. So for example, instead of normal \u003cstrong\u003everify\u003c/strong\u003e block, we use, \u003cstrong\u003ecoVerify\u003c/strong\u003e which stands for \u003cstrong\u003ecoroutineVerify\u003c/strong\u003e. The same applies to \u003cstrong\u003eevery\u003c/strong\u003e and \u003cstrong\u003ecoEvery\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eBuild and run the test. It should fail. Now we are going to fix it.\u003c/p\u003e\u003cp\u003eGo back to the repository class and implement the feature to make the test pass:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepository(\n    val dao: CitiesDao,\n    val service: FindCityService\n) {\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String? = service.findCity(\n          latitude,\n          longitude\n        ).result.\u003cem\u003efirstOrNull\u003c/em\u003e()\n            ?.adminDistrict\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun your test again. It should pass. But it is not the end. The next thing to test is whether the returned value is being stored in database.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should store response city in database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ewhenever\u003c/em\u003e(\n        service.findCity(latitude, longitude)\n    ) \u003cem\u003edoReturn \u003c/em\u003eresponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    val captor = \u003cem\u003eargumentCaptor\u003c/em\u003e\u0026lt;CityEntity\u0026gt;()\n    \u003cem\u003everify\u003c/em\u003e(dao.insertCity(captor.capture()))\n        \n    val entity = captor.firstValue\n    \u003cem\u003eassertEquals\u003c/em\u003e(cityName, entity.cityName)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003eargumentCaptor \u003c/strong\u003eallows us to store the argument passed to the \u003cstrong\u003einsertCity \u003c/strong\u003emethod invoked in the repository and then do assertions based on the stored value.\nIn \u003cstrong\u003emockk\u003c/strong\u003e we don\u0026#x27;t need this captor object, we can do it more simple: \u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should store response city in database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003ereturns response\n    \u003cem\u003ecoJustRun \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003ecoVerify \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003edao.insertCity(\n            withArg \u003cstrong\u003e{ \u003c/strong\u003eentity \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e                \u003c/strong\u003e\u003cem\u003eassertEquals\u003c/em\u003e(cityName, entity.cityName)\n            \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e)\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eInside the \u003cstrong\u003ewithArg\u003c/strong\u003e function we have access to the argument passed to the \u003cstrong\u003einsertCity\u003c/strong\u003e method.\nWe also need to add \u003cstrong\u003ecoJustRun\u003c/strong\u003e function to mock the invocation to that method. Without it, \u003cstrong\u003emockk\u003c/strong\u003e would throw an exception saying that no answer was found. \nWe also use \u003cstrong\u003eany()\u003c/strong\u003e matcher there which means, that this mock should be valid for any argument value, unlike the mock above which explicitly sets the mock to work only for a given latitude and longitude.\n\nRemember to also add this line to the previous test, otherwise it will start to fail once the \u003cstrong\u003edao\u003c/strong\u003e interaction was added to the feature implementation.\n\nWe can also achieve the same behaviour, by just adding \u003cstrong\u003erelaxed\u003c/strong\u003e parameter to the mock definition. Then we don\u0026#x27;t need this \u003cstrong\u003ejustRun\u003c/strong\u003e at all. \u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eval dao = mockk\u0026lt;CitiesDao\u0026gt;(relaxed = true)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt this point those tests should fail. To fix it, go back to the repository class and implement the feature.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003esuspend fun getCityName(\n    latitude: String,\n    longitude: String\n) = service.findCity(latitude, longitude)\n        .result.\u003cem\u003efirstOrNull\u003c/em\u003e()\n        ?.adminDistrict\n        ?.\u003cem\u003ealso \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003ecityName \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003edao.insertCity(\n                CityEntity(\n                    latitude, \n                    longitude, \n                    cityName\n                )\n            )\n        \u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe test should pass now, but there is an additional scenario we should test - when the list is empty and the null-safe calls are not invoked. In this scenario the \u003cstrong\u003einsertCity\u003c/strong\u003e should not be invoked at all.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should not store response city in database when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    val emptyResponse = \u003cem\u003emock\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eon \u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003e\u003cem\u003edoReturn emptyList\u003c/em\u003e()\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ewhenever\u003c/em\u003e(\n        service.findCity(latitude, longitude)\n    ) \u003cem\u003edoReturn \u003c/em\u003eemptyResponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003everify\u003c/em\u003e(dao, \u003cem\u003enever\u003c/em\u003e()).insertCity(\u003cem\u003eany\u003c/em\u003e())\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003enever()\u003c/strong\u003e is a verification mode which says that we are checking that this method was not called at all during the test.\u003c/p\u003e\u003cp\u003eIn \u003cstrong\u003emockk\u003c/strong\u003e it\u0026#x27;s even shorter:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should not store response city in database when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    val emptyResponse = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003eemptyList\u003c/em\u003e()\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003ecoVerify\u003c/em\u003e(exactly = 0) \u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow run all repository tests. All of them should pass.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eAdding more tests\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWe are still testing our repository. Now we need to test, if the repository is returning a result from the database. \nFrom now on, the course will show only \u003cstrong\u003emockk\u003c/strong\u003e code.\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should return proper city name`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns response\n    \u003cem\u003ecoJustRun \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    val result = repository.getCityName(\n        latitude,\n        longitude\n    )\n\n    // then\n    \u003cem\u003eassertEquals\u003c/em\u003e(cityName, result)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe next step will be checking that in case of an empty response list, we receive a null value:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should return null when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    val emptyResponse = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003eemptyList\u003c/em\u003e()\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003ereturns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    val result = repository\n        .getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003eassertNull\u003c/em\u003e(result)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn case of some network error, the code in the repository will throw an exception, because that\u0026#x27;s the way coroutines signal errors in execution. \nLet\u0026#x27;s verify this behaviour:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test(expected = RuntimeException::class)\nfun `calling getCity should throw exception when request fails`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003eanswers \u003cstrong\u003e{ \u003c/strong\u003ethrow RuntimeException() \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then \n    // exception\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time we are using \u003cstrong\u003eanswers\u003c/strong\u003e instead of \u003cstrong\u003ereturns\u003c/strong\u003e, in order to throw the exception inside the lambda. Also, we need to add an expected exception class to the \u003cstrong\u003e@Test\u003c/strong\u003e annotation. \nAs you can see, there\u0026#x27;s no assertion at the end of the test, because the \u003cstrong\u003eexpected\u003c/strong\u003e parameter in the annotation took its job.\u003c/p\u003e\u003cp\u003e\nThe last step is to ensure that we are not calling our service when a given city is already stored in the database. Start with creating a test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `calling getCity should not call api when there is a value in the database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns response\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        dao.checkIfCityExists(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns true\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        dao.getCityName(latitude, longitude)\n    \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n    \u003cem\u003ecoJustRun \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003everify \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eservice \u003cem\u003ewasNot \u003c/em\u003ecalled \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003ewasNot called\u003c/strong\u003e expression is a part of \u003cstrong\u003emockk\u003c/strong\u003e DSL for checking if there were no interactions with a given object.\n\nNext, implement the feature to make it pass:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003esuspend fun getCityName(\n    latitude: String,\n    longitude: String\n) =\n    if (dao.checkIfCityExists(latitude, longitude)) {\n        dao.getCityName(latitude, longitude)\n    } else {\n        service.findCity(latitude, longitude)\n            .result.\u003cem\u003efirstOrNull\u003c/em\u003e()\n            ?.adminDistrict\n            ?.\u003cem\u003ealso \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003ecityName \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e                \u003c/strong\u003edao.insertCity(\n                    CityEntity(\n                        latitude,\n                        longitude, \n                        cityName\n                    )\n                )\n            \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun all tests for the repository. You should notice that this test is passing, but all others are failing now. \nAdd a mock response for \u003cstrong\u003echeckIfCityExists\u003c/strong\u003e to them method to make them pass again.\nAs you can see, the number of \u003cstrong\u003eevery\u003c/strong\u003e invocations is increasing together with the implementation complexity. It\u0026#x27;s worth considering adding a default response to the mocked methods during the mock declaration (just like with the \u003cstrong\u003eresponse\u003c/strong\u003e mock) to avoid writing them in every single test.\u003c/p\u003e\u003cp\u003eYou can reference the full test class below with the mentioned adjustments below:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepositoryTest {\n    private val latitude = \u0026quot;1.0\u0026quot;\n    private val longitude = \u0026quot;2.0\u0026quot;\n    private val cityName = \u0026quot;London\u0026quot;\n    private val cityInfo = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityInfo\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eadminDistrict \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eprivate val response = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003elistOf\u003c/em\u003e(cityInfo)\n    \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eprivate val dao = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CitiesDao\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n        \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003einsertCity(any()) \u003cstrong\u003e} \u003c/strong\u003e\u003cem\u003ejust \u003c/em\u003eruns\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            getCityName(latitude, longitude)\n        \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n        \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            checkIfCityExists(latitude, longitude) \n        \u003cstrong\u003e} \u003c/strong\u003ereturns false\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eprivate val service = \u003cem\u003emockk\u003c/em\u003e\u0026lt;FindCityService\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            findCity(latitude, longitude) \n        \u003cstrong\u003e} \u003c/strong\u003ereturns response\n    \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should call api`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003ecoVerify \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            service.findCity(latitude, longitude) \n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should store response city in database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003ecoVerify \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003edao.insertCity(\n                withArg \u003cstrong\u003e{ \u003c/strong\u003eentity \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e                    \u003c/strong\u003e\u003cem\u003eassertEquals\u003c/em\u003e(\n                        cityName,\n                        entity.cityName\n                    )\n                \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e)\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should not store response city in database when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        val emptyResponse = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003eemptyList\u003c/em\u003e()\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            service.findCity(latitude, longitude) \n        \u003cstrong\u003e} \u003c/strong\u003ereturns emptyResponse\n\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003ecoVerify\u003c/em\u003e(exactly = 0) \u003cstrong\u003e{ \u003c/strong\u003edao.insertCity(any()) \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should return proper city name`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        val repository = createRepository()\n\n        // when\n        val result = repository.getCityName(\n            latitude,\n            longitude\n        )\n\n        // then\n        \u003cem\u003eassertEquals\u003c/em\u003e(cityName, result)\n    \u003cstrong\u003e}\n\n\u003c/strong\u003e    @Test\nfun `calling getCity should return null when result list is empty`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    val emptyResponse = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CityResponse\u0026gt; \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eresult \u003cstrong\u003e} \u003c/strong\u003ereturns \u003cem\u003eemptyList\u003c/em\u003e()\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003ereturns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    val result = repository\n        .getCityName(latitude, longitude)\n\n    // then\n    \u003cem\u003eassertNull\u003c/em\u003e(result)\n\u003cstrong\u003e}\u003c/strong\u003e\n\n@Test(expected = RuntimeException::class)\nfun `calling getCity should throw exception when request fails`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e// given\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        service.findCity(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003eanswers \u003cstrong\u003e{ \u003c/strong\u003ethrow RuntimeException() \u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eval repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    // exception\n\u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003e@Test\n    fun `calling getCity should not call api when there is a value in the database`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e// given\n        \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            dao.checkIfCityExists(\n                latitude,\n                longitude\n            )\n        \u003cstrong\u003e} \u003c/strong\u003ereturns true\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        \u003cem\u003everify \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eservice \u003cem\u003ewasNot \u003c/em\u003ecalled \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eprivate fun createRepository() =\n        CitiesRepository(dao, service)\n}\u003c/code\u003e\u003c/pre\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"915f3","text":"In this step we are going to implement a repository pattern using a pure TDD.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bg5ah","text":"Let's start by adding dependencies to mocking libraries, which will help us simulate the responses. The two most popular are mockito-kotlin and mockk. The former is a wrapper over regular mockito library, which was designed for Java, so it doesn't cover some of Kotlin-specific features, like mocking companion objects, as well as global and extension functions. Mockk was designed specially for Kotlin, so it is much more flexible, offers more features and has better support for coroutines. \nHowever,  the choice of the library is up to you. The course will show implementation using both of them.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":125,"length":14,"style":"BOLD"},{"offset":144,"length":7,"style":"BOLD"},{"offset":188,"length":7,"style":"BOLD"},{"offset":363,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"euj9n","text":"testImplementation 'org.mockito:mockito-inline:4.2.0'\ntestImplementation 'org.mockito.kotlin:mockito-kotlin:4.0.0'\ntestImplementation 'io.mockk:mockk:1.12.3'","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8hsti","text":"The mockito-inline dependency is also required. Without it Mockito won't know how to mock Kotlin classes, which are final by default.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":15,"style":"BOLD"},{"offset":59,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"frvji","text":"Then, let's create a CitiesRepository class in the data package:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":21,"length":16,"style":"BOLD"},{"offset":51,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9h4uj","text":"class CitiesRepository(\n    val dao: CitiesDao,\n    val service: FindCityService\n) {\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ) = \"\"\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":82,"length":7,"style":"CODE"},{"offset":171,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"ek4m9","text":"Before we start testing we also need to create an empty test class and set it up properly. Create a CitiesRepositoryTest class in the repository package under the test source set.\nA setup with mockito-kotlin may look as follows:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":100,"length":20,"style":"BOLD"},{"offset":134,"length":10,"style":"BOLD"},{"offset":163,"length":4,"style":"BOLD"},{"offset":193,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ennjb","text":"class CitiesRepositoryTest {\n    private val dao = mock\u003cCitiesDao\u003e()\n    private val service = mock\u003cFindCityService\u003e()\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":51,"length":4,"style":"ITALIC"},{"offset":95,"length":4,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"2cr92","text":"And with mockk:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":9,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a40ck","text":"class CitiesRepositoryTest {\n    private val dao = mockk\u003cCitiesDao\u003e()\n    private val service = mockk\u003cFindCityService\u003e()\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":51,"length":5,"style":"ITALIC"},{"offset":96,"length":5,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"1uujj","text":"Testing our repository","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9qff8","text":"Ok, now we can start testing the repository. Let's create a test for fetching data from the internet and returning it.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5bblv","text":"First, let's set the mock response:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5nce9","text":"private val latitude = \"1.0\"\nprivate val longitude = \"2.0\"\nprivate val cityName = \"London\"\nprivate val cityInfo = mock\u003cCityInfo\u003e {\n    on { adminDistrict } doReturn cityName\n}\nprivate val response = mock\u003cCityResponse\u003e {\n    on { result } doReturn listOf(cityInfo)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":114,"length":4,"style":"ITALIC"},{"offset":156,"length":9,"style":"ITALIC"},{"offset":199,"length":4,"style":"ITALIC"},{"offset":238,"length":15,"style":"ITALIC"},{"offset":129,"length":1,"style":"BOLD"},{"offset":131,"length":4,"style":"BOLD"},{"offset":138,"length":2,"style":"BOLD"},{"offset":154,"length":2,"style":"BOLD"},{"offset":174,"length":1,"style":"BOLD"},{"offset":218,"length":1,"style":"BOLD"},{"offset":220,"length":4,"style":"BOLD"},{"offset":227,"length":2,"style":"BOLD"},{"offset":236,"length":2,"style":"BOLD"},{"offset":264,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dvnl1","text":"And for mockk:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":7,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"60f01","text":"private val latitude = \"1.0\"\nprivate val longitude = \"2.0\"\nprivate val cityName = \"London\"\nprivate val cityInfo = mockk\u003cCityInfo\u003e {\n    every { adminDistrict } returns cityName\n}\nprivate val response = mockk\u003cCityResponse\u003e {\n    every { result } returns listOf(cityInfo)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":114,"length":5,"style":"ITALIC"},{"offset":136,"length":6,"style":"ITALIC"},{"offset":202,"length":5,"style":"ITALIC"},{"offset":228,"length":6,"style":"ITALIC"},{"offset":253,"length":6,"style":"ITALIC"},{"offset":130,"length":1,"style":"BOLD"},{"offset":132,"length":4,"style":"BOLD"},{"offset":142,"length":2,"style":"BOLD"},{"offset":158,"length":2,"style":"BOLD"},{"offset":177,"length":1,"style":"BOLD"},{"offset":222,"length":1,"style":"BOLD"},{"offset":224,"length":4,"style":"BOLD"},{"offset":234,"length":2,"style":"BOLD"},{"offset":243,"length":2,"style":"BOLD"},{"offset":270,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"brpt5","text":"Now, the test itself:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3dqrl","text":"   @Test\nfun `calling getCity should call findCity endpoint`() =\n    runTest {\n        // given\n        whenever(\n            service.findCity(latitude, longitude)\n        ) doReturn response\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        verify(service).findCity(latitude, longitude)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"CODE"},{"offset":69,"length":8,"style":"ITALIC"},{"offset":104,"length":8,"style":"ITALIC"},{"offset":174,"length":9,"style":"ITALIC"},{"offset":330,"length":6,"style":"ITALIC"},{"offset":77,"length":1,"style":"BOLD"},{"offset":79,"length":4,"style":"BOLD"},{"offset":376,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2fuuj","text":"The same test in mockk looks as follows:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":17,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ccjpk","text":"@Test\nfun `calling getCity should call findCity endpoint`()= \n    runTest {\n        // given\n        coEvery {\n            service.findCity(latitude, longitude)\n        } returns response\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        coVerify {\n            service.findCity(latitude, longitude)\n        }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":66,"length":8,"style":"ITALIC"},{"offset":101,"length":8,"style":"ITALIC"},{"offset":326,"length":9,"style":"ITALIC"},{"offset":74,"length":1,"style":"BOLD"},{"offset":76,"length":4,"style":"BOLD"},{"offset":109,"length":3,"style":"BOLD"},{"offset":169,"length":2,"style":"BOLD"},{"offset":188,"length":4,"style":"BOLD"},{"offset":335,"length":2,"style":"BOLD"},{"offset":395,"length":1,"style":"BOLD"},{"offset":397,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5seub","text":"As you can see, tests using both libraries look very similar, only syntax is as bit different. \nMockk adds co- prefix to the methods that call suspend functions inside, because they must be called only from the other coroutine body. So for example, instead of normal verify block, we use, coVerify which stands for coroutineVerify. The same applies to every and coEvery.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":96,"length":5,"style":"BOLD"},{"offset":107,"length":3,"style":"BOLD"},{"offset":267,"length":6,"style":"BOLD"},{"offset":289,"length":8,"style":"BOLD"},{"offset":315,"length":15,"style":"BOLD"},{"offset":352,"length":5,"style":"BOLD"},{"offset":362,"length":7,"style":"BOLD"},{"offset":107,"length":3,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"b6mfc","text":"Build and run the test. It should fail. Now we are going to fix it.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1mmc8","text":"Go back to the repository class and implement the feature to make the test pass:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aj920","text":"class CitiesRepository(\n    val dao: CitiesDao,\n    val service: FindCityService\n) {\n    suspend fun getCityName(\n        latitude: String,\n        longitude: String\n    ): String? = service.findCity(\n          latitude,\n          longitude\n        ).result.firstOrNull()\n            ?.adminDistrict\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":258,"length":11,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"4eb3f","text":"Run your test again. It should pass. But it is not the end. The next thing to test is whether the returned value is being stored in database.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9h9le","text":"@Test\nfun `calling getCity should store response city in database`() = runTest {\n    // given\n    whenever(\n        service.findCity(latitude, longitude)\n    ) doReturn response\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    val captor = argumentCaptor\u003cCityEntity\u003e()\n    verify(dao.insertCity(captor.capture()))\n        \n    val entity = captor.firstValue\n    assertEquals(cityName, entity.cityName)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":71,"length":8,"style":"ITALIC"},{"offset":98,"length":8,"style":"ITALIC"},{"offset":160,"length":9,"style":"ITALIC"},{"offset":310,"length":14,"style":"ITALIC"},{"offset":343,"length":6,"style":"ITALIC"},{"offset":432,"length":12,"style":"ITALIC"},{"offset":79,"length":1,"style":"BOLD"},{"offset":81,"length":4,"style":"BOLD"},{"offset":472,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dg8u4","text":"The argumentCaptor allows us to store the argument passed to the insertCity method invoked in the repository and then do assertions based on the stored value.\nIn mockk we don't need this captor object, we can do it more simple: ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":15,"style":"BOLD"},{"offset":65,"length":11,"style":"BOLD"},{"offset":162,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fnjk3","text":"@Test\nfun `calling getCity should store response city in database`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude) \n    } returns response\n    coJustRun { dao.insertCity(any()) }\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    coVerify {\n        dao.insertCity(\n            withArg { entity -\u003e\n                assertEquals(cityName, entity.cityName)\n            }\n        )\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":71,"length":8,"style":"ITALIC"},{"offset":98,"length":8,"style":"ITALIC"},{"offset":183,"length":10,"style":"ITALIC"},{"offset":338,"length":9,"style":"ITALIC"},{"offset":421,"length":12,"style":"ITALIC"},{"offset":79,"length":1,"style":"BOLD"},{"offset":81,"length":4,"style":"BOLD"},{"offset":106,"length":3,"style":"BOLD"},{"offset":160,"length":2,"style":"BOLD"},{"offset":193,"length":2,"style":"BOLD"},{"offset":217,"length":1,"style":"BOLD"},{"offset":220,"length":4,"style":"BOLD"},{"offset":347,"length":1,"style":"BOLD"},{"offset":349,"length":8,"style":"BOLD"},{"offset":393,"length":2,"style":"BOLD"},{"offset":402,"length":2,"style":"BOLD"},{"offset":405,"length":16,"style":"BOLD"},{"offset":473,"length":1,"style":"BOLD"},{"offset":475,"length":8,"style":"BOLD"},{"offset":489,"length":1,"style":"BOLD"},{"offset":491,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3ormh","text":"Inside the withArg function we have access to the argument passed to the insertCity method.\nWe also need to add coJustRun function to mock the invocation to that method. Without it, mockk would throw an exception saying that no answer was found. \nWe also use any() matcher there which means, that this mock should be valid for any argument value, unlike the mock above which explicitly sets the mock to work only for a given latitude and longitude.\n\nRemember to also add this line to the previous test, otherwise it will start to fail once the dao interaction was added to the feature implementation.\n\nWe can also achieve the same behaviour, by just adding relaxed parameter to the mock definition. Then we don't need this justRun at all. ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":11,"length":7,"style":"BOLD"},{"offset":73,"length":10,"style":"BOLD"},{"offset":112,"length":9,"style":"BOLD"},{"offset":182,"length":5,"style":"BOLD"},{"offset":259,"length":5,"style":"BOLD"},{"offset":544,"length":3,"style":"BOLD"},{"offset":657,"length":7,"style":"BOLD"},{"offset":723,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bvi0","text":"val dao = mockk\u003cCitiesDao\u003e(relaxed = true)","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"af2b6","text":"At this point those tests should fail. To fix it, go back to the repository class and implement the feature.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9jimb","text":"suspend fun getCityName(\n    latitude: String,\n    longitude: String\n) = service.findCity(latitude, longitude)\n        .result.firstOrNull()\n        ?.adminDistrict\n        ?.also { cityName -\u003e\n            dao.insertCity(\n                CityEntity(\n                    latitude, \n                    longitude, \n                    cityName\n                )\n            )\n        }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":127,"length":11,"style":"ITALIC"},{"offset":175,"length":5,"style":"ITALIC"},{"offset":180,"length":2,"style":"BOLD"},{"offset":191,"length":2,"style":"BOLD"},{"offset":194,"length":12,"style":"BOLD"},{"offset":382,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1gfe6","text":"The test should pass now, but there is an additional scenario we should test - when the list is empty and the null-safe calls are not invoked. In this scenario the insertCity should not be invoked at all.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":164,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fndv2","text":"@Test\nfun `calling getCity should not store response city in database when result list is empty`() = runTest {\n    // given\n    val emptyResponse = mock\u003cCityResponse\u003e {\n        on { result } doReturn emptyList()\n    }\n    whenever(\n        service.findCity(latitude, longitude)\n    ) doReturn emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    verify(dao, never()).insertCity(any())\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":101,"length":8,"style":"ITALIC"},{"offset":148,"length":4,"style":"ITALIC"},{"offset":191,"length":18,"style":"ITALIC"},{"offset":222,"length":8,"style":"ITALIC"},{"offset":284,"length":9,"style":"ITALIC"},{"offset":426,"length":6,"style":"ITALIC"},{"offset":438,"length":5,"style":"ITALIC"},{"offset":458,"length":3,"style":"ITALIC"},{"offset":109,"length":1,"style":"BOLD"},{"offset":111,"length":4,"style":"BOLD"},{"offset":167,"length":1,"style":"BOLD"},{"offset":169,"length":8,"style":"BOLD"},{"offset":180,"length":2,"style":"BOLD"},{"offset":189,"length":2,"style":"BOLD"},{"offset":216,"length":1,"style":"BOLD"},{"offset":218,"length":4,"style":"BOLD"},{"offset":465,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ea3q0","text":"never() is a verification mode which says that we are checking that this method was not called at all during the test.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6c4dn","text":"In mockk it's even shorter:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":3,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"f3p4k","text":"@Test\nfun `calling getCity should not store response city in database when result list is empty`() = runTest {\n    // given\n    val emptyResponse = mockk\u003cCityResponse\u003e {\n        every { result } returns emptyList()\n    }\n    coEvery { \n        service.findCity(latitude, longitude)\n    } returns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    coVerify(exactly = 0) { dao.insertCity(any()) }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":101,"length":8,"style":"ITALIC"},{"offset":148,"length":5,"style":"ITALIC"},{"offset":178,"length":6,"style":"ITALIC"},{"offset":203,"length":9,"style":"ITALIC"},{"offset":225,"length":8,"style":"ITALIC"},{"offset":429,"length":8,"style":"ITALIC"},{"offset":109,"length":1,"style":"BOLD"},{"offset":111,"length":4,"style":"BOLD"},{"offset":168,"length":1,"style":"BOLD"},{"offset":170,"length":8,"style":"BOLD"},{"offset":184,"length":2,"style":"BOLD"},{"offset":193,"length":2,"style":"BOLD"},{"offset":219,"length":1,"style":"BOLD"},{"offset":221,"length":4,"style":"BOLD"},{"offset":233,"length":3,"style":"BOLD"},{"offset":286,"length":2,"style":"BOLD"},{"offset":451,"length":2,"style":"BOLD"},{"offset":475,"length":1,"style":"BOLD"},{"offset":477,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bj0lk","text":"Now run all repository tests. All of them should pass.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3sbts","text":"Adding more tests","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ebsvu","text":"We are still testing our repository. Now we need to test, if the repository is returning a result from the database. \nFrom now on, the course will show only mockk code.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":157,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ccd0d","text":"@Test\nfun `calling getCity should return proper city name`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude)\n    } returns response\n    coJustRun { dao.insertCity(any()) }\n\n    val repository = createRepository()\n\n    // when\n    val result = repository.getCityName(\n        latitude,\n        longitude\n    )\n\n    // then\n    assertEquals(cityName, result)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":63,"length":8,"style":"ITALIC"},{"offset":90,"length":8,"style":"ITALIC"},{"offset":174,"length":10,"style":"ITALIC"},{"offset":364,"length":12,"style":"ITALIC"},{"offset":71,"length":1,"style":"BOLD"},{"offset":73,"length":4,"style":"BOLD"},{"offset":98,"length":3,"style":"BOLD"},{"offset":151,"length":2,"style":"BOLD"},{"offset":184,"length":2,"style":"BOLD"},{"offset":208,"length":1,"style":"BOLD"},{"offset":211,"length":4,"style":"BOLD"},{"offset":395,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a7q35","text":"The next step will be checking that in case of an empty response list, we receive a null value:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ae32t","text":"@Test\nfun `calling getCity should return null when result list is empty`() = runTest {\n    // given\n    val emptyResponse = mockk\u003cCityResponse\u003e {\n        every { result } returns emptyList()\n    }\n    coEvery { \n        service.findCity(latitude, longitude) \n    } returns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    val result = repository\n        .getCityName(latitude, longitude)\n\n    // then\n    assertNull(result)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":77,"length":8,"style":"ITALIC"},{"offset":124,"length":5,"style":"ITALIC"},{"offset":154,"length":6,"style":"ITALIC"},{"offset":179,"length":9,"style":"ITALIC"},{"offset":201,"length":8,"style":"ITALIC"},{"offset":428,"length":10,"style":"ITALIC"},{"offset":85,"length":1,"style":"BOLD"},{"offset":87,"length":4,"style":"BOLD"},{"offset":144,"length":1,"style":"BOLD"},{"offset":146,"length":8,"style":"BOLD"},{"offset":160,"length":2,"style":"BOLD"},{"offset":169,"length":2,"style":"BOLD"},{"offset":195,"length":1,"style":"BOLD"},{"offset":197,"length":4,"style":"BOLD"},{"offset":209,"length":3,"style":"BOLD"},{"offset":263,"length":2,"style":"BOLD"},{"offset":447,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"du416","text":"In case of some network error, the code in the repository will throw an exception, because that's the way coroutines signal errors in execution. \nLet's verify this behaviour:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5civj","text":"@Test(expected = RuntimeException::class)\nfun `calling getCity should throw exception when request fails`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude) \n    } answers { throw RuntimeException() }\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then \n    // exception\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":110,"length":8,"style":"ITALIC"},{"offset":137,"length":8,"style":"ITALIC"},{"offset":118,"length":1,"style":"BOLD"},{"offset":120,"length":4,"style":"BOLD"},{"offset":145,"length":3,"style":"BOLD"},{"offset":199,"length":2,"style":"BOLD"},{"offset":209,"length":2,"style":"BOLD"},{"offset":236,"length":1,"style":"BOLD"},{"offset":239,"length":4,"style":"BOLD"},{"offset":371,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1ceh4","text":"This time we are using answers instead of returns, in order to throw the exception inside the lambda. Also, we need to add an expected exception class to the @Test annotation. \nAs you can see, there's no assertion at the end of the test, because the expected parameter in the annotation took its job.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":23,"length":7,"style":"BOLD"},{"offset":42,"length":7,"style":"BOLD"},{"offset":158,"length":5,"style":"BOLD"},{"offset":250,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bteve","text":"\nThe last step is to ensure that we are not calling our service when a given city is already stored in the database. Start with creating a test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6tf2r","text":"@Test\nfun `calling getCity should not call api when there is a value in the database`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude)\n    } returns response\n    coEvery { \n        dao.checkIfCityExists(latitude, longitude)\n    } returns true\n    coEvery { \n        dao.getCityName(latitude, longitude)\n    } returns cityName\n    coJustRun { dao.insertCity(any()) }\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    verify { service wasNot called }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":90,"length":8,"style":"ITALIC"},{"offset":117,"length":8,"style":"ITALIC"},{"offset":201,"length":8,"style":"ITALIC"},{"offset":286,"length":8,"style":"ITALIC"},{"offset":369,"length":10,"style":"ITALIC"},{"offset":524,"length":7,"style":"ITALIC"},{"offset":541,"length":7,"style":"ITALIC"},{"offset":98,"length":1,"style":"BOLD"},{"offset":100,"length":4,"style":"BOLD"},{"offset":125,"length":3,"style":"BOLD"},{"offset":178,"length":2,"style":"BOLD"},{"offset":209,"length":3,"style":"BOLD"},{"offset":267,"length":2,"style":"BOLD"},{"offset":294,"length":3,"style":"BOLD"},{"offset":346,"length":2,"style":"BOLD"},{"offset":379,"length":2,"style":"BOLD"},{"offset":403,"length":1,"style":"BOLD"},{"offset":406,"length":4,"style":"BOLD"},{"offset":531,"length":2,"style":"BOLD"},{"offset":555,"length":1,"style":"BOLD"},{"offset":557,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ftrj2","text":"The wasNot called expression is a part of mockk DSL for checking if there were no interactions with a given object.\n\nNext, implement the feature to make it pass:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":13,"style":"BOLD"},{"offset":42,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2ds03","text":"suspend fun getCityName(\n    latitude: String,\n    longitude: String\n) =\n    if (dao.checkIfCityExists(latitude, longitude)) {\n        dao.getCityName(latitude, longitude)\n    } else {\n        service.findCity(latitude, longitude)\n            .result.firstOrNull()\n            ?.adminDistrict\n            ?.also { cityName -\u003e\n                dao.insertCity(\n                    CityEntity(\n                        latitude,\n                        longitude, \n                        cityName\n                    )\n                )\n            }\n    }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":251,"length":11,"style":"ITALIC"},{"offset":307,"length":5,"style":"ITALIC"},{"offset":312,"length":2,"style":"BOLD"},{"offset":323,"length":2,"style":"BOLD"},{"offset":326,"length":16,"style":"BOLD"},{"offset":545,"length":1,"style":"BOLD"},{"offset":547,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"d2ns6","text":"Run all tests for the repository. You should notice that this test is passing, but all others are failing now. \nAdd a mock response for checkIfCityExists to them method to make them pass again.\nAs you can see, the number of every invocations is increasing together with the implementation complexity. It's worth considering adding a default response to the mocked methods during the mock declaration (just like with the response mock) to avoid writing them in every single test.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":136,"length":17,"style":"BOLD"},{"offset":224,"length":5,"style":"BOLD"},{"offset":420,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3o3nk","text":"You can reference the full test class below with the mentioned adjustments below:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"blcqg","text":"class CitiesRepositoryTest {\n    private val latitude = \"1.0\"\n    private val longitude = \"2.0\"\n    private val cityName = \"London\"\n    private val cityInfo = mockk\u003cCityInfo\u003e {\n        every { adminDistrict } returns cityName\n    }\n    private val response = mockk\u003cCityResponse\u003e {\n        every { result } returns listOf(cityInfo)\n    }\n\n    private val dao = mockk\u003cCitiesDao\u003e {\n        coEvery { insertCity(any()) } just runs\n        coEvery { \n            getCityName(latitude, longitude)\n        } returns cityName\n        coEvery { \n            checkIfCityExists(latitude, longitude) \n        } returns false\n    }\n    private val service = mockk\u003cFindCityService\u003e {\n        coEvery { \n            findCity(latitude, longitude) \n        } returns response\n    }\n\n    @Test\n    fun `calling getCity should call api`() = runTest {\n        // given\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        coVerify { \n            service.findCity(latitude, longitude) \n        }\n    }\n\n    @Test\n    fun `calling getCity should store response city in database`() = runTest {\n        // given\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        coVerify {\n            dao.insertCity(\n                withArg { entity -\u003e\n                    assertEquals(\n                        cityName,\n                        entity.cityName\n                    )\n                }\n            )\n        }\n    }\n\n    @Test\n    fun `calling getCity should not store response city in database when result list is empty`() = runTest {\n        // given\n        val emptyResponse = mockk\u003cCityResponse\u003e {\n            every { result } returns emptyList()\n        }\n        coEvery { \n            service.findCity(latitude, longitude) \n        } returns emptyResponse\n\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        coVerify(exactly = 0) { dao.insertCity(any()) }\n    }\n\n    @Test\n    fun `calling getCity should return proper city name`() = runTest {\n        // given\n        val repository = createRepository()\n\n        // when\n        val result = repository.getCityName(\n            latitude,\n            longitude\n        )\n\n        // then\n        assertEquals(cityName, result)\n    }\n\n    @Test\nfun `calling getCity should return null when result list is empty`() = runTest {\n    // given\n    val emptyResponse = mockk\u003cCityResponse\u003e {\n        every { result } returns emptyList()\n    }\n    coEvery { \n        service.findCity(latitude, longitude) \n    } returns emptyResponse\n\n    val repository = createRepository()\n\n    // when\n    val result = repository\n        .getCityName(latitude, longitude)\n\n    // then\n    assertNull(result)\n}\n\n@Test(expected = RuntimeException::class)\nfun `calling getCity should throw exception when request fails`() = runTest {\n    // given\n    coEvery { \n        service.findCity(latitude, longitude) \n    } answers { throw RuntimeException() }\n\n    val repository = createRepository()\n\n    // when\n    repository.getCityName(latitude, longitude)\n\n    // then\n    // exception\n}\n\n    @Test\n    fun `calling getCity should not call api when there is a value in the database`() = runTest {\n        // given\n        coEvery { \n            dao.checkIfCityExists(\n                latitude,\n                longitude\n            )\n        } returns true\n        val repository = createRepository()\n\n        // when\n        repository.getCityName(latitude, longitude)\n\n        // then\n        verify { service wasNot called }\n    }\n\n    private fun createRepository() =\n        CitiesRepository(dao, service)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":159,"length":5,"style":"ITALIC"},{"offset":185,"length":6,"style":"ITALIC"},{"offset":259,"length":5,"style":"ITALIC"},{"offset":289,"length":6,"style":"ITALIC"},{"offset":314,"length":6,"style":"ITALIC"},{"offset":360,"length":5,"style":"ITALIC"},{"offset":387,"length":8,"style":"ITALIC"},{"offset":417,"length":5,"style":"ITALIC"},{"offset":435,"length":8,"style":"ITALIC"},{"offset":526,"length":8,"style":"ITALIC"},{"offset":645,"length":5,"style":"ITALIC"},{"offset":678,"length":8,"style":"ITALIC"},{"offset":822,"length":8,"style":"ITALIC"},{"offset":987,"length":9,"style":"ITALIC"},{"offset":1146,"length":8,"style":"ITALIC"},{"offset":1311,"length":9,"style":"ITALIC"},{"offset":1406,"length":12,"style":"ITALIC"},{"offset":1674,"length":8,"style":"ITALIC"},{"offset":1729,"length":5,"style":"ITALIC"},{"offset":1763,"length":6,"style":"ITALIC"},{"offset":1788,"length":9,"style":"ITALIC"},{"offset":1818,"length":8,"style":"ITALIC"},{"offset":2051,"length":8,"style":"ITALIC"},{"offset":2177,"length":8,"style":"ITALIC"},{"offset":2389,"length":12,"style":"ITALIC"},{"offset":2508,"length":8,"style":"ITALIC"},{"offset":2555,"length":5,"style":"ITALIC"},{"offset":2585,"length":6,"style":"ITALIC"},{"offset":2610,"length":9,"style":"ITALIC"},{"offset":2632,"length":8,"style":"ITALIC"},{"offset":2859,"length":10,"style":"ITALIC"},{"offset":2991,"length":8,"style":"ITALIC"},{"offset":3018,"length":8,"style":"ITALIC"},{"offset":3352,"length":8,"style":"ITALIC"},{"offset":3387,"length":8,"style":"ITALIC"},{"offset":3660,"length":7,"style":"ITALIC"},{"offset":3677,"length":7,"style":"ITALIC"},{"offset":175,"length":1,"style":"BOLD"},{"offset":177,"length":8,"style":"BOLD"},{"offset":191,"length":2,"style":"BOLD"},{"offset":207,"length":2,"style":"BOLD"},{"offset":230,"length":1,"style":"BOLD"},{"offset":232,"length":4,"style":"BOLD"},{"offset":279,"length":1,"style":"BOLD"},{"offset":281,"length":8,"style":"BOLD"},{"offset":295,"length":2,"style":"BOLD"},{"offset":304,"length":2,"style":"BOLD"},{"offset":335,"length":1,"style":"BOLD"},{"offset":338,"length":4,"style":"BOLD"},{"offset":377,"length":1,"style":"BOLD"},{"offset":395,"length":2,"style":"BOLD"},{"offset":415,"length":2,"style":"BOLD"},{"offset":427,"length":8,"style":"BOLD"},{"offset":443,"length":3,"style":"BOLD"},{"offset":499,"length":2,"style":"BOLD"},{"offset":534,"length":3,"style":"BOLD"},{"offset":597,"length":2,"style":"BOLD"},{"offset":617,"length":1,"style":"BOLD"},{"offset":619,"length":4,"style":"BOLD"},{"offset":668,"length":1,"style":"BOLD"},{"offset":670,"length":8,"style":"BOLD"},{"offset":686,"length":3,"style":"BOLD"},{"offset":740,"length":2,"style":"BOLD"},{"offset":763,"length":1,"style":"BOLD"},{"offset":766,"length":4,"style":"BOLD"},{"offset":830,"length":1,"style":"BOLD"},{"offset":832,"length":8,"style":"BOLD"},{"offset":996,"length":3,"style":"BOLD"},{"offset":1058,"length":1,"style":"BOLD"},{"offset":1060,"length":5,"style":"BOLD"},{"offset":1067,"length":4,"style":"BOLD"},{"offset":1154,"length":1,"style":"BOLD"},{"offset":1156,"length":8,"style":"BOLD"},{"offset":1320,"length":1,"style":"BOLD"},{"offset":1322,"length":12,"style":"BOLD"},{"offset":1374,"length":2,"style":"BOLD"},{"offset":1383,"length":2,"style":"BOLD"},{"offset":1386,"length":20,"style":"BOLD"},{"offset":1532,"length":1,"style":"BOLD"},{"offset":1534,"length":12,"style":"BOLD"},{"offset":1556,"length":1,"style":"BOLD"},{"offset":1558,"length":5,"style":"BOLD"},{"offset":1565,"length":4,"style":"BOLD"},{"offset":1682,"length":1,"style":"BOLD"},{"offset":1684,"length":8,"style":"BOLD"},{"offset":1749,"length":1,"style":"BOLD"},{"offset":1751,"length":12,"style":"BOLD"},{"offset":1769,"length":2,"style":"BOLD"},{"offset":1778,"length":2,"style":"BOLD"},{"offset":1808,"length":1,"style":"BOLD"},{"offset":1810,"length":8,"style":"BOLD"},{"offset":1826,"length":3,"style":"BOLD"},{"offset":1888,"length":2,"style":"BOLD"},{"offset":2073,"length":2,"style":"BOLD"},{"offset":2097,"length":1,"style":"BOLD"},{"offset":2099,"length":5,"style":"BOLD"},{"offset":2106,"length":4,"style":"BOLD"},{"offset":2185,"length":1,"style":"BOLD"},{"offset":2187,"length":8,"style":"BOLD"},{"offset":2424,"length":3,"style":"BOLD"},{"offset":2516,"length":1,"style":"BOLD"},{"offset":2518,"length":4,"style":"BOLD"},{"offset":2575,"length":1,"style":"BOLD"},{"offset":2577,"length":8,"style":"BOLD"},{"offset":2591,"length":2,"style":"BOLD"},{"offset":2600,"length":2,"style":"BOLD"},{"offset":2626,"length":1,"style":"BOLD"},{"offset":2628,"length":4,"style":"BOLD"},{"offset":2640,"length":3,"style":"BOLD"},{"offset":2694,"length":2,"style":"BOLD"},{"offset":2878,"length":1,"style":"BOLD"},{"offset":2999,"length":1,"style":"BOLD"},{"offset":3001,"length":4,"style":"BOLD"},{"offset":3026,"length":3,"style":"BOLD"},{"offset":3080,"length":2,"style":"BOLD"},{"offset":3090,"length":2,"style":"BOLD"},{"offset":3117,"length":1,"style":"BOLD"},{"offset":3120,"length":4,"style":"BOLD"},{"offset":3251,"length":1,"style":"BOLD"},{"offset":3254,"length":4,"style":"BOLD"},{"offset":3360,"length":1,"style":"BOLD"},{"offset":3362,"length":8,"style":"BOLD"},{"offset":3395,"length":3,"style":"BOLD"},{"offset":3507,"length":2,"style":"BOLD"},{"offset":3667,"length":2,"style":"BOLD"},{"offset":3691,"length":1,"style":"BOLD"},{"offset":3693,"length":5,"style":"BOLD"},{"offset":3700,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{},"allow_comments":true},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":5,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":785,"position":7,"new_position":7,"published_attributes":{"type":"slide","answers":[],"title":"Step 6: Creating ViewModel","body":null,"serialized_body":"\u003cp\u003eThe next step is to create a ViewModel for our Activity. It will be responsible for fetching a city from our repository and displaying it on the device screen. We will implement it using \u003cstrong\u003eKotlin Flow\u003c/strong\u003e as it\u0026#x27;s now the best choice with ViewModels. Let\u0026#x27;s start with adding required dependency:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edependencies {\n    ...\n    \u003c/span\u003eimplementation \u0026#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.1\u0026#x27;\n    testImplementation \u0026#x27;app.cash.turbine:turbine:0.7.0\u0026#x27;\u003cspan\u003e\n    ...\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first one adds support for coroutines to the ViewModel class and the second one is a handy library for testing \u003cstrong\u003eKotlin Flows, \u003c/strong\u003eas the coroutines library doesn\u0026#x27;t offer a dedicated test operators for Hot Flows\u003cstrong\u003e.\n\n\u003c/strong\u003eThen create a ViewModel class:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesViewModel(\n    private val repository: CitiesRepository\n): ViewModel() {\n    private val cityStateFlow = \u003cem\u003eMutableStateFlow\u003c/em\u003e(\u0026quot;\u0026quot;)\n\n    fun findCity(latitude: String, longitude: String) {\n\n    }\n\n    fun cityName(): Flow\u0026lt;CityState\u0026gt; = cityStateFlow\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLike always, start with creating a test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesViewModelTest {\n    private val latitude = \u0026quot;1.0\u0026quot;\n    private val longitude = \u0026quot;2.0\u0026quot;\n    private val cityName = \u0026quot;London\u0026quot;\n\n    private val repository = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CitiesRepository\u0026gt;()\n\n    @Test\nfun `cityStateFlow should emit proper city result after calling findCity`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\n\u003c/strong\u003e    // given\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        repository.getCityName(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n\n    val viewModel = createViewModel()\n\n    viewModel.cityName().test \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eviewModel.findCity(latitude, longitude)\n\n        \u003cem\u003eassertEquals\u003c/em\u003e(\u0026quot;\u0026quot;, awaitItem())\n        \u003cem\u003eassertEquals\u003c/em\u003e(cityName, awaitItem())\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eprivate fun createViewModel() = \n        CitiesViewModel(repository)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003etest\u003c/strong\u003e operator comes from the Turbine library and allows to make assertions on the values emitted by the Flow under test.\n\u003cstrong\u003eawaitItem()\u003c/strong\u003e is a method available inside this lambda and it suspends until the item is available.\nSince the Stat Flow emits empty string as a first value, we first consume this one and then we get the proper item from the repository.\nFor more available operators please see the \u003ca href=\"https://github.com/cashapp/turbine\"\u003eTurbine Readme\u003c/a\u003e.\nOne more important thing to remember is that the subscription to the Flow must happen before any emission trigger, so the \u003cstrong\u003efindCity\u003c/strong\u003e method (or any other) must be invoked inside the \u003cstrong\u003etest\u003c/strong\u003e operator.\u003c/p\u003e\u003cp\u003eOf course this test fails at this point and the simplest way to fix it, is to emit an item received from the repository:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003efun findCity(latitude: String, longitude: String) {\n    \u003cem\u003eviewModelScope\u003c/em\u003e.\u003cem\u003elaunch \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003ecityStateFlow.emit(\n            repository.getCityName(latitude, longitude)\n        )\n    \u003cstrong\u003e}\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can run this test now, however it will still fail, because \u003cstrong\u003eviewModelScope\u003c/strong\u003e uses a hardcoded \u003cstrong\u003eDispatchers.Main.immediate\u003c/strong\u003e under the hood and it doesn\u0026#x27;t work in tests out-of-the-box. \nWe need to replace it with a \u003cstrong\u003eTestDispatcher\u003c/strong\u003e. Hopefully \u003cstrong\u003ecoroutines-test \u003c/strong\u003elibrary gives us a handy global methods to handle it:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate val testDispatcher = \u003cem\u003eStandardTestDispatcher\u003c/em\u003e()\n\n@Before\nfun setup() {\n    Dispatchers.\u003cem\u003esetMain\u003c/em\u003e(testDispatcher)\n}\n\n@After\nfun clear() {\n    Dispatchers.\u003cem\u003eresetMain\u003c/em\u003e()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun test again. It should pass.\u003c/p\u003e\u003cp\u003eThis code works well, but it doesn\u0026#x27;t take any request errors into consideration. As mentioned before, coroutines signal errors by throwing exceptions, so we must prepare our ViewModel to handle those exceptions.\nA very common way to do it is to create a class that can represent possible response states, like Idle, Loading, Success and Failure that can be further translated into user-understandable messages. An ideal tool for it is a \u003cstrong\u003esealed class\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003esealed class CityState {\n    object Idle : CityState()\n    data class Success(\n        val cityName: String?\n    ) : CityState()\n    data class Failure(\n        val error: Throwable\n    ) : CityState()\n    object Loading : CityState()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow the Flow and the \u003cstrong\u003efindCity\u003c/strong\u003e method must be modified to accept new type of data:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate val cityStateFlow = \n    \u003cem\u003eMutableStateFlow\u003c/em\u003e\u0026lt;CityState\u0026gt;(CityState.Idle)\n\nfun findCity(latitude: String, longitude: String) {\n    \u003cem\u003eviewModelScope\u003c/em\u003e.\u003cem\u003elaunch \u003c/em\u003e\u003cstrong\u003e{\n\u003c/strong\u003e        cityStateFlow.emit(CityState.Loading)\n\u003cstrong\u003e        \u003c/strong\u003eval state = repository\n            .\u003cem\u003erunCatching \u003c/em\u003e\u003cstrong\u003e{\n\u003c/strong\u003e                \u003cstrong\u003e \u003c/strong\u003egetCityName(latitude, longitude)\n            \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e.\u003cem\u003efold\u003c/em\u003e(\n                onSuccess = CityState::Success,\n                onFailure = CityState::Failure\n            )\n        cityStateFlow.emit(state)\n    \u003cstrong\u003e}\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince \u003cstrong\u003eStateFlow\u003c/strong\u003e requires an initial value, we first emit \u003cstrong\u003eIdle\u003c/strong\u003e state, because nothing should happen before the \u003cstrong\u003efindCity\u003c/strong\u003e method is called. After calling it, we emit \u003cstrong\u003eLoading\u003c/strong\u003e state to show the progress bar and then we wait for the response.\nInstead of using a regular \u003cstrong\u003etry-catch\u003c/strong\u003e block, we can use the \u003cstrong\u003ekotlin.Result\u003c/strong\u003e API to do it in a more functional way.\u003c/p\u003e\u003cp\u003eThe test should be modified as well:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `cityStateFlow should emit Idle, Loading and Success states when request is successful`() =\n    \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            repository.getCityName(latitude, longitude)         \n        \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n        val viewModel = createViewModel()\n\n        viewModel.cityName().test \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003eviewModel.findCity(latitude, longitude)\n\n            \u003cem\u003eassertEquals\u003c/em\u003e(CityState.Idle, awaitItem())\n            \u003cem\u003eassertEquals\u003c/em\u003e(\n                CityState.Loading,\n                awaitItem()\n            )\n            \u003cem\u003eassertEquals\u003c/em\u003e(\n                CityState.Success(cityName),             \n                awaitItem()\n            )\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe should also ensure that a \u003cstrong\u003eFailure\u003c/strong\u003e state is emitted in case of a failed response:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `cityStateFlow should emit Idle, Loading and Failure states when request fails`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eval error = RuntimeException()\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        repository.getCityName(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003eanswers \u003cstrong\u003e{ \u003c/strong\u003ethrow error \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eval viewModel = createViewModel()\n\n    viewModel.cityName().test \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eviewModel.findCity(latitude, longitude)\n\n        \u003cem\u003eassertEquals\u003c/em\u003e(CityState.Idle, awaitItem())\n        \u003cem\u003eassertEquals\u003c/em\u003e(CityState.Loading, awaitItem())\n        \u003cem\u003eassertEquals\u003c/em\u003e(\n            CityState.Failure(error),\n            awaitItem()\n        )\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003c/p\u003e","structured_body":{"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://github.com/cashapp/turbine","text":"Turbine Readme"}}},"blocks":[{"key":"47rp7","text":"The next step is to create a ViewModel for our Activity. It will be responsible for fetching a city from our repository and displaying it on the device screen. We will implement it using Kotlin Flow as it's now the best choice with ViewModels. Let's start with adding required dependency:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":187,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5862q","text":"dependencies {\n    ...\n    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.1'\n    testImplementation 'app.cash.turbine:turbine:0.7.0'\n    ...\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":27,"style":"CODE"},{"offset":148,"length":10,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"bufr7","text":"The first one adds support for coroutines to the ViewModel class and the second one is a handy library for testing Kotlin Flows, as the coroutines library doesn't offer a dedicated test operators for Hot Flows.\n\nThen create a ViewModel class:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":115,"length":14,"style":"BOLD"},{"offset":209,"length":3,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"25q91","text":"class CitiesViewModel(\n    private val repository: CitiesRepository\n): ViewModel() {\n    private val cityStateFlow = MutableStateFlow(\"\")\n\n    fun findCity(latitude: String, longitude: String) {\n\n    }\n\n    fun cityName(): Flow\u003cCityState\u003e = cityStateFlow\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":117,"length":16,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"458g5","text":"Like always, start with creating a test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7cu7m","text":"class CitiesViewModelTest {\n    private val latitude = \"1.0\"\n    private val longitude = \"2.0\"\n    private val cityName = \"London\"\n\n    private val repository = mockk\u003cCitiesRepository\u003e()\n\n    @Test\nfun `cityStateFlow should emit proper city result after calling findCity`() = runTest {\n    // given\n    coEvery { \n        repository.getCityName(latitude, longitude) \n    } returns cityName\n\n    val viewModel = createViewModel()\n\n    viewModel.cityName().test {\n        viewModel.findCity(latitude, longitude)\n\n        assertEquals(\"\", awaitItem())\n        assertEquals(cityName, awaitItem())\n    }\n}\n\n    private fun createViewModel() = \n        CitiesViewModel(repository)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":161,"length":5,"style":"ITALIC"},{"offset":276,"length":8,"style":"ITALIC"},{"offset":303,"length":8,"style":"ITALIC"},{"offset":519,"length":12,"style":"ITALIC"},{"offset":557,"length":12,"style":"ITALIC"},{"offset":284,"length":2,"style":"BOLD"},{"offset":299,"length":4,"style":"BOLD"},{"offset":311,"length":3,"style":"BOLD"},{"offset":371,"length":2,"style":"BOLD"},{"offset":460,"length":1,"style":"BOLD"},{"offset":462,"length":8,"style":"BOLD"},{"offset":597,"length":1,"style":"BOLD"},{"offset":599,"length":1,"style":"BOLD"},{"offset":602,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7lgr0","text":"The test operator comes from the Turbine library and allows to make assertions on the values emitted by the Flow under test.\nawaitItem() is a method available inside this lambda and it suspends until the item is available.\nSince the Stat Flow emits empty string as a first value, we first consume this one and then we get the proper item from the repository.\nFor more available operators please see the Turbine Readme.\nOne more important thing to remember is that the subscription to the Flow must happen before any emission trigger, so the findCity method (or any other) must be invoked inside the test operator.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":4,"style":"BOLD"},{"offset":125,"length":11,"style":"BOLD"},{"offset":541,"length":8,"style":"BOLD"},{"offset":599,"length":4,"style":"BOLD"}],"entityRanges":[{"offset":403,"length":14,"key":0}],"data":{}},{"key":"1093p","text":"Of course this test fails at this point and the simplest way to fix it, is to emit an item received from the repository:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"boktb","text":"fun findCity(latitude: String, longitude: String) {\n    viewModelScope.launch {\n        cityStateFlow.emit(\n            repository.getCityName(latitude, longitude)\n        )\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":56,"length":14,"style":"ITALIC"},{"offset":71,"length":7,"style":"ITALIC"},{"offset":78,"length":1,"style":"BOLD"},{"offset":80,"length":8,"style":"BOLD"},{"offset":178,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1vs89","text":"You can run this test now, however it will still fail, because viewModelScope uses a hardcoded Dispatchers.Main.immediate under the hood and it doesn't work in tests out-of-the-box. \nWe need to replace it with a TestDispatcher. Hopefully coroutines-test library gives us a handy global methods to handle it:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":63,"length":14,"style":"BOLD"},{"offset":95,"length":26,"style":"BOLD"},{"offset":212,"length":14,"style":"BOLD"},{"offset":238,"length":16,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5bla9","text":"private val testDispatcher = StandardTestDispatcher()\n\n@Before\nfun setup() {\n    Dispatchers.setMain(testDispatcher)\n}\n\n@After\nfun clear() {\n    Dispatchers.resetMain()\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":29,"length":22,"style":"ITALIC"},{"offset":93,"length":7,"style":"ITALIC"},{"offset":157,"length":9,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"bbam1","text":"Run test again. It should pass.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ikmn","text":"This code works well, but it doesn't take any request errors into consideration. As mentioned before, coroutines signal errors by throwing exceptions, so we must prepare our ViewModel to handle those exceptions.\nA very common way to do it is to create a class that can represent possible response states, like Idle, Loading, Success and Failure that can be further translated into user-understandable messages. An ideal tool for it is a sealed class:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":437,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3mhpa","text":"sealed class CityState {\n    object Idle : CityState()\n    data class Success(\n        val cityName: String?\n    ) : CityState()\n    data class Failure(\n        val error: Throwable\n    ) : CityState()\n    object Loading : CityState()\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"85rdn","text":"Now the Flow and the findCity method must be modified to accept new type of data:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":21,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"28jpb","text":"private val cityStateFlow = \n    MutableStateFlow\u003cCityState\u003e(CityState.Idle)\n\nfun findCity(latitude: String, longitude: String) {\n    viewModelScope.launch {\n        cityStateFlow.emit(CityState.Loading)\n        val state = repository\n            .runCatching {\n                 getCityName(latitude, longitude)\n            }\n            .fold(\n                onSuccess = CityState::Success,\n                onFailure = CityState::Failure\n            )\n        cityStateFlow.emit(state)\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":33,"length":16,"style":"ITALIC"},{"offset":134,"length":14,"style":"ITALIC"},{"offset":149,"length":7,"style":"ITALIC"},{"offset":248,"length":12,"style":"ITALIC"},{"offset":339,"length":4,"style":"ITALIC"},{"offset":156,"length":2,"style":"BOLD"},{"offset":204,"length":8,"style":"BOLD"},{"offset":260,"length":2,"style":"BOLD"},{"offset":278,"length":1,"style":"BOLD"},{"offset":324,"length":1,"style":"BOLD"},{"offset":326,"length":12,"style":"BOLD"},{"offset":492,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dp2vt","text":"Since StateFlow requires an initial value, we first emit Idle state, because nothing should happen before the findCity method is called. After calling it, we emit Loading state to show the progress bar and then we wait for the response.\nInstead of using a regular try-catch block, we can use the kotlin.Result API to do it in a more functional way.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":6,"length":9,"style":"BOLD"},{"offset":57,"length":4,"style":"BOLD"},{"offset":110,"length":8,"style":"BOLD"},{"offset":163,"length":7,"style":"BOLD"},{"offset":264,"length":9,"style":"BOLD"},{"offset":296,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bjr2g","text":"The test should be modified as well:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4s79c","text":"@Test\nfun `cityStateFlow should emit Idle, Loading and Success states when request is successful`() =\n    runTest {\n        coEvery { \n            repository.getCityName(latitude, longitude)         \n        } returns cityName\n        val viewModel = createViewModel()\n\n        viewModel.cityName().test {\n            viewModel.findCity(latitude, longitude)\n\n            assertEquals(CityState.Idle, awaitItem())\n            assertEquals(\n                CityState.Loading,\n                awaitItem()\n            )\n            assertEquals(\n                CityState.Success(cityName),             \n                awaitItem()\n            )\n        }\n    }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":106,"length":8,"style":"ITALIC"},{"offset":124,"length":8,"style":"ITALIC"},{"offset":371,"length":12,"style":"ITALIC"},{"offset":425,"length":12,"style":"ITALIC"},{"offset":528,"length":12,"style":"ITALIC"},{"offset":114,"length":1,"style":"BOLD"},{"offset":116,"length":8,"style":"BOLD"},{"offset":132,"length":3,"style":"BOLD"},{"offset":208,"length":2,"style":"BOLD"},{"offset":304,"length":1,"style":"BOLD"},{"offset":306,"length":12,"style":"BOLD"},{"offset":650,"length":1,"style":"BOLD"},{"offset":652,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8257i","text":"We should also ensure that a Failure state is emitted in case of a failed response:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":29,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"79tnd","text":"@Test\nfun `cityStateFlow should emit Idle, Loading and Failure states when request fails`() = runTest {\n    val error = RuntimeException()\n    coEvery { \n        repository.getCityName(latitude, longitude) \n    } answers { throw error }\n    val viewModel = createViewModel()\n\n    viewModel.cityName().test {\n        viewModel.findCity(latitude, longitude)\n\n        assertEquals(CityState.Idle, awaitItem())\n        assertEquals(CityState.Loading, awaitItem())\n        assertEquals(\n            CityState.Failure(error),\n            awaitItem()\n        )\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":94,"length":8,"style":"ITALIC"},{"offset":143,"length":8,"style":"ITALIC"},{"offset":365,"length":12,"style":"ITALIC"},{"offset":415,"length":12,"style":"ITALIC"},{"offset":468,"length":12,"style":"ITALIC"},{"offset":102,"length":1,"style":"BOLD"},{"offset":104,"length":4,"style":"BOLD"},{"offset":151,"length":3,"style":"BOLD"},{"offset":211,"length":2,"style":"BOLD"},{"offset":221,"length":2,"style":"BOLD"},{"offset":235,"length":1,"style":"BOLD"},{"offset":237,"length":4,"style":"BOLD"},{"offset":306,"length":1,"style":"BOLD"},{"offset":308,"length":8,"style":"BOLD"},{"offset":558,"length":1,"style":"BOLD"},{"offset":560,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8biqp","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 6: Creating ViewModel","body":null,"serialized_body":"\u003cp\u003eThe next step is to create a ViewModel for our Activity. It will be responsible for fetching a city from our repository and displaying it on the device screen. We will implement it using \u003cstrong\u003eKotlin Flow\u003c/strong\u003e as it\u0026#x27;s now the best choice with ViewModels. Let\u0026#x27;s start with adding required dependency:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edependencies {\n    ...\n    \u003c/span\u003eimplementation \u0026#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.1\u0026#x27;\n    testImplementation \u0026#x27;app.cash.turbine:turbine:0.7.0\u0026#x27;\u003cspan\u003e\n    ...\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first one adds support for coroutines to the ViewModel class and the second one is a handy library for testing \u003cstrong\u003eKotlin Flows, \u003c/strong\u003eas the coroutines library doesn\u0026#x27;t offer a dedicated test operators for Hot Flows\u003cstrong\u003e.\n\n\u003c/strong\u003eThen create a ViewModel class:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesViewModel(\n    private val repository: CitiesRepository\n): ViewModel() {\n    private val cityStateFlow = \u003cem\u003eMutableStateFlow\u003c/em\u003e(\u0026quot;\u0026quot;)\n\n    fun findCity(latitude: String, longitude: String) {\n\n    }\n\n    fun cityName(): Flow\u0026lt;CityState\u0026gt; = cityStateFlow\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLike always, start with creating a test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesViewModelTest {\n    private val latitude = \u0026quot;1.0\u0026quot;\n    private val longitude = \u0026quot;2.0\u0026quot;\n    private val cityName = \u0026quot;London\u0026quot;\n\n    private val repository = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CitiesRepository\u0026gt;()\n\n    @Test\nfun `cityStateFlow should emit proper city result after calling findCity`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\n\u003c/strong\u003e    // given\n\u003cstrong\u003e    \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        repository.getCityName(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n\n    val viewModel = createViewModel()\n\n    viewModel.cityName().test \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eviewModel.findCity(latitude, longitude)\n\n        \u003cem\u003eassertEquals\u003c/em\u003e(\u0026quot;\u0026quot;, awaitItem())\n        \u003cem\u003eassertEquals\u003c/em\u003e(cityName, awaitItem())\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\n\n\u003cstrong\u003e    \u003c/strong\u003eprivate fun createViewModel() = \n        CitiesViewModel(repository)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003etest\u003c/strong\u003e operator comes from the Turbine library and allows to make assertions on the values emitted by the Flow under test.\n\u003cstrong\u003eawaitItem()\u003c/strong\u003e is a method available inside this lambda and it suspends until the item is available.\nSince the Stat Flow emits empty string as a first value, we first consume this one and then we get the proper item from the repository.\nFor more available operators please see the \u003ca href=\"https://github.com/cashapp/turbine\"\u003eTurbine Readme\u003c/a\u003e.\nOne more important thing to remember is that the subscription to the Flow must happen before any emission trigger, so the \u003cstrong\u003efindCity\u003c/strong\u003e method (or any other) must be invoked inside the \u003cstrong\u003etest\u003c/strong\u003e operator.\u003c/p\u003e\u003cp\u003eOf course this test fails at this point and the simplest way to fix it, is to emit an item received from the repository:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003efun findCity(latitude: String, longitude: String) {\n    \u003cem\u003eviewModelScope\u003c/em\u003e.\u003cem\u003elaunch \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003ecityStateFlow.emit(\n            repository.getCityName(latitude, longitude)\n        )\n    \u003cstrong\u003e}\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can run this test now, however it will still fail, because \u003cstrong\u003eviewModelScope\u003c/strong\u003e uses a hardcoded \u003cstrong\u003eDispatchers.Main.immediate\u003c/strong\u003e under the hood and it doesn\u0026#x27;t work in tests out-of-the-box. \nWe need to replace it with a \u003cstrong\u003eTestDispatcher\u003c/strong\u003e. Hopefully \u003cstrong\u003ecoroutines-test \u003c/strong\u003elibrary gives us a handy global methods to handle it:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate val testDispatcher = \u003cem\u003eStandardTestDispatcher\u003c/em\u003e()\n\n@Before\nfun setup() {\n    Dispatchers.\u003cem\u003esetMain\u003c/em\u003e(testDispatcher)\n}\n\n@After\nfun clear() {\n    Dispatchers.\u003cem\u003eresetMain\u003c/em\u003e()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRun test again. It should pass.\u003c/p\u003e\u003cp\u003eThis code works well, but it doesn\u0026#x27;t take any request errors into consideration. As mentioned before, coroutines signal errors by throwing exceptions, so we must prepare our ViewModel to handle those exceptions.\nA very common way to do it is to create a class that can represent possible response states, like Idle, Loading, Success and Failure that can be further translated into user-understandable messages. An ideal tool for it is a \u003cstrong\u003esealed class\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003esealed class CityState {\n    object Idle : CityState()\n    data class Success(\n        val cityName: String?\n    ) : CityState()\n    data class Failure(\n        val error: Throwable\n    ) : CityState()\n    object Loading : CityState()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow the Flow and the \u003cstrong\u003efindCity\u003c/strong\u003e method must be modified to accept new type of data:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate val cityStateFlow = \n    \u003cem\u003eMutableStateFlow\u003c/em\u003e\u0026lt;CityState\u0026gt;(CityState.Idle)\n\nfun findCity(latitude: String, longitude: String) {\n    \u003cem\u003eviewModelScope\u003c/em\u003e.\u003cem\u003elaunch \u003c/em\u003e\u003cstrong\u003e{\n\u003c/strong\u003e        cityStateFlow.emit(CityState.Loading)\n\u003cstrong\u003e        \u003c/strong\u003eval state = repository\n            .\u003cem\u003erunCatching \u003c/em\u003e\u003cstrong\u003e{\n\u003c/strong\u003e                \u003cstrong\u003e \u003c/strong\u003egetCityName(latitude, longitude)\n            \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e.\u003cem\u003efold\u003c/em\u003e(\n                onSuccess = CityState::Success,\n                onFailure = CityState::Failure\n            )\n        cityStateFlow.emit(state)\n    \u003cstrong\u003e}\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince \u003cstrong\u003eStateFlow\u003c/strong\u003e requires an initial value, we first emit \u003cstrong\u003eIdle\u003c/strong\u003e state, because nothing should happen before the \u003cstrong\u003efindCity\u003c/strong\u003e method is called. After calling it, we emit \u003cstrong\u003eLoading\u003c/strong\u003e state to show the progress bar and then we wait for the response.\nInstead of using a regular \u003cstrong\u003etry-catch\u003c/strong\u003e block, we can use the \u003cstrong\u003ekotlin.Result\u003c/strong\u003e API to do it in a more functional way.\u003c/p\u003e\u003cp\u003eThe test should be modified as well:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `cityStateFlow should emit Idle, Loading and Success states when request is successful`() =\n    \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003e\u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e            repository.getCityName(latitude, longitude)         \n        \u003cstrong\u003e} \u003c/strong\u003ereturns cityName\n        val viewModel = createViewModel()\n\n        viewModel.cityName().test \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003eviewModel.findCity(latitude, longitude)\n\n            \u003cem\u003eassertEquals\u003c/em\u003e(CityState.Idle, awaitItem())\n            \u003cem\u003eassertEquals\u003c/em\u003e(\n                CityState.Loading,\n                awaitItem()\n            )\n            \u003cem\u003eassertEquals\u003c/em\u003e(\n                CityState.Success(cityName),             \n                awaitItem()\n            )\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe should also ensure that a \u003cstrong\u003eFailure\u003c/strong\u003e state is emitted in case of a failed response:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `cityStateFlow should emit Idle, Loading and Failure states when request fails`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eval error = RuntimeException()\n    \u003cem\u003ecoEvery \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e        repository.getCityName(latitude, longitude) \n    \u003cstrong\u003e} \u003c/strong\u003eanswers \u003cstrong\u003e{ \u003c/strong\u003ethrow error \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eval viewModel = createViewModel()\n\n    viewModel.cityName().test \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eviewModel.findCity(latitude, longitude)\n\n        \u003cem\u003eassertEquals\u003c/em\u003e(CityState.Idle, awaitItem())\n        \u003cem\u003eassertEquals\u003c/em\u003e(CityState.Loading, awaitItem())\n        \u003cem\u003eassertEquals\u003c/em\u003e(\n            CityState.Failure(error),\n            awaitItem()\n        )\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003c/p\u003e","structured_body":{"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://github.com/cashapp/turbine","text":"Turbine Readme"}}},"blocks":[{"key":"47rp7","text":"The next step is to create a ViewModel for our Activity. It will be responsible for fetching a city from our repository and displaying it on the device screen. We will implement it using Kotlin Flow as it's now the best choice with ViewModels. Let's start with adding required dependency:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":187,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5862q","text":"dependencies {\n    ...\n    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.1'\n    testImplementation 'app.cash.turbine:turbine:0.7.0'\n    ...\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":27,"style":"CODE"},{"offset":148,"length":10,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"bufr7","text":"The first one adds support for coroutines to the ViewModel class and the second one is a handy library for testing Kotlin Flows, as the coroutines library doesn't offer a dedicated test operators for Hot Flows.\n\nThen create a ViewModel class:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":115,"length":14,"style":"BOLD"},{"offset":209,"length":3,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"25q91","text":"class CitiesViewModel(\n    private val repository: CitiesRepository\n): ViewModel() {\n    private val cityStateFlow = MutableStateFlow(\"\")\n\n    fun findCity(latitude: String, longitude: String) {\n\n    }\n\n    fun cityName(): Flow\u003cCityState\u003e = cityStateFlow\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":117,"length":16,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"458g5","text":"Like always, start with creating a test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7cu7m","text":"class CitiesViewModelTest {\n    private val latitude = \"1.0\"\n    private val longitude = \"2.0\"\n    private val cityName = \"London\"\n\n    private val repository = mockk\u003cCitiesRepository\u003e()\n\n    @Test\nfun `cityStateFlow should emit proper city result after calling findCity`() = runTest {\n    // given\n    coEvery { \n        repository.getCityName(latitude, longitude) \n    } returns cityName\n\n    val viewModel = createViewModel()\n\n    viewModel.cityName().test {\n        viewModel.findCity(latitude, longitude)\n\n        assertEquals(\"\", awaitItem())\n        assertEquals(cityName, awaitItem())\n    }\n}\n\n    private fun createViewModel() = \n        CitiesViewModel(repository)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":161,"length":5,"style":"ITALIC"},{"offset":276,"length":8,"style":"ITALIC"},{"offset":303,"length":8,"style":"ITALIC"},{"offset":519,"length":12,"style":"ITALIC"},{"offset":557,"length":12,"style":"ITALIC"},{"offset":284,"length":2,"style":"BOLD"},{"offset":299,"length":4,"style":"BOLD"},{"offset":311,"length":3,"style":"BOLD"},{"offset":371,"length":2,"style":"BOLD"},{"offset":460,"length":1,"style":"BOLD"},{"offset":462,"length":8,"style":"BOLD"},{"offset":597,"length":1,"style":"BOLD"},{"offset":599,"length":1,"style":"BOLD"},{"offset":602,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7lgr0","text":"The test operator comes from the Turbine library and allows to make assertions on the values emitted by the Flow under test.\nawaitItem() is a method available inside this lambda and it suspends until the item is available.\nSince the Stat Flow emits empty string as a first value, we first consume this one and then we get the proper item from the repository.\nFor more available operators please see the Turbine Readme.\nOne more important thing to remember is that the subscription to the Flow must happen before any emission trigger, so the findCity method (or any other) must be invoked inside the test operator.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":4,"style":"BOLD"},{"offset":125,"length":11,"style":"BOLD"},{"offset":541,"length":8,"style":"BOLD"},{"offset":599,"length":4,"style":"BOLD"}],"entityRanges":[{"offset":403,"length":14,"key":0}],"data":{}},{"key":"1093p","text":"Of course this test fails at this point and the simplest way to fix it, is to emit an item received from the repository:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"boktb","text":"fun findCity(latitude: String, longitude: String) {\n    viewModelScope.launch {\n        cityStateFlow.emit(\n            repository.getCityName(latitude, longitude)\n        )\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":56,"length":14,"style":"ITALIC"},{"offset":71,"length":7,"style":"ITALIC"},{"offset":78,"length":1,"style":"BOLD"},{"offset":80,"length":8,"style":"BOLD"},{"offset":178,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1vs89","text":"You can run this test now, however it will still fail, because viewModelScope uses a hardcoded Dispatchers.Main.immediate under the hood and it doesn't work in tests out-of-the-box. \nWe need to replace it with a TestDispatcher. Hopefully coroutines-test library gives us a handy global methods to handle it:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":63,"length":14,"style":"BOLD"},{"offset":95,"length":26,"style":"BOLD"},{"offset":212,"length":14,"style":"BOLD"},{"offset":238,"length":16,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5bla9","text":"private val testDispatcher = StandardTestDispatcher()\n\n@Before\nfun setup() {\n    Dispatchers.setMain(testDispatcher)\n}\n\n@After\nfun clear() {\n    Dispatchers.resetMain()\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":29,"length":22,"style":"ITALIC"},{"offset":93,"length":7,"style":"ITALIC"},{"offset":157,"length":9,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"bbam1","text":"Run test again. It should pass.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ikmn","text":"This code works well, but it doesn't take any request errors into consideration. As mentioned before, coroutines signal errors by throwing exceptions, so we must prepare our ViewModel to handle those exceptions.\nA very common way to do it is to create a class that can represent possible response states, like Idle, Loading, Success and Failure that can be further translated into user-understandable messages. An ideal tool for it is a sealed class:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":437,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3mhpa","text":"sealed class CityState {\n    object Idle : CityState()\n    data class Success(\n        val cityName: String?\n    ) : CityState()\n    data class Failure(\n        val error: Throwable\n    ) : CityState()\n    object Loading : CityState()\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"85rdn","text":"Now the Flow and the findCity method must be modified to accept new type of data:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":21,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"28jpb","text":"private val cityStateFlow = \n    MutableStateFlow\u003cCityState\u003e(CityState.Idle)\n\nfun findCity(latitude: String, longitude: String) {\n    viewModelScope.launch {\n        cityStateFlow.emit(CityState.Loading)\n        val state = repository\n            .runCatching {\n                 getCityName(latitude, longitude)\n            }\n            .fold(\n                onSuccess = CityState::Success,\n                onFailure = CityState::Failure\n            )\n        cityStateFlow.emit(state)\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":33,"length":16,"style":"ITALIC"},{"offset":134,"length":14,"style":"ITALIC"},{"offset":149,"length":7,"style":"ITALIC"},{"offset":248,"length":12,"style":"ITALIC"},{"offset":339,"length":4,"style":"ITALIC"},{"offset":156,"length":2,"style":"BOLD"},{"offset":204,"length":8,"style":"BOLD"},{"offset":260,"length":2,"style":"BOLD"},{"offset":278,"length":1,"style":"BOLD"},{"offset":324,"length":1,"style":"BOLD"},{"offset":326,"length":12,"style":"BOLD"},{"offset":492,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dp2vt","text":"Since StateFlow requires an initial value, we first emit Idle state, because nothing should happen before the findCity method is called. After calling it, we emit Loading state to show the progress bar and then we wait for the response.\nInstead of using a regular try-catch block, we can use the kotlin.Result API to do it in a more functional way.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":6,"length":9,"style":"BOLD"},{"offset":57,"length":4,"style":"BOLD"},{"offset":110,"length":8,"style":"BOLD"},{"offset":163,"length":7,"style":"BOLD"},{"offset":264,"length":9,"style":"BOLD"},{"offset":296,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bjr2g","text":"The test should be modified as well:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4s79c","text":"@Test\nfun `cityStateFlow should emit Idle, Loading and Success states when request is successful`() =\n    runTest {\n        coEvery { \n            repository.getCityName(latitude, longitude)         \n        } returns cityName\n        val viewModel = createViewModel()\n\n        viewModel.cityName().test {\n            viewModel.findCity(latitude, longitude)\n\n            assertEquals(CityState.Idle, awaitItem())\n            assertEquals(\n                CityState.Loading,\n                awaitItem()\n            )\n            assertEquals(\n                CityState.Success(cityName),             \n                awaitItem()\n            )\n        }\n    }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":106,"length":8,"style":"ITALIC"},{"offset":124,"length":8,"style":"ITALIC"},{"offset":371,"length":12,"style":"ITALIC"},{"offset":425,"length":12,"style":"ITALIC"},{"offset":528,"length":12,"style":"ITALIC"},{"offset":114,"length":1,"style":"BOLD"},{"offset":116,"length":8,"style":"BOLD"},{"offset":132,"length":3,"style":"BOLD"},{"offset":208,"length":2,"style":"BOLD"},{"offset":304,"length":1,"style":"BOLD"},{"offset":306,"length":12,"style":"BOLD"},{"offset":650,"length":1,"style":"BOLD"},{"offset":652,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8257i","text":"We should also ensure that a Failure state is emitted in case of a failed response:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":29,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"79tnd","text":"@Test\nfun `cityStateFlow should emit Idle, Loading and Failure states when request fails`() = runTest {\n    val error = RuntimeException()\n    coEvery { \n        repository.getCityName(latitude, longitude) \n    } answers { throw error }\n    val viewModel = createViewModel()\n\n    viewModel.cityName().test {\n        viewModel.findCity(latitude, longitude)\n\n        assertEquals(CityState.Idle, awaitItem())\n        assertEquals(CityState.Loading, awaitItem())\n        assertEquals(\n            CityState.Failure(error),\n            awaitItem()\n        )\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":94,"length":8,"style":"ITALIC"},{"offset":143,"length":8,"style":"ITALIC"},{"offset":365,"length":12,"style":"ITALIC"},{"offset":415,"length":12,"style":"ITALIC"},{"offset":468,"length":12,"style":"ITALIC"},{"offset":102,"length":1,"style":"BOLD"},{"offset":104,"length":4,"style":"BOLD"},{"offset":151,"length":3,"style":"BOLD"},{"offset":211,"length":2,"style":"BOLD"},{"offset":221,"length":2,"style":"BOLD"},{"offset":235,"length":1,"style":"BOLD"},{"offset":237,"length":4,"style":"BOLD"},{"offset":306,"length":1,"style":"BOLD"},{"offset":308,"length":8,"style":"BOLD"},{"offset":558,"length":1,"style":"BOLD"},{"offset":560,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8biqp","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":3,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":2610,"position":8,"new_position":8,"published_attributes":{"type":"slide","answers":[],"title":"Step 7: Setting up the DI","body":null,"serialized_body":"\u003cp\u003eIn order to test the Activity and perform the acceptance test, we need to connect the pieces of code we created using a Dependency Injection. At the time of writing this codelab, the most popular solution is \u003cstrong\u003eHilt\u003c/strong\u003e library. It is a build-up over Dagger 2 library, which is adjusted for easier use on Android. To add this to our project we first need to have this block in the top-level \u003cstrong\u003ebuild.gradle\u003c/strong\u003e file, before the \u003cstrong\u003eplugins\u003c/strong\u003e block:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003ebuildscript \u003cstrong\u003e{\u003c/strong\u003e  \n    repositories \u003cstrong\u003e{\u003c/strong\u003e \n        google()\n    \u003cstrong\u003e}\u003c/strong\u003e  \n    dependencies \u003cstrong\u003e{\u003c/strong\u003e  \n        classpath \u0026#x27;com.google.dagger:hilt-android-gradle-plugin:2.40.5\u0026#x27;     \n    \u003cstrong\u003e}\n}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we need to add those lines to the app-level \u003cstrong\u003egradle\u003c/strong\u003e file:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eplugins \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    ...\u003c/strong\u003e\n    id \u0026#x27;dagger.hilt.android.plugin\u0026#x27;\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edependencies {\n    ...\n\u003c/span\u003e    def hilt_version = \u0026quot;2.40.5\u0026quot;\n    implementation \u0026#x27;androidx.activity:activity-ktx:1.4.0\u0026#x27;\u003cspan\u003e\n    \u003c/span\u003eimplementation \u0026quot;com.google.dagger:hilt-android:$hilt_version\u0026quot;\n    kapt \u0026quot;com.google.dagger:hilt-compiler:$hilt_version\u0026quot;\n    ...\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs usually with Hilt, we start by creating a class extending Android \u003cstrong\u003eApplication\u003c/strong\u003e class and annotate it with \u003cstrong\u003e@HiltAndroidApp\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltAndroidApp\nclass App : Application()\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe also need to inform the \u003cstrong\u003emanifest file\u003c/strong\u003e about this change:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u0026lt;uses-permission android:name=\u0026quot;android.permission.INTERNET\u0026quot; /\u0026gt;\n\n\u0026lt;application\n    android:name=\u0026quot;.App\u0026quot;\n    ...\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we should create modules under \u003cstrong\u003edi\u003c/strong\u003e package that will provide the required Retrofit and Room dependencies:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkConfigModule {\n    private const val BASE_URL = \n        \u0026quot;https://api.postcodes.io\u0026quot;\n\n    @Provides\n    fun provideBaseUrl(): HttpUrl =         \n        BASE_URL.\u003cem\u003etoHttpUrl\u003c/em\u003e()\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    fun provideOkHttpClient(): OkHttpClient = \n        OkHttpClient.Builder().build()\n\n    @Provides\n    fun provideMoshi(): Moshi = Moshi.Builder()\n        .add(KotlinJsonAdapterFactory())\n        .build()\n\n    @Provides\n    fun provideRetrofit(\n        okHttpClient: OkHttpClient,\n        moshi: Moshi,\n        baseUrl: HttpUrl\n    ): Retrofit =\n        Retrofit.Builder().client(okHttpClient)\n            .addConverterFactory(\n                MoshiConverterFactory.create(moshi)\n            )\n            .baseUrl(baseUrl)\n            .build()\n\n    @Provides\n    @Singleton\n    fun provideCityService(\n        retrofit: Retrofit\n    ): FindCityService = retrofit.\u003cem\u003ecreate\u003c/em\u003e()\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n    @Provides\n    @Singleton\n    fun provideCitiesDatabase(\n        @ApplicationContext appContext: Context\n    ): CitiesDatabase =\n        Room.databaseBuilder(\n            appContext,\n            CitiesDatabase::class.\u003cem\u003ejava\u003c/em\u003e, \n            \u0026quot;cities\u0026quot;\n        ).build()\n\n    @Provides\n    @Singleton\n    fun provideCitiesDao(database: CitiesDatabase) = \n        database.citiesDao()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe separate \u003cstrong\u003eNetworkConfigModule\u003c/strong\u003e was introduced, so that the baseUrl can later be easily replaced in tests.\u003c/p\u003e\u003cp\u003eNext we must annotate all the classes created by us with \u003cstrong\u003e@Inject\u003c/strong\u003e annotations:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepository @Inject constructor(\n    ...\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltViewModel\nclass CityViewModel @Inject constructor(\n    ...\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe last step is to add the \u003cstrong\u003e@AndroidEntryPoint\u003c/strong\u003e annotation to our \u003cstrong\u003eMainActivity\u003c/strong\u003e and inject the \u003cstrong\u003eCitiesViewModel\u003c/strong\u003e there:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n   private val viewModel by \u003cem\u003eviewModels\u003c/em\u003e\u0026lt;CitiesViewModel\u0026gt;()\n   ...\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe project should now build without any problems.\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"2jiev","text":"In order to test the Activity and perform the acceptance test, we need to connect the pieces of code we created using a Dependency Injection. At the time of writing this codelab, the most popular solution is Hilt library. It is a build-up over Dagger 2 library, which is adjusted for easier use on Android. To add this to our project we first need to have this block in the top-level build.gradle file, before the plugins block:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":208,"length":4,"style":"BOLD"},{"offset":384,"length":12,"style":"BOLD"},{"offset":414,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"484kv","text":"buildscript {  \n    repositories { \n        google()\n    }  \n    dependencies {  \n        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.40.5'     \n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":12,"length":1,"style":"BOLD"},{"offset":33,"length":1,"style":"BOLD"},{"offset":57,"length":1,"style":"BOLD"},{"offset":78,"length":1,"style":"BOLD"},{"offset":163,"length":3,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4pp4v","text":"Then we need to add those lines to the app-level gradle file:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":49,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2dfep","text":"plugins {\n    ...\n    id 'dagger.hilt.android.plugin'\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":8,"length":1,"style":"BOLD"},{"offset":10,"length":7,"style":"BOLD"},{"offset":54,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2jc8o","text":"dependencies {\n    ...\n    def hilt_version = \"2.40.5\"\n    implementation 'androidx.activity:activity-ktx:1.4.0'\n    implementation \"com.google.dagger:hilt-android:$hilt_version\"\n    kapt \"com.google.dagger:hilt-compiler:$hilt_version\"\n    ...\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"CODE"},{"offset":112,"length":5,"style":"CODE"},{"offset":243,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"5v0uk","text":"As usually with Hilt, we start by creating a class extending Android Application class and annotate it with @HiltAndroidApp:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":69,"length":11,"style":"BOLD"},{"offset":108,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"98nqi","text":"@HiltAndroidApp\nclass App : Application()","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b0fma","text":"We also need to inform the manifest file about this change:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":27,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"flet3","text":"\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n\n\u003capplication\n    android:name=\".App\"\n    ...","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"48ltd","text":"Then we should create modules under di package that will provide the required Retrofit and Room dependencies:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":36,"length":2,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"e0r30","text":"@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkConfigModule {\n    private const val BASE_URL = \n        \"https://api.postcodes.io\"\n\n    @Provides\n    fun provideBaseUrl(): HttpUrl =         \n        BASE_URL.toHttpUrl()\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":221,"length":9,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"7jg6k","text":"@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    fun provideOkHttpClient(): OkHttpClient = \n        OkHttpClient.Builder().build()\n\n    @Provides\n    fun provideMoshi(): Moshi = Moshi.Builder()\n        .add(KotlinJsonAdapterFactory())\n        .build()\n\n    @Provides\n    fun provideRetrofit(\n        okHttpClient: OkHttpClient,\n        moshi: Moshi,\n        baseUrl: HttpUrl\n    ): Retrofit =\n        Retrofit.Builder().client(okHttpClient)\n            .addConverterFactory(\n                MoshiConverterFactory.create(moshi)\n            )\n            .baseUrl(baseUrl)\n            .build()\n\n    @Provides\n    @Singleton\n    fun provideCityService(\n        retrofit: Retrofit\n    ): FindCityService = retrofit.create()\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":749,"length":6,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"8jl4p","text":"@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n    @Provides\n    @Singleton\n    fun provideCitiesDatabase(\n        @ApplicationContext appContext: Context\n    ): CitiesDatabase =\n        Room.databaseBuilder(\n            appContext,\n            CitiesDatabase::class.java, \n            \"cities\"\n        ).build()\n\n    @Provides\n    @Singleton\n    fun provideCitiesDao(database: CitiesDatabase) = \n        database.citiesDao()\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":290,"length":4,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"df9m","text":"The separate NetworkConfigModule was introduced, so that the baseUrl can later be easily replaced in tests.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":13,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3cepn","text":"Next we must annotate all the classes created by us with @Inject annotations:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":57,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"e69ff","text":"class CitiesRepository @Inject constructor(\n    ...","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8136m","text":"@HiltViewModel\nclass CityViewModel @Inject constructor(\n    ...","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3r6es","text":"The last step is to add the @AndroidEntryPoint annotation to our MainActivity and inject the CitiesViewModel there:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":28,"length":18,"style":"BOLD"},{"offset":65,"length":12,"style":"BOLD"},{"offset":93,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"d6vo2","text":"@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n   private val viewModel by viewModels\u003cCitiesViewModel\u003e()\n   ...","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":90,"length":10,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"114uq","text":"The project should now build without any problems.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2eibq","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5qi5g","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 7: Setting up the DI","body":null,"serialized_body":"\u003cp\u003eIn order to test the Activity and perform the acceptance test, we need to connect the pieces of code we created using a Dependency Injection. At the time of writing this codelab, the most popular solution is \u003cstrong\u003eHilt\u003c/strong\u003e library. It is a build-up over Dagger 2 library, which is adjusted for easier use on Android. To add this to our project we first need to have this block in the top-level \u003cstrong\u003ebuild.gradle\u003c/strong\u003e file, before the \u003cstrong\u003eplugins\u003c/strong\u003e block:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003ebuildscript \u003cstrong\u003e{\u003c/strong\u003e  \n    repositories \u003cstrong\u003e{\u003c/strong\u003e \n        google()\n    \u003cstrong\u003e}\u003c/strong\u003e  \n    dependencies \u003cstrong\u003e{\u003c/strong\u003e  \n        classpath \u0026#x27;com.google.dagger:hilt-android-gradle-plugin:2.40.5\u0026#x27;     \n    \u003cstrong\u003e}\n}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we need to add those lines to the app-level \u003cstrong\u003egradle\u003c/strong\u003e file:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eplugins \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    ...\u003c/strong\u003e\n    id \u0026#x27;dagger.hilt.android.plugin\u0026#x27;\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edependencies {\n    ...\n\u003c/span\u003e    def hilt_version = \u0026quot;2.40.5\u0026quot;\n    implementation \u0026#x27;androidx.activity:activity-ktx:1.4.0\u0026#x27;\u003cspan\u003e\n    \u003c/span\u003eimplementation \u0026quot;com.google.dagger:hilt-android:$hilt_version\u0026quot;\n    kapt \u0026quot;com.google.dagger:hilt-compiler:$hilt_version\u0026quot;\n    ...\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAs usually with Hilt, we start by creating a class extending Android \u003cstrong\u003eApplication\u003c/strong\u003e class and annotate it with \u003cstrong\u003e@HiltAndroidApp\u003c/strong\u003e:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltAndroidApp\nclass App : Application()\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe also need to inform the \u003cstrong\u003emanifest file\u003c/strong\u003e about this change:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u0026lt;uses-permission android:name=\u0026quot;android.permission.INTERNET\u0026quot; /\u0026gt;\n\n\u0026lt;application\n    android:name=\u0026quot;.App\u0026quot;\n    ...\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we should create modules under \u003cstrong\u003edi\u003c/strong\u003e package that will provide the required Retrofit and Room dependencies:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkConfigModule {\n    private const val BASE_URL = \n        \u0026quot;https://api.postcodes.io\u0026quot;\n\n    @Provides\n    fun provideBaseUrl(): HttpUrl =         \n        BASE_URL.\u003cem\u003etoHttpUrl\u003c/em\u003e()\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    fun provideOkHttpClient(): OkHttpClient = \n        OkHttpClient.Builder().build()\n\n    @Provides\n    fun provideMoshi(): Moshi = Moshi.Builder()\n        .add(KotlinJsonAdapterFactory())\n        .build()\n\n    @Provides\n    fun provideRetrofit(\n        okHttpClient: OkHttpClient,\n        moshi: Moshi,\n        baseUrl: HttpUrl\n    ): Retrofit =\n        Retrofit.Builder().client(okHttpClient)\n            .addConverterFactory(\n                MoshiConverterFactory.create(moshi)\n            )\n            .baseUrl(baseUrl)\n            .build()\n\n    @Provides\n    @Singleton\n    fun provideCityService(\n        retrofit: Retrofit\n    ): FindCityService = retrofit.\u003cem\u003ecreate\u003c/em\u003e()\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n    @Provides\n    @Singleton\n    fun provideCitiesDatabase(\n        @ApplicationContext appContext: Context\n    ): CitiesDatabase =\n        Room.databaseBuilder(\n            appContext,\n            CitiesDatabase::class.\u003cem\u003ejava\u003c/em\u003e, \n            \u0026quot;cities\u0026quot;\n        ).build()\n\n    @Provides\n    @Singleton\n    fun provideCitiesDao(database: CitiesDatabase) = \n        database.citiesDao()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe separate \u003cstrong\u003eNetworkConfigModule\u003c/strong\u003e was introduced, so that the baseUrl can later be easily replaced in tests.\u003c/p\u003e\u003cp\u003eNext we must annotate all the classes created by us with \u003cstrong\u003e@Inject\u003c/strong\u003e annotations:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass CitiesRepository @Inject constructor(\n    ...\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltViewModel\nclass CityViewModel @Inject constructor(\n    ...\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe last step is to add the \u003cstrong\u003e@AndroidEntryPoint\u003c/strong\u003e annotation to our \u003cstrong\u003eMainActivity\u003c/strong\u003e and inject the \u003cstrong\u003eCitiesViewModel\u003c/strong\u003e there:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n   private val viewModel by \u003cem\u003eviewModels\u003c/em\u003e\u0026lt;CitiesViewModel\u0026gt;()\n   ...\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe project should now build without any problems.\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"2jiev","text":"In order to test the Activity and perform the acceptance test, we need to connect the pieces of code we created using a Dependency Injection. At the time of writing this codelab, the most popular solution is Hilt library. It is a build-up over Dagger 2 library, which is adjusted for easier use on Android. To add this to our project we first need to have this block in the top-level build.gradle file, before the plugins block:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":208,"length":4,"style":"BOLD"},{"offset":384,"length":12,"style":"BOLD"},{"offset":414,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"484kv","text":"buildscript {  \n    repositories { \n        google()\n    }  \n    dependencies {  \n        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.40.5'     \n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":12,"length":1,"style":"BOLD"},{"offset":33,"length":1,"style":"BOLD"},{"offset":57,"length":1,"style":"BOLD"},{"offset":78,"length":1,"style":"BOLD"},{"offset":163,"length":3,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4pp4v","text":"Then we need to add those lines to the app-level gradle file:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":49,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2dfep","text":"plugins {\n    ...\n    id 'dagger.hilt.android.plugin'\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":8,"length":1,"style":"BOLD"},{"offset":10,"length":7,"style":"BOLD"},{"offset":54,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2jc8o","text":"dependencies {\n    ...\n    def hilt_version = \"2.40.5\"\n    implementation 'androidx.activity:activity-ktx:1.4.0'\n    implementation \"com.google.dagger:hilt-android:$hilt_version\"\n    kapt \"com.google.dagger:hilt-compiler:$hilt_version\"\n    ...\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":23,"style":"CODE"},{"offset":112,"length":5,"style":"CODE"},{"offset":243,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"5v0uk","text":"As usually with Hilt, we start by creating a class extending Android Application class and annotate it with @HiltAndroidApp:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":69,"length":11,"style":"BOLD"},{"offset":108,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"98nqi","text":"@HiltAndroidApp\nclass App : Application()","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b0fma","text":"We also need to inform the manifest file about this change:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":27,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"flet3","text":"\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n\n\u003capplication\n    android:name=\".App\"\n    ...","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"48ltd","text":"Then we should create modules under di package that will provide the required Retrofit and Room dependencies:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":36,"length":2,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"e0r30","text":"@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkConfigModule {\n    private const val BASE_URL = \n        \"https://api.postcodes.io\"\n\n    @Provides\n    fun provideBaseUrl(): HttpUrl =         \n        BASE_URL.toHttpUrl()\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":221,"length":9,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"7jg6k","text":"@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    fun provideOkHttpClient(): OkHttpClient = \n        OkHttpClient.Builder().build()\n\n    @Provides\n    fun provideMoshi(): Moshi = Moshi.Builder()\n        .add(KotlinJsonAdapterFactory())\n        .build()\n\n    @Provides\n    fun provideRetrofit(\n        okHttpClient: OkHttpClient,\n        moshi: Moshi,\n        baseUrl: HttpUrl\n    ): Retrofit =\n        Retrofit.Builder().client(okHttpClient)\n            .addConverterFactory(\n                MoshiConverterFactory.create(moshi)\n            )\n            .baseUrl(baseUrl)\n            .build()\n\n    @Provides\n    @Singleton\n    fun provideCityService(\n        retrofit: Retrofit\n    ): FindCityService = retrofit.create()\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":749,"length":6,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"8jl4p","text":"@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n    @Provides\n    @Singleton\n    fun provideCitiesDatabase(\n        @ApplicationContext appContext: Context\n    ): CitiesDatabase =\n        Room.databaseBuilder(\n            appContext,\n            CitiesDatabase::class.java, \n            \"cities\"\n        ).build()\n\n    @Provides\n    @Singleton\n    fun provideCitiesDao(database: CitiesDatabase) = \n        database.citiesDao()\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":290,"length":4,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"df9m","text":"The separate NetworkConfigModule was introduced, so that the baseUrl can later be easily replaced in tests.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":13,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3cepn","text":"Next we must annotate all the classes created by us with @Inject annotations:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":57,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"e69ff","text":"class CitiesRepository @Inject constructor(\n    ...","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8136m","text":"@HiltViewModel\nclass CityViewModel @Inject constructor(\n    ...","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3r6es","text":"The last step is to add the @AndroidEntryPoint annotation to our MainActivity and inject the CitiesViewModel there:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":28,"length":18,"style":"BOLD"},{"offset":65,"length":12,"style":"BOLD"},{"offset":93,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"d6vo2","text":"@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n   private val viewModel by viewModels\u003cCitiesViewModel\u003e()\n   ...","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":90,"length":10,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"114uq","text":"The project should now build without any problems.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2eibq","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5qi5g","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2022-04-27T13:54:06.481+02:00","estimated_time":2,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":2611,"position":9,"new_position":9,"published_attributes":{"type":"slide","answers":[],"title":"Step 8: Testing the network layer","body":null,"serialized_body":"\u003cp\u003eWith the DI set up, we can resume the work on testing the network layer.\u003c/p\u003e\u003cp\u003eWe will use Hilt testing features as well as the \u003cstrong\u003eRobolectric\u003c/strong\u003e framework, as it allows to test Android-specific classes without the need of running the test on a device or emulator. We will need it to create the dependency tree and get the network classes from it.\u003c/p\u003e\u003cp\u003eFirst, we need to add the Robolectric dependency:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003etestImplementation \u0026#x27;org.robolectric:robolectric:4.6.1\u0026#x27;\ntestImplementation \u0026quot;com.google.dagger:hilt-android-testing:$hilt_version\u0026quot;\nkaptTest \u0026quot;com.google.dagger:hilt-android-compiler:$hilt_version\u0026quot;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen add those annotations to the test class:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltAndroidTest\n@UninstallModules(NetworkConfigModule::class)\n@RunWith(RobolectricTestRunner::class)\n@Config(\n    sdk = [23], \n    application = HiltTestApplication::class\n)\nclass ApiConfigurationTest {\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first one enables Hilt injection inside this class and the second one removes the real NetworkConfigModule from the dependency tree, so we can replace the \u003cstrong\u003ebaseUrl\u003c/strong\u003e with the url used by the \u003cstrong\u003eMockWebServer\u003c/strong\u003e.\nThen we configure the Robolectric specifying that it should be run using Robolectric test runner and use Android SDK version 23 and use the predefined \u003cstrong\u003eHiltTestApplication\u003c/strong\u003e so it can be a root for the dependency tree.\u003c/p\u003e\u003cp\u003eWe will also need the objets below:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@get:Rule\nval hiltRule = HiltAndroidRule(this)\n\n@BindValue @JvmField\nval baseUrl: HttpUrl = server.url(\u0026quot;/\u0026quot;)\n\n@Inject\nlateinit var moshi: Moshi\n\n@Inject\nlateinit var service: FindCityService\n\n@Before\nfun setup() {\n    hiltRule.inject()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003eHiltAndroidRule \u003c/strong\u003eis a handler for injecting the required fields. \nThe \u003cstrong\u003e@BindValue \u003c/strong\u003eannotation tells Hilt to put this mock server \u003cstrong\u003eHttpUrl\u003c/strong\u003e object inside the dependency tree, so it can be used to create the Retrofit instance (we first had to uninstall the module with a real value, otherwise there would be a dependency duplication).\nThen we can inject the required fields just as in a normal production code.\u003c/p\u003e\u003cp\u003eWith this setup done, we can finish writing the test itself:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `verify findCity api call`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eval latitude = \u0026quot;1.0\u0026quot;\n    val longitude = \u0026quot;2.0\u0026quot;\n    val responseJson = readFile(\u0026quot;response.json\u0026quot;)\n        .\u003cem\u003eorEmpty\u003c/em\u003e()\n\n    val response = MockResponse()\n        .setBody(responseJson)\n        .setResponseCode(200)\n  \n    server.enqueue(response)\n\n    val expectedResponse = moshi\n        .adapter(CityResponse::class.\u003cem\u003ejava\u003c/em\u003e)\n        .fromJson(responseJson)\n\n    val actual = service.findCity(latitude, longitude)\n    \u003cem\u003eassertEquals\u003c/em\u003e(expectedResponse, actual)\n\n    val request = server.takeRequest()\n\n    \u003cem\u003eassertEquals\u003c/em\u003e(\n        \u0026quot;/postcodes?lat=$latitude\u0026amp;lon=$longitude\u0026amp;limit=1\u0026quot;,     \n        request.path\n    )\n    \u003cem\u003eassertEquals\u003c/em\u003e(\u0026quot;GET\u0026quot;, request.method)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUsing Moshi we first parse the JSON passed to the server to compare it with the object returned from the \u003cstrong\u003efindCity\u003c/strong\u003e method. Then we check the actual path of the request and the method type.\u003c/p\u003e\u003cp\u003eCurrently this test fails, because the \u003cstrong\u003eFindCityService\u003c/strong\u003e is still a normal interface without the Retrofit annotations. Let\u0026#x27;s fix it now:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003einterface FindCityService {\n    @GET(\u0026quot;postcodes\u0026quot;)\n    suspend fun findCity(\n        @Query(\u0026quot;lat\u0026quot;) latitude: String,\n        @Query(\u0026quot;lon\u0026quot;) longitude: String,\n        @Query(\u0026quot;limit\u0026quot;) limit: Int = 1\n    ): CityResponse\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\nRun the test again, it should pass now.\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"sk94","text":"With the DI set up, we can resume the work on testing the network layer.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aipk2","text":"We will use Hilt testing features as well as the Robolectric framework, as it allows to test Android-specific classes without the need of running the test on a device or emulator. We will need it to create the dependency tree and get the network classes from it.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":49,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ea3na","text":"First, we need to add the Robolectric dependency:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b4l83","text":"testImplementation 'org.robolectric:robolectric:4.6.1'\ntestImplementation \"com.google.dagger:hilt-android-testing:$hilt_version\"\nkaptTest \"com.google.dagger:hilt-android-compiler:$hilt_version\"","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dromu","text":"Then add those annotations to the test class:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6vc26","text":"@HiltAndroidTest\n@UninstallModules(NetworkConfigModule::class)\n@RunWith(RobolectricTestRunner::class)\n@Config(\n    sdk = [23], \n    application = HiltTestApplication::class\n)\nclass ApiConfigurationTest {","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4uuh0","text":"The first one enables Hilt injection inside this class and the second one removes the real NetworkConfigModule from the dependency tree, so we can replace the baseUrl with the url used by the MockWebServer.\nThen we configure the Robolectric specifying that it should be run using Robolectric test runner and use Android SDK version 23 and use the predefined HiltTestApplication so it can be a root for the dependency tree.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":159,"length":7,"style":"BOLD"},{"offset":192,"length":13,"style":"BOLD"},{"offset":358,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"f0b3a","text":"We will also need the objets below:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dqeco","text":"@get:Rule\nval hiltRule = HiltAndroidRule(this)\n\n@BindValue @JvmField\nval baseUrl: HttpUrl = server.url(\"/\")\n\n@Inject\nlateinit var moshi: Moshi\n\n@Inject\nlateinit var service: FindCityService\n\n@Before\nfun setup() {\n    hiltRule.inject()\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bqn7p","text":"The HiltAndroidRule is a handler for injecting the required fields. \nThe @BindValue annotation tells Hilt to put this mock server HttpUrl object inside the dependency tree, so it can be used to create the Retrofit instance (we first had to uninstall the module with a real value, otherwise there would be a dependency duplication).\nThen we can inject the required fields just as in a normal production code.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":16,"style":"BOLD"},{"offset":73,"length":11,"style":"BOLD"},{"offset":130,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7i1pp","text":"With this setup done, we can finish writing the test itself:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eshua","text":"@Test\nfun `verify findCity api call`() = runTest {\n    val latitude = \"1.0\"\n    val longitude = \"2.0\"\n    val responseJson = readFile(\"response.json\")\n        .orEmpty()\n\n    val response = MockResponse()\n        .setBody(responseJson)\n        .setResponseCode(200)\n  \n    server.enqueue(response)\n\n    val expectedResponse = moshi\n        .adapter(CityResponse::class.java)\n        .fromJson(responseJson)\n\n    val actual = service.findCity(latitude, longitude)\n    assertEquals(expectedResponse, actual)\n\n    val request = server.takeRequest()\n\n    assertEquals(\n        \"/postcodes?lat=$latitude\u0026lon=$longitude\u0026limit=1\",     \n        request.path\n    )\n    assertEquals(\"GET\", request.method)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":41,"length":8,"style":"ITALIC"},{"offset":160,"length":7,"style":"ITALIC"},{"offset":369,"length":4,"style":"ITALIC"},{"offset":467,"length":12,"style":"ITALIC"},{"offset":551,"length":12,"style":"ITALIC"},{"offset":660,"length":12,"style":"ITALIC"},{"offset":49,"length":1,"style":"BOLD"},{"offset":51,"length":4,"style":"BOLD"},{"offset":696,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3fhst","text":"Using Moshi we first parse the JSON passed to the server to compare it with the object returned from the findCity method. Then we check the actual path of the request and the method type.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":105,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9acqu","text":"Currently this test fails, because the FindCityService is still a normal interface without the Retrofit annotations. Let's fix it now:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":39,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"aai00","text":"interface FindCityService {\n    @GET(\"postcodes\")\n    suspend fun findCity(\n        @Query(\"lat\") latitude: String,\n        @Query(\"lon\") longitude: String,\n        @Query(\"limit\") limit: Int = 1\n    ): CityResponse\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2ht6b","text":"\nRun the test again, it should pass now.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 8: Testing the network layer","body":null,"serialized_body":"\u003cp\u003eWith the DI set up, we can resume the work on testing the network layer.\u003c/p\u003e\u003cp\u003eWe will use Hilt testing features as well as the \u003cstrong\u003eRobolectric\u003c/strong\u003e framework, as it allows to test Android-specific classes without the need of running the test on a device or emulator. We will need it to create the dependency tree and get the network classes from it.\u003c/p\u003e\u003cp\u003eFirst, we need to add the Robolectric dependency:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003etestImplementation \u0026#x27;org.robolectric:robolectric:4.6.1\u0026#x27;\ntestImplementation \u0026quot;com.google.dagger:hilt-android-testing:$hilt_version\u0026quot;\nkaptTest \u0026quot;com.google.dagger:hilt-android-compiler:$hilt_version\u0026quot;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen add those annotations to the test class:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltAndroidTest\n@UninstallModules(NetworkConfigModule::class)\n@RunWith(RobolectricTestRunner::class)\n@Config(\n    sdk = [23], \n    application = HiltTestApplication::class\n)\nclass ApiConfigurationTest {\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe first one enables Hilt injection inside this class and the second one removes the real NetworkConfigModule from the dependency tree, so we can replace the \u003cstrong\u003ebaseUrl\u003c/strong\u003e with the url used by the \u003cstrong\u003eMockWebServer\u003c/strong\u003e.\nThen we configure the Robolectric specifying that it should be run using Robolectric test runner and use Android SDK version 23 and use the predefined \u003cstrong\u003eHiltTestApplication\u003c/strong\u003e so it can be a root for the dependency tree.\u003c/p\u003e\u003cp\u003eWe will also need the objets below:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@get:Rule\nval hiltRule = HiltAndroidRule(this)\n\n@BindValue @JvmField\nval baseUrl: HttpUrl = server.url(\u0026quot;/\u0026quot;)\n\n@Inject\nlateinit var moshi: Moshi\n\n@Inject\nlateinit var service: FindCityService\n\n@Before\nfun setup() {\n    hiltRule.inject()\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cstrong\u003eHiltAndroidRule \u003c/strong\u003eis a handler for injecting the required fields. \nThe \u003cstrong\u003e@BindValue \u003c/strong\u003eannotation tells Hilt to put this mock server \u003cstrong\u003eHttpUrl\u003c/strong\u003e object inside the dependency tree, so it can be used to create the Retrofit instance (we first had to uninstall the module with a real value, otherwise there would be a dependency duplication).\nThen we can inject the required fields just as in a normal production code.\u003c/p\u003e\u003cp\u003eWith this setup done, we can finish writing the test itself:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun `verify findCity api call`() = \u003cem\u003erunTest \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eval latitude = \u0026quot;1.0\u0026quot;\n    val longitude = \u0026quot;2.0\u0026quot;\n    val responseJson = readFile(\u0026quot;response.json\u0026quot;)\n        .\u003cem\u003eorEmpty\u003c/em\u003e()\n\n    val response = MockResponse()\n        .setBody(responseJson)\n        .setResponseCode(200)\n  \n    server.enqueue(response)\n\n    val expectedResponse = moshi\n        .adapter(CityResponse::class.\u003cem\u003ejava\u003c/em\u003e)\n        .fromJson(responseJson)\n\n    val actual = service.findCity(latitude, longitude)\n    \u003cem\u003eassertEquals\u003c/em\u003e(expectedResponse, actual)\n\n    val request = server.takeRequest()\n\n    \u003cem\u003eassertEquals\u003c/em\u003e(\n        \u0026quot;/postcodes?lat=$latitude\u0026amp;lon=$longitude\u0026amp;limit=1\u0026quot;,     \n        request.path\n    )\n    \u003cem\u003eassertEquals\u003c/em\u003e(\u0026quot;GET\u0026quot;, request.method)\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUsing Moshi we first parse the JSON passed to the server to compare it with the object returned from the \u003cstrong\u003efindCity\u003c/strong\u003e method. Then we check the actual path of the request and the method type.\u003c/p\u003e\u003cp\u003eCurrently this test fails, because the \u003cstrong\u003eFindCityService\u003c/strong\u003e is still a normal interface without the Retrofit annotations. Let\u0026#x27;s fix it now:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003einterface FindCityService {\n    @GET(\u0026quot;postcodes\u0026quot;)\n    suspend fun findCity(\n        @Query(\u0026quot;lat\u0026quot;) latitude: String,\n        @Query(\u0026quot;lon\u0026quot;) longitude: String,\n        @Query(\u0026quot;limit\u0026quot;) limit: Int = 1\n    ): CityResponse\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\nRun the test again, it should pass now.\u003c/p\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"sk94","text":"With the DI set up, we can resume the work on testing the network layer.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aipk2","text":"We will use Hilt testing features as well as the Robolectric framework, as it allows to test Android-specific classes without the need of running the test on a device or emulator. We will need it to create the dependency tree and get the network classes from it.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":49,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ea3na","text":"First, we need to add the Robolectric dependency:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b4l83","text":"testImplementation 'org.robolectric:robolectric:4.6.1'\ntestImplementation \"com.google.dagger:hilt-android-testing:$hilt_version\"\nkaptTest \"com.google.dagger:hilt-android-compiler:$hilt_version\"","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dromu","text":"Then add those annotations to the test class:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6vc26","text":"@HiltAndroidTest\n@UninstallModules(NetworkConfigModule::class)\n@RunWith(RobolectricTestRunner::class)\n@Config(\n    sdk = [23], \n    application = HiltTestApplication::class\n)\nclass ApiConfigurationTest {","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4uuh0","text":"The first one enables Hilt injection inside this class and the second one removes the real NetworkConfigModule from the dependency tree, so we can replace the baseUrl with the url used by the MockWebServer.\nThen we configure the Robolectric specifying that it should be run using Robolectric test runner and use Android SDK version 23 and use the predefined HiltTestApplication so it can be a root for the dependency tree.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":159,"length":7,"style":"BOLD"},{"offset":192,"length":13,"style":"BOLD"},{"offset":358,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"f0b3a","text":"We will also need the objets below:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dqeco","text":"@get:Rule\nval hiltRule = HiltAndroidRule(this)\n\n@BindValue @JvmField\nval baseUrl: HttpUrl = server.url(\"/\")\n\n@Inject\nlateinit var moshi: Moshi\n\n@Inject\nlateinit var service: FindCityService\n\n@Before\nfun setup() {\n    hiltRule.inject()\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bqn7p","text":"The HiltAndroidRule is a handler for injecting the required fields. \nThe @BindValue annotation tells Hilt to put this mock server HttpUrl object inside the dependency tree, so it can be used to create the Retrofit instance (we first had to uninstall the module with a real value, otherwise there would be a dependency duplication).\nThen we can inject the required fields just as in a normal production code.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":16,"style":"BOLD"},{"offset":73,"length":11,"style":"BOLD"},{"offset":130,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7i1pp","text":"With this setup done, we can finish writing the test itself:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eshua","text":"@Test\nfun `verify findCity api call`() = runTest {\n    val latitude = \"1.0\"\n    val longitude = \"2.0\"\n    val responseJson = readFile(\"response.json\")\n        .orEmpty()\n\n    val response = MockResponse()\n        .setBody(responseJson)\n        .setResponseCode(200)\n  \n    server.enqueue(response)\n\n    val expectedResponse = moshi\n        .adapter(CityResponse::class.java)\n        .fromJson(responseJson)\n\n    val actual = service.findCity(latitude, longitude)\n    assertEquals(expectedResponse, actual)\n\n    val request = server.takeRequest()\n\n    assertEquals(\n        \"/postcodes?lat=$latitude\u0026lon=$longitude\u0026limit=1\",     \n        request.path\n    )\n    assertEquals(\"GET\", request.method)\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":41,"length":8,"style":"ITALIC"},{"offset":160,"length":7,"style":"ITALIC"},{"offset":369,"length":4,"style":"ITALIC"},{"offset":467,"length":12,"style":"ITALIC"},{"offset":551,"length":12,"style":"ITALIC"},{"offset":660,"length":12,"style":"ITALIC"},{"offset":49,"length":1,"style":"BOLD"},{"offset":51,"length":4,"style":"BOLD"},{"offset":696,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3fhst","text":"Using Moshi we first parse the JSON passed to the server to compare it with the object returned from the findCity method. Then we check the actual path of the request and the method type.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":105,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9acqu","text":"Currently this test fails, because the FindCityService is still a normal interface without the Retrofit annotations. Let's fix it now:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":39,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"aai00","text":"interface FindCityService {\n    @GET(\"postcodes\")\n    suspend fun findCity(\n        @Query(\"lat\") latitude: String,\n        @Query(\"lon\") longitude: String,\n        @Query(\"limit\") limit: Int = 1\n    ): CityResponse\n}","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2ht6b","text":"\nRun the test again, it should pass now.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2022-04-27T13:54:06.481+02:00","estimated_time":2,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":786,"position":10,"new_position":10,"published_attributes":{"type":"slide","answers":[],"title":"Step 9: Testing our activity","body":null,"serialized_body":"\u003cp\u003eTo finish, our next step is to test our activity. You can use either \u003cstrong\u003eRobolectric\u003c/strong\u003e or \u003cstrong\u003eEspresso\u003c/strong\u003e, but here we will use Robolectric again. In order to run those test properly we need this additional configuration in the app-level \u003cstrong\u003ebuild.gradle\u003c/strong\u003e file:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003ebuildFeatures \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eviewBinding true\n\u003cstrong\u003e}\u003c/strong\u003e\ntestOptions \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eunitTests \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eincludeAndroidResources true\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\n\u003c/strong\u003edependencies {\n    testImplementation \u0026#x27;androidx.test:core-ktx:1.4.0\u0026#x27;\n}\u003cstrong\u003e \u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFirst closure enables \u003cstrong\u003eViewBinding\u003c/strong\u003e for interacting with views and the second one is required so that Robolectric framework can see Android-specific classes during unit tests (like our MainActivity class). We also need the additional dependency for launching the Activity.\u003c/p\u003e\u003cp\u003eThe next step is creating a base setup for the test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltAndroidTest\n@RunWith(RobolectricTestRunner::class)\n@Config(\n    sdk = [23],\n    application = HiltTestApplication::class\n)\nclass MainActivityTest {\n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n\n    private val latitude = \u0026quot;1.0\u0026quot;\n    private val longitude = \u0026quot;2.0\u0026quot;\n\n    @BindValue\n    @JvmField\n    val viewModel = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CitiesViewModel\u0026gt;(\n        relaxed = true\n    )\n\n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we mark our mock ViewModel with \u003cstrong\u003e@BindValue \u003c/strong\u003eannotation, so that Hilt can replace the real ViewModel instance with this mock for every test in this class.\u003c/p\u003e\u003cp\u003eNow we\u0026#x27;re ready to start testing the Activity. Let\u0026#x27;s start with testing whether a correct method is called after the FIND button is pressed:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun shouldTriggerFindingCityAfterClickingButton() {\n    \u003cem\u003elaunchActivity\u003c/em\u003e\u0026lt;MainActivity\u0026gt;().\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003escenario \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003escenario.onActivity \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            it\u003c/strong\u003e.binding.latInput.setText(latitude)\n            \u003cstrong\u003eit\u003c/strong\u003e.binding.lonInput.setText(longitude)\n            \u003cstrong\u003eit\u003c/strong\u003e.binding.findCityButton.performClick()\n\n            \u003cem\u003everify \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e                viewModel.findCity(latitude, longitude) \n            \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e        }\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cem\u003elaunchActivity \u003c/em\u003emethod is a part of \u003cstrong\u003eandroidx.test\u003c/strong\u003e library and is a convenient way to easily launch a given Activity in a test. It provides an \u003cstrong\u003eActivityScenario \u003c/strong\u003eobject which can access the Activity at different lifecycle states.\u003c/p\u003e\u003cp\u003eLike always, we are going to implement the feature to make this test pass. Open \u003cstrong\u003eMainActivity\u003c/strong\u003e and add the following code:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e...\ninternal val binding by \u003cem\u003elazy \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e    ActivityMainBinding.inflate(\u003cem\u003elayoutInflater\u003c/em\u003e)\n\u003cstrong\u003e}\u003c/strong\u003e\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(binding.root)\n\n    binding.findCityButton.setOnClickListener \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eviewModel.findCity(\n            binding.latInput.\u003cem\u003etext\u003c/em\u003e.toString(),\n            binding.lonInput.\u003cem\u003etext\u003c/em\u003e.toString()\n        )\n    \u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe also need to create another test for ensuring that our TextView will be updated after a value is set to the StateFlow. Add one more test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun shouldSetCityNameWhenCityStateEmitsSuccess() {\n    val cityName = \u0026quot;London\u0026quot;\n    \u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eviewModel.cityName() \u003cstrong\u003e} \u003c/strong\u003ereturns \n        \u003cem\u003eflowOf\u003c/em\u003e(CityState.Success(cityName))\n\n    \u003cem\u003elaunchActivity\u003c/em\u003e\u0026lt;MainActivity\u0026gt;().\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003escenario \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003escenario.onActivity \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e\u003cem\u003eassertEquals\u003c/em\u003e(\n                cityName, \n                \u003cstrong\u003eit\u003c/strong\u003e.binding.cityResult.\u003cem\u003etext\n\u003c/em\u003e            )\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd easily fix it by adding a Flow collector to our Activity:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eoverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(binding.\u003cem\u003eroot\u003c/em\u003e)\n\n    \u003cem\u003elifecycleScope\u003c/em\u003e.launchWhenStarted \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e    viewModel.cityName().collect \u003cstrong\u003e{ \u003c/strong\u003estate \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e     \u003c/strong\u003e    \u003cstrong\u003e   \u003c/strong\u003ewhen (state) {\n                is CityState.Success -\u0026gt; \n                    binding.cityResult.\u003cem\u003etext \u003c/em\u003e= \n                        state.cityName\n                is CityState.Failure -\u0026gt; \n                    binding.cityResult.\u003cem\u003etext \u003c/em\u003e= \n                        state.error.message\n                CityState.Loading, CityState.Idle -\u0026gt; {\n                    /* no-op */\n                }\n            }\n        \u003cstrong\u003e}\u003c/strong\u003e\n    \u003cstrong\u003e}\n\u003c/strong\u003e    ...\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOf course setting the error message to the same text view would not be the best solution in a real-world app, but it\u0026#x27;s enough for the purpose of this codelab. In a real app we should also handle somehow the Loading state.\n\u003c/p\u003e\u003cp\u003eAs the last step can add a test to ensure the error message is properly displayed:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun shouldSetErrorMessageWhenCityStateEmitsFailure() {\n    val errorMessage = \u0026quot;Error\u0026quot;\n    val error = RuntimeException(errorMessage)\n    \u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eviewModel.cityName() \u003cstrong\u003e} \u003c/strong\u003ereturns\n        \u003cem\u003eflowOf\u003c/em\u003e(CityState.Failure(error))\n\n    \u003cem\u003elaunchActivity\u003c/em\u003e\u0026lt;MainActivity\u0026gt;().\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003escenario \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003escenario.onActivity \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e\u003cem\u003eassertEquals\u003c/em\u003e(\n                errorMessage, \n                \u003cstrong\u003eit\u003c/strong\u003e.binding.cityResult.\u003cem\u003etext\n\u003c/em\u003e            )\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"39n24","text":"To finish, our next step is to test our activity. You can use either Robolectric or Espresso, but here we will use Robolectric again. In order to run those test properly we need this additional configuration in the app-level build.gradle file:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":69,"length":11,"style":"BOLD"},{"offset":84,"length":8,"style":"BOLD"},{"offset":225,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"coos7","text":"buildFeatures {\n    viewBinding true\n}\ntestOptions {\n    unitTests {\n        includeAndroidResources true\n    }\n}\ndependencies {\n    testImplementation 'androidx.test:core-ktx:1.4.0'\n} ","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":14,"length":1,"style":"BOLD"},{"offset":16,"length":4,"style":"BOLD"},{"offset":37,"length":1,"style":"BOLD"},{"offset":51,"length":1,"style":"BOLD"},{"offset":53,"length":4,"style":"BOLD"},{"offset":67,"length":1,"style":"BOLD"},{"offset":69,"length":8,"style":"BOLD"},{"offset":110,"length":1,"style":"BOLD"},{"offset":112,"length":2,"style":"BOLD"},{"offset":184,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4k86b","text":"First closure enables ViewBinding for interacting with views and the second one is required so that Robolectric framework can see Android-specific classes during unit tests (like our MainActivity class). We also need the additional dependency for launching the Activity.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":22,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7ja4t","text":"The next step is creating a base setup for the test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"65qpk","text":"@HiltAndroidTest\n@RunWith(RobolectricTestRunner::class)\n@Config(\n    sdk = [23],\n    application = HiltTestApplication::class\n)\nclass MainActivityTest {\n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n\n    private val latitude = \"1.0\"\n    private val longitude = \"2.0\"\n\n    @BindValue\n    @JvmField\n    val viewModel = mockk\u003cCitiesViewModel\u003e(\n        relaxed = true\n    )\n\n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":326,"length":5,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"6pnt5","text":"Here we mark our mock ViewModel with @BindValue annotation, so that Hilt can replace the real ViewModel instance with this mock for every test in this class.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":37,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"17tg8","text":"Now we're ready to start testing the Activity. Let's start with testing whether a correct method is called after the FIND button is pressed:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"75r01","text":"@Test\nfun shouldTriggerFindingCityAfterClickingButton() {\n    launchActivity\u003cMainActivity\u003e().use { scenario -\u003e\n        scenario.onActivity {\n            it.binding.latInput.setText(latitude)\n            it.binding.lonInput.setText(longitude)\n            it.binding.findCityButton.performClick()\n\n            verify { \n                viewModel.findCity(latitude, longitude) \n            }\n        }\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":62,"length":14,"style":"ITALIC"},{"offset":93,"length":4,"style":"ITALIC"},{"offset":308,"length":7,"style":"ITALIC"},{"offset":97,"length":2,"style":"BOLD"},{"offset":108,"length":2,"style":"BOLD"},{"offset":111,"length":8,"style":"BOLD"},{"offset":139,"length":1,"style":"BOLD"},{"offset":141,"length":14,"style":"BOLD"},{"offset":203,"length":2,"style":"BOLD"},{"offset":254,"length":2,"style":"BOLD"},{"offset":315,"length":3,"style":"BOLD"},{"offset":387,"length":1,"style":"BOLD"},{"offset":389,"length":9,"style":"BOLD"},{"offset":399,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"91tmm","text":"The launchActivity method is a part of androidx.test library and is a convenient way to easily launch a given Activity in a test. It provides an ActivityScenario object which can access the Activity at different lifecycle states.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":15,"style":"ITALIC"},{"offset":39,"length":13,"style":"BOLD"},{"offset":145,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a4hsl","text":"Like always, we are going to implement the feature to make this test pass. Open MainActivity and add the following code:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":80,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ajd4a","text":"...\ninternal val binding by lazy { \n    ActivityMainBinding.inflate(layoutInflater)\n}\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(binding.root)\n\n    binding.findCityButton.setOnClickListener {\n        viewModel.findCity(\n            binding.latInput.text.toString(),\n            binding.lonInput.text.toString()\n        )\n    }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":28,"length":5,"style":"ITALIC"},{"offset":68,"length":14,"style":"ITALIC"},{"offset":318,"length":4,"style":"ITALIC"},{"offset":364,"length":4,"style":"ITALIC"},{"offset":33,"length":3,"style":"BOLD"},{"offset":84,"length":1,"style":"BOLD"},{"offset":259,"length":1,"style":"BOLD"},{"offset":261,"length":8,"style":"BOLD"},{"offset":394,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dg1l5","text":"We also need to create another test for ensuring that our TextView will be updated after a value is set to the StateFlow. Add one more test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"48ev4","text":"@Test\nfun shouldSetCityNameWhenCityStateEmitsSuccess() {\n    val cityName = \"London\"\n    every { viewModel.cityName() } returns \n        flowOf(CityState.Success(cityName))\n\n    launchActivity\u003cMainActivity\u003e().use { scenario -\u003e\n        scenario.onActivity {\n            assertEquals(\n                cityName, \n                it.binding.cityResult.text\n            )\n        }\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":89,"length":6,"style":"ITALIC"},{"offset":137,"length":6,"style":"ITALIC"},{"offset":178,"length":14,"style":"ITALIC"},{"offset":209,"length":4,"style":"ITALIC"},{"offset":269,"length":12,"style":"ITALIC"},{"offset":348,"length":5,"style":"ITALIC"},{"offset":95,"length":2,"style":"BOLD"},{"offset":118,"length":2,"style":"BOLD"},{"offset":213,"length":2,"style":"BOLD"},{"offset":224,"length":2,"style":"BOLD"},{"offset":227,"length":8,"style":"BOLD"},{"offset":255,"length":1,"style":"BOLD"},{"offset":257,"length":12,"style":"BOLD"},{"offset":326,"length":2,"style":"BOLD"},{"offset":375,"length":1,"style":"BOLD"},{"offset":377,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9ne6c","text":"And easily fix it by adding a Flow collector to our Activity:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8g08e","text":"override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(binding.root)\n\n    lifecycleScope.launchWhenStarted {\n        viewModel.cityName().collect { state -\u003e\n            when (state) {\n                is CityState.Success -\u003e \n                    binding.cityResult.text = \n                        state.cityName\n                is CityState.Failure -\u003e \n                    binding.cityResult.text = \n                        state.error.message\n                CityState.Loading, CityState.Idle -\u003e {\n                    /* no-op */\n                }\n            }\n        }\n    }\n    ...","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":119,"length":4,"style":"ITALIC"},{"offset":130,"length":14,"style":"ITALIC"},{"offset":320,"length":5,"style":"ITALIC"},{"offset":447,"length":5,"style":"ITALIC"},{"offset":163,"length":1,"style":"BOLD"},{"offset":165,"length":4,"style":"BOLD"},{"offset":202,"length":2,"style":"BOLD"},{"offset":210,"length":2,"style":"BOLD"},{"offset":213,"length":5,"style":"BOLD"},{"offset":222,"length":3,"style":"BOLD"},{"offset":626,"length":1,"style":"BOLD"},{"offset":632,"length":2,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6j7l2","text":"Of course setting the error message to the same text view would not be the best solution in a real-world app, but it's enough for the purpose of this codelab. In a real app we should also handle somehow the Loading state.\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dph5j","text":"As the last step can add a test to ensure the error message is properly displayed:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e5loj","text":"@Test\nfun shouldSetErrorMessageWhenCityStateEmitsFailure() {\n    val errorMessage = \"Error\"\n    val error = RuntimeException(errorMessage)\n    every { viewModel.cityName() } returns\n        flowOf(CityState.Failure(error))\n\n    launchActivity\u003cMainActivity\u003e().use { scenario -\u003e\n        scenario.onActivity {\n            assertEquals(\n                errorMessage, \n                it.binding.cityResult.text\n            )\n        }\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":143,"length":6,"style":"ITALIC"},{"offset":190,"length":6,"style":"ITALIC"},{"offset":228,"length":14,"style":"ITALIC"},{"offset":259,"length":4,"style":"ITALIC"},{"offset":319,"length":12,"style":"ITALIC"},{"offset":402,"length":5,"style":"ITALIC"},{"offset":149,"length":2,"style":"BOLD"},{"offset":172,"length":2,"style":"BOLD"},{"offset":263,"length":2,"style":"BOLD"},{"offset":274,"length":2,"style":"BOLD"},{"offset":277,"length":8,"style":"BOLD"},{"offset":305,"length":1,"style":"BOLD"},{"offset":307,"length":12,"style":"BOLD"},{"offset":380,"length":2,"style":"BOLD"},{"offset":429,"length":1,"style":"BOLD"},{"offset":431,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 9: Testing our activity","body":null,"serialized_body":"\u003cp\u003eTo finish, our next step is to test our activity. You can use either \u003cstrong\u003eRobolectric\u003c/strong\u003e or \u003cstrong\u003eEspresso\u003c/strong\u003e, but here we will use Robolectric again. In order to run those test properly we need this additional configuration in the app-level \u003cstrong\u003ebuild.gradle\u003c/strong\u003e file:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003ebuildFeatures \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eviewBinding true\n\u003cstrong\u003e}\u003c/strong\u003e\ntestOptions \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003eunitTests \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eincludeAndroidResources true\n    \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e}\n\u003c/strong\u003edependencies {\n    testImplementation \u0026#x27;androidx.test:core-ktx:1.4.0\u0026#x27;\n}\u003cstrong\u003e \u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFirst closure enables \u003cstrong\u003eViewBinding\u003c/strong\u003e for interacting with views and the second one is required so that Robolectric framework can see Android-specific classes during unit tests (like our MainActivity class). We also need the additional dependency for launching the Activity.\u003c/p\u003e\u003cp\u003eThe next step is creating a base setup for the test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltAndroidTest\n@RunWith(RobolectricTestRunner::class)\n@Config(\n    sdk = [23],\n    application = HiltTestApplication::class\n)\nclass MainActivityTest {\n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n\n    private val latitude = \u0026quot;1.0\u0026quot;\n    private val longitude = \u0026quot;2.0\u0026quot;\n\n    @BindValue\n    @JvmField\n    val viewModel = \u003cem\u003emockk\u003c/em\u003e\u0026lt;CitiesViewModel\u0026gt;(\n        relaxed = true\n    )\n\n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we mark our mock ViewModel with \u003cstrong\u003e@BindValue \u003c/strong\u003eannotation, so that Hilt can replace the real ViewModel instance with this mock for every test in this class.\u003c/p\u003e\u003cp\u003eNow we\u0026#x27;re ready to start testing the Activity. Let\u0026#x27;s start with testing whether a correct method is called after the FIND button is pressed:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun shouldTriggerFindingCityAfterClickingButton() {\n    \u003cem\u003elaunchActivity\u003c/em\u003e\u0026lt;MainActivity\u0026gt;().\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003escenario \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003escenario.onActivity \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            it\u003c/strong\u003e.binding.latInput.setText(latitude)\n            \u003cstrong\u003eit\u003c/strong\u003e.binding.lonInput.setText(longitude)\n            \u003cstrong\u003eit\u003c/strong\u003e.binding.findCityButton.performClick()\n\n            \u003cem\u003everify \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e                viewModel.findCity(latitude, longitude) \n            \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e        }\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003cem\u003elaunchActivity \u003c/em\u003emethod is a part of \u003cstrong\u003eandroidx.test\u003c/strong\u003e library and is a convenient way to easily launch a given Activity in a test. It provides an \u003cstrong\u003eActivityScenario \u003c/strong\u003eobject which can access the Activity at different lifecycle states.\u003c/p\u003e\u003cp\u003eLike always, we are going to implement the feature to make this test pass. Open \u003cstrong\u003eMainActivity\u003c/strong\u003e and add the following code:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e...\ninternal val binding by \u003cem\u003elazy \u003c/em\u003e\u003cstrong\u003e{ \n\u003c/strong\u003e    ActivityMainBinding.inflate(\u003cem\u003elayoutInflater\u003c/em\u003e)\n\u003cstrong\u003e}\u003c/strong\u003e\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(binding.root)\n\n    binding.findCityButton.setOnClickListener \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003eviewModel.findCity(\n            binding.latInput.\u003cem\u003etext\u003c/em\u003e.toString(),\n            binding.lonInput.\u003cem\u003etext\u003c/em\u003e.toString()\n        )\n    \u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe also need to create another test for ensuring that our TextView will be updated after a value is set to the StateFlow. Add one more test:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun shouldSetCityNameWhenCityStateEmitsSuccess() {\n    val cityName = \u0026quot;London\u0026quot;\n    \u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eviewModel.cityName() \u003cstrong\u003e} \u003c/strong\u003ereturns \n        \u003cem\u003eflowOf\u003c/em\u003e(CityState.Success(cityName))\n\n    \u003cem\u003elaunchActivity\u003c/em\u003e\u0026lt;MainActivity\u0026gt;().\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003escenario \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003escenario.onActivity \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e\u003cem\u003eassertEquals\u003c/em\u003e(\n                cityName, \n                \u003cstrong\u003eit\u003c/strong\u003e.binding.cityResult.\u003cem\u003etext\n\u003c/em\u003e            )\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd easily fix it by adding a Flow collector to our Activity:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eoverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(binding.\u003cem\u003eroot\u003c/em\u003e)\n\n    \u003cem\u003elifecycleScope\u003c/em\u003e.launchWhenStarted \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e    viewModel.cityName().collect \u003cstrong\u003e{ \u003c/strong\u003estate \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e     \u003c/strong\u003e    \u003cstrong\u003e   \u003c/strong\u003ewhen (state) {\n                is CityState.Success -\u0026gt; \n                    binding.cityResult.\u003cem\u003etext \u003c/em\u003e= \n                        state.cityName\n                is CityState.Failure -\u0026gt; \n                    binding.cityResult.\u003cem\u003etext \u003c/em\u003e= \n                        state.error.message\n                CityState.Loading, CityState.Idle -\u0026gt; {\n                    /* no-op */\n                }\n            }\n        \u003cstrong\u003e}\u003c/strong\u003e\n    \u003cstrong\u003e}\n\u003c/strong\u003e    ...\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOf course setting the error message to the same text view would not be the best solution in a real-world app, but it\u0026#x27;s enough for the purpose of this codelab. In a real app we should also handle somehow the Loading state.\n\u003c/p\u003e\u003cp\u003eAs the last step can add a test to ensure the error message is properly displayed:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@Test\nfun shouldSetErrorMessageWhenCityStateEmitsFailure() {\n    val errorMessage = \u0026quot;Error\u0026quot;\n    val error = RuntimeException(errorMessage)\n    \u003cem\u003eevery \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003eviewModel.cityName() \u003cstrong\u003e} \u003c/strong\u003ereturns\n        \u003cem\u003eflowOf\u003c/em\u003e(CityState.Failure(error))\n\n    \u003cem\u003elaunchActivity\u003c/em\u003e\u0026lt;MainActivity\u0026gt;().\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ \u003c/strong\u003escenario \u003cstrong\u003e-\u0026gt;\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003escenario.onActivity \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e            \u003c/strong\u003e\u003cem\u003eassertEquals\u003c/em\u003e(\n                errorMessage, \n                \u003cstrong\u003eit\u003c/strong\u003e.binding.cityResult.\u003cem\u003etext\n\u003c/em\u003e            )\n        \u003cstrong\u003e}\u003c/strong\u003e\n\u003cstrong\u003e    }\u003c/strong\u003e\n}\u003c/code\u003e\u003c/pre\u003e","structured_body":{"entityMap":{},"blocks":[{"key":"39n24","text":"To finish, our next step is to test our activity. You can use either Robolectric or Espresso, but here we will use Robolectric again. In order to run those test properly we need this additional configuration in the app-level build.gradle file:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":69,"length":11,"style":"BOLD"},{"offset":84,"length":8,"style":"BOLD"},{"offset":225,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"coos7","text":"buildFeatures {\n    viewBinding true\n}\ntestOptions {\n    unitTests {\n        includeAndroidResources true\n    }\n}\ndependencies {\n    testImplementation 'androidx.test:core-ktx:1.4.0'\n} ","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":14,"length":1,"style":"BOLD"},{"offset":16,"length":4,"style":"BOLD"},{"offset":37,"length":1,"style":"BOLD"},{"offset":51,"length":1,"style":"BOLD"},{"offset":53,"length":4,"style":"BOLD"},{"offset":67,"length":1,"style":"BOLD"},{"offset":69,"length":8,"style":"BOLD"},{"offset":110,"length":1,"style":"BOLD"},{"offset":112,"length":2,"style":"BOLD"},{"offset":184,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4k86b","text":"First closure enables ViewBinding for interacting with views and the second one is required so that Robolectric framework can see Android-specific classes during unit tests (like our MainActivity class). We also need the additional dependency for launching the Activity.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":22,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7ja4t","text":"The next step is creating a base setup for the test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"65qpk","text":"@HiltAndroidTest\n@RunWith(RobolectricTestRunner::class)\n@Config(\n    sdk = [23],\n    application = HiltTestApplication::class\n)\nclass MainActivityTest {\n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n\n    private val latitude = \"1.0\"\n    private val longitude = \"2.0\"\n\n    @BindValue\n    @JvmField\n    val viewModel = mockk\u003cCitiesViewModel\u003e(\n        relaxed = true\n    )\n\n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":326,"length":5,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"6pnt5","text":"Here we mark our mock ViewModel with @BindValue annotation, so that Hilt can replace the real ViewModel instance with this mock for every test in this class.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":37,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"17tg8","text":"Now we're ready to start testing the Activity. Let's start with testing whether a correct method is called after the FIND button is pressed:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"75r01","text":"@Test\nfun shouldTriggerFindingCityAfterClickingButton() {\n    launchActivity\u003cMainActivity\u003e().use { scenario -\u003e\n        scenario.onActivity {\n            it.binding.latInput.setText(latitude)\n            it.binding.lonInput.setText(longitude)\n            it.binding.findCityButton.performClick()\n\n            verify { \n                viewModel.findCity(latitude, longitude) \n            }\n        }\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":62,"length":14,"style":"ITALIC"},{"offset":93,"length":4,"style":"ITALIC"},{"offset":308,"length":7,"style":"ITALIC"},{"offset":97,"length":2,"style":"BOLD"},{"offset":108,"length":2,"style":"BOLD"},{"offset":111,"length":8,"style":"BOLD"},{"offset":139,"length":1,"style":"BOLD"},{"offset":141,"length":14,"style":"BOLD"},{"offset":203,"length":2,"style":"BOLD"},{"offset":254,"length":2,"style":"BOLD"},{"offset":315,"length":3,"style":"BOLD"},{"offset":387,"length":1,"style":"BOLD"},{"offset":389,"length":9,"style":"BOLD"},{"offset":399,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"91tmm","text":"The launchActivity method is a part of androidx.test library and is a convenient way to easily launch a given Activity in a test. It provides an ActivityScenario object which can access the Activity at different lifecycle states.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":4,"length":15,"style":"ITALIC"},{"offset":39,"length":13,"style":"BOLD"},{"offset":145,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a4hsl","text":"Like always, we are going to implement the feature to make this test pass. Open MainActivity and add the following code:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":80,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ajd4a","text":"...\ninternal val binding by lazy { \n    ActivityMainBinding.inflate(layoutInflater)\n}\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(binding.root)\n\n    binding.findCityButton.setOnClickListener {\n        viewModel.findCity(\n            binding.latInput.text.toString(),\n            binding.lonInput.text.toString()\n        )\n    }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":28,"length":5,"style":"ITALIC"},{"offset":68,"length":14,"style":"ITALIC"},{"offset":318,"length":4,"style":"ITALIC"},{"offset":364,"length":4,"style":"ITALIC"},{"offset":33,"length":3,"style":"BOLD"},{"offset":84,"length":1,"style":"BOLD"},{"offset":259,"length":1,"style":"BOLD"},{"offset":261,"length":8,"style":"BOLD"},{"offset":394,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dg1l5","text":"We also need to create another test for ensuring that our TextView will be updated after a value is set to the StateFlow. Add one more test:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"48ev4","text":"@Test\nfun shouldSetCityNameWhenCityStateEmitsSuccess() {\n    val cityName = \"London\"\n    every { viewModel.cityName() } returns \n        flowOf(CityState.Success(cityName))\n\n    launchActivity\u003cMainActivity\u003e().use { scenario -\u003e\n        scenario.onActivity {\n            assertEquals(\n                cityName, \n                it.binding.cityResult.text\n            )\n        }\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":89,"length":6,"style":"ITALIC"},{"offset":137,"length":6,"style":"ITALIC"},{"offset":178,"length":14,"style":"ITALIC"},{"offset":209,"length":4,"style":"ITALIC"},{"offset":269,"length":12,"style":"ITALIC"},{"offset":348,"length":5,"style":"ITALIC"},{"offset":95,"length":2,"style":"BOLD"},{"offset":118,"length":2,"style":"BOLD"},{"offset":213,"length":2,"style":"BOLD"},{"offset":224,"length":2,"style":"BOLD"},{"offset":227,"length":8,"style":"BOLD"},{"offset":255,"length":1,"style":"BOLD"},{"offset":257,"length":12,"style":"BOLD"},{"offset":326,"length":2,"style":"BOLD"},{"offset":375,"length":1,"style":"BOLD"},{"offset":377,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9ne6c","text":"And easily fix it by adding a Flow collector to our Activity:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8g08e","text":"override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(binding.root)\n\n    lifecycleScope.launchWhenStarted {\n        viewModel.cityName().collect { state -\u003e\n            when (state) {\n                is CityState.Success -\u003e \n                    binding.cityResult.text = \n                        state.cityName\n                is CityState.Failure -\u003e \n                    binding.cityResult.text = \n                        state.error.message\n                CityState.Loading, CityState.Idle -\u003e {\n                    /* no-op */\n                }\n            }\n        }\n    }\n    ...","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":119,"length":4,"style":"ITALIC"},{"offset":130,"length":14,"style":"ITALIC"},{"offset":320,"length":5,"style":"ITALIC"},{"offset":447,"length":5,"style":"ITALIC"},{"offset":163,"length":1,"style":"BOLD"},{"offset":165,"length":4,"style":"BOLD"},{"offset":202,"length":2,"style":"BOLD"},{"offset":210,"length":2,"style":"BOLD"},{"offset":213,"length":5,"style":"BOLD"},{"offset":222,"length":3,"style":"BOLD"},{"offset":626,"length":1,"style":"BOLD"},{"offset":632,"length":2,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6j7l2","text":"Of course setting the error message to the same text view would not be the best solution in a real-world app, but it's enough for the purpose of this codelab. In a real app we should also handle somehow the Loading state.\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dph5j","text":"As the last step can add a test to ensure the error message is properly displayed:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e5loj","text":"@Test\nfun shouldSetErrorMessageWhenCityStateEmitsFailure() {\n    val errorMessage = \"Error\"\n    val error = RuntimeException(errorMessage)\n    every { viewModel.cityName() } returns\n        flowOf(CityState.Failure(error))\n\n    launchActivity\u003cMainActivity\u003e().use { scenario -\u003e\n        scenario.onActivity {\n            assertEquals(\n                errorMessage, \n                it.binding.cityResult.text\n            )\n        }\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":143,"length":6,"style":"ITALIC"},{"offset":190,"length":6,"style":"ITALIC"},{"offset":228,"length":14,"style":"ITALIC"},{"offset":259,"length":4,"style":"ITALIC"},{"offset":319,"length":12,"style":"ITALIC"},{"offset":402,"length":5,"style":"ITALIC"},{"offset":149,"length":2,"style":"BOLD"},{"offset":172,"length":2,"style":"BOLD"},{"offset":263,"length":2,"style":"BOLD"},{"offset":274,"length":2,"style":"BOLD"},{"offset":277,"length":8,"style":"BOLD"},{"offset":305,"length":1,"style":"BOLD"},{"offset":307,"length":12,"style":"BOLD"},{"offset":380,"length":2,"style":"BOLD"},{"offset":429,"length":1,"style":"BOLD"},{"offset":431,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":2,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]},{"id":787,"position":11,"new_position":11,"published_attributes":{"type":"slide","answers":[],"title":"Step 10: Coming back to our acceptance test","body":null,"serialized_body":"\u003cp\u003eThe final step is to go back to the acceptance test and make it pass. It will be very similar to the MainActivityTest, however this time we will use Espresso and run the test on a real device.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eAdding required dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWe need to duplicate some libraries, that were previously used only for unit tests:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edependencies {\n...\n \u003c/span\u003eandroidTestImplementation \u0026quot;com.google.dagger:hilt-android-testing:$hilt_version\u0026quot;\nkaptAndroidTest \u0026quot;com.google.dagger:hilt-android-compiler:$hilt_version\u0026quot;\nandroidTestImplementation \u0026quot;com.squareup.okhttp3:mockwebserver:$okhttp_version\u0026quot;\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eOverriding configuration for espresso test\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eThanks to Hilt great testing support, the setup of the test will be very easy. First we need to create a custom test runner, which will use \u003cstrong\u003eHiltTestApplication\u003c/strong\u003e as a default Application class for tests (it\u0026#x27;s analogous to using it in the Robolectric annotation):\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass HiltTestRunner : AndroidJUnitRunner() {\n    override fun newApplication(\n        cl: ClassLoader?, \n        name: String?,\n        context: Context?\n    ): Application = \n        super.newApplication(\n            cl, \n            HiltTestApplication::class.\u003cem\u003ejava\u003c/em\u003e.\u003cem\u003ename\u003c/em\u003e, \n            context\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we need to register this runner in the app-level gradle file, replacing the default one:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003edefaultConfig \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e...\n    testInstrumentationRunner \n\u0026quot;{your_package}.HiltTestRunner\u0026quot;\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor this test we will also mock the responses with the \u003cstrong\u003eMockWebServer\u003c/strong\u003e, because real API calls can sometimes take longer than usual and can make our tests non-deterministic.\u003c/p\u003e\u003cp\u003eHowever, the problem with \u003cstrong\u003eMockWebServer\u003c/strong\u003e in tests run on a device is that it uses by default plain \u003cstrong\u003ehttp\u003c/strong\u003e requests, and starting from Android 8 such requests are automatically blocked, allowing only \u003cstrong\u003ehttps\u003c/strong\u003e. \nBecause of that, we need to tell the system, that it should allow \u003cstrong\u003ehttp\u003c/strong\u003e requests for \u003cstrong\u003elocalhost\u003c/strong\u003e subdomain, otherwise this test would always fail on any device using Android 8 or any higher.\nWe can do it by defining a network config file under \u003cstrong\u003eres/xml\u003c/strong\u003e directory:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u0026lt;network-security-config\u0026gt;\n    \u0026lt;base-config cleartextTrafficPermitted=\u0026quot;false\u0026quot; /\u0026gt;\n    \u0026lt;domain-config cleartextTrafficPermitted=\u0026quot;true\u0026quot;\u0026gt;\n        \u0026lt;domain includeSubdomains=\u0026quot;true\u0026quot;\u0026gt;localhost\u0026lt;/domain\u0026gt;\n    \u0026lt;/domain-config\u0026gt;\n\u0026lt;/network-security-config\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we need to register this file in the Manifest file:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u0026lt;application\n    ...\nandroid:networkSecurityConfig=\u0026quot;@xml/network_security_config\u0026quot;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe will also use the \u003cstrong\u003eHiltAndroidRule\u003c/strong\u003e as before.\nAdditionally, we need the JSON file in this test as well, so create a new \u003cstrong\u003eassets\u003c/strong\u003e folder under \u003cstrong\u003eandroidTest\u003c/strong\u003e directory and paste there the same JSON file we used before.\nTo read it, we will need a new method:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate fun readAsset(path: String) =         \n    InstrumentationRegistry.getInstrumentation()\n        .context\n        .\u003cem\u003eassets\u003c/em\u003e\n    \u003cem\u003e    \u003c/em\u003e.open(path)\n        .\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ it\u003c/strong\u003e.\u003cem\u003ebufferedReader\u003c/em\u003e().\u003cem\u003ereadText\u003c/em\u003e() \u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we can finish the setup:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltAndroidTest\n@UninstallModules(NetworkConfigModule::class)\nclass CityFinderAcceptanceTest {\n\n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n\n    private val response = readAsset(\u0026quot;response.json\u0026quot;)\n\n    private val server = MockWebServer().\u003cem\u003eapply \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003edispatcher = object : Dispatcher() {\n            override fun dispatch(\n                request: RecordedRequest\n            ): MockResponse = \n                if(request.path.\u003cem\u003eorEmpty\u003c/em\u003e()\n                       .\u003cem\u003econtains\u003c/em\u003e(\u0026quot;/postcodes\u0026quot;)) {\n                   MockResponse()\n                      .setResponseCode(200)\n                      .setBody(response)\n                } else {\n                    MockResponse().setResponseCode(404)\n                }\n        }\n    \u003cstrong\u003e}\u003c/strong\u003e\n\n    @BindValue\n    @JvmField\n    val baseUrl: HttpUrl = server.url(\u0026quot;/\u0026quot;)\n\n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }\n\n    @After\n    fun clear() {\n        server.shutdown()\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time instead of using \u003cstrong\u003eserver.enqueue(response)\u003c/strong\u003e we use a Dispatcher object. It can be useful when we have more than one request in the test and we want to configure them all in a one place.\nWe can distinguish different requests by the \u003cstrong\u003erequest.path \u003c/strong\u003eproperty.\u003c/p\u003e\u003cp\u003eRun you test - it is passing right now.\u003c/p\u003e\u003cp\u003eCongratulations, you have created one feature of your application using Test Driven Development!\u003c/p\u003e\u003cp\u003eNow try to use TDD yourself and add more features to this application.\u003c/p\u003e\u003cp\u003eThe full source code of this codelab is available \u003ca href=\"https://github.com/netguru/android-test-driven-development\"\u003ehere\u003c/a\u003e.\u003c/p\u003e","structured_body":{"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://github.com/netguru/android-test-driven-development","text":"here"}}},"blocks":[{"key":"cjhpn","text":"The final step is to go back to the acceptance test and make it pass. It will be very similar to the MainActivityTest, however this time we will use Espresso and run the test on a real device.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ekcfb","text":"Adding required dependencies","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"co8ig","text":"We need to duplicate some libraries, that were previously used only for unit tests:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4kjhu","text":"dependencies {\n...\n androidTestImplementation \"com.google.dagger:hilt-android-testing:$hilt_version\"\nkaptAndroidTest \"com.google.dagger:hilt-android-compiler:$hilt_version\"\nandroidTestImplementation \"com.squareup.okhttp3:mockwebserver:$okhttp_version\"\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"CODE"},{"offset":251,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"f7nfk","text":"Overriding configuration for espresso test","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":42,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a994v","text":"Thanks to Hilt great testing support, the setup of the test will be very easy. First we need to create a custom test runner, which will use HiltTestApplication as a default Application class for tests (it's analogous to using it in the Robolectric annotation):","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":140,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ahe48","text":"class HiltTestRunner : AndroidJUnitRunner() {\n    override fun newApplication(\n        cl: ClassLoader?, \n        name: String?,\n        context: Context?\n    ): Application = \n        super.newApplication(\n            cl, \n            HiltTestApplication::class.java.name, \n            context\n        )\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":263,"length":4,"style":"ITALIC"},{"offset":268,"length":4,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"946c2","text":"Then we need to register this runner in the app-level gradle file, replacing the default one:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bo6bm","text":"defaultConfig {\n    ...\n    testInstrumentationRunner \n\"{your_package}.HiltTestRunner\"\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":14,"length":1,"style":"BOLD"},{"offset":16,"length":4,"style":"BOLD"},{"offset":87,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"em5sf","text":"For this test we will also mock the responses with the MockWebServer, because real API calls can sometimes take longer than usual and can make our tests non-deterministic.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":55,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8ttn6","text":"However, the problem with MockWebServer in tests run on a device is that it uses by default plain http requests, and starting from Android 8 such requests are automatically blocked, allowing only https. \nBecause of that, we need to tell the system, that it should allow http requests for localhost subdomain, otherwise this test would always fail on any device using Android 8 or any higher.\nWe can do it by defining a network config file under res/xml directory:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":26,"length":13,"style":"BOLD"},{"offset":98,"length":4,"style":"BOLD"},{"offset":196,"length":5,"style":"BOLD"},{"offset":270,"length":4,"style":"BOLD"},{"offset":288,"length":9,"style":"BOLD"},{"offset":445,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"b2re7","text":"\u003cnetwork-security-config\u003e\n    \u003cbase-config cleartextTrafficPermitted=\"false\" /\u003e\n    \u003cdomain-config cleartextTrafficPermitted=\"true\"\u003e\n        \u003cdomain includeSubdomains=\"true\"\u003elocalhost\u003c/domain\u003e\n    \u003c/domain-config\u003e\n\u003c/network-security-config\u003e","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"58ees","text":"Then we need to register this file in the Manifest file:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ahhg","text":"\u003capplication\n    ...\nandroid:networkSecurityConfig=\"@xml/network_security_config\"","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f6q8i","text":"We will also use the HiltAndroidRule as before.\nAdditionally, we need the JSON file in this test as well, so create a new assets folder under androidTest directory and paste there the same JSON file we used before.\nTo read it, we will need a new method:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":21,"length":15,"style":"BOLD"},{"offset":122,"length":6,"style":"BOLD"},{"offset":142,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8ataq","text":"private fun readAsset(path: String) =         \n    InstrumentationRegistry.getInstrumentation()\n        .context\n        .assets\n        .open(path)\n        .use { it.bufferedReader().readText() }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":122,"length":6,"style":"ITALIC"},{"offset":133,"length":4,"style":"ITALIC"},{"offset":158,"length":4,"style":"ITALIC"},{"offset":167,"length":14,"style":"ITALIC"},{"offset":184,"length":8,"style":"ITALIC"},{"offset":162,"length":4,"style":"BOLD"},{"offset":195,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"b11ui","text":"Now we can finish the setup:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9nipf","text":"@HiltAndroidTest\n@UninstallModules(NetworkConfigModule::class)\nclass CityFinderAcceptanceTest {\n\n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n\n    private val response = readAsset(\"response.json\")\n\n    private val server = MockWebServer().apply {\n        dispatcher = object : Dispatcher() {\n            override fun dispatch(\n                request: RecordedRequest\n            ): MockResponse = \n                if(request.path.orEmpty()\n                       .contains(\"/postcodes\")) {\n                   MockResponse()\n                      .setResponseCode(200)\n                      .setBody(response)\n                } else {\n                    MockResponse().setResponseCode(404)\n                }\n        }\n    }\n\n    @BindValue\n    @JvmField\n    val baseUrl: HttpUrl = server.url(\"/\")\n\n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }\n\n    @After\n    fun clear() {\n        server.shutdown()\n    }\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":249,"length":6,"style":"ITALIC"},{"offset":441,"length":7,"style":"ITALIC"},{"offset":475,"length":8,"style":"ITALIC"},{"offset":255,"length":1,"style":"BOLD"},{"offset":257,"length":8,"style":"BOLD"},{"offset":733,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"f86hi","text":"This time instead of using server.enqueue(response) we use a Dispatcher object. It can be useful when we have more than one request in the test and we want to configure them all in a one place.\nWe can distinguish different requests by the request.path property.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":27,"length":24,"style":"BOLD"},{"offset":239,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"cqu1k","text":"Run you test - it is passing right now.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"arli2","text":"Congratulations, you have created one feature of your application using Test Driven Development!","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5cb1q","text":"Now try to use TDD yourself and add more features to this application.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4bvlf","text":"The full source code of this codelab is available here.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":50,"length":4,"key":0}],"data":{}}]},"feedback":null,"cover_slide_data":{}},"draft_attributes":{"type":"slide","answers":[],"title":"Step 10: Coming back to our acceptance test","body":null,"serialized_body":"\u003cp\u003eThe final step is to go back to the acceptance test and make it pass. It will be very similar to the MainActivityTest, however this time we will use Espresso and run the test on a real device.\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003eAdding required dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWe need to duplicate some libraries, that were previously used only for unit tests:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u003cspan\u003edependencies {\n...\n \u003c/span\u003eandroidTestImplementation \u0026quot;com.google.dagger:hilt-android-testing:$hilt_version\u0026quot;\nkaptAndroidTest \u0026quot;com.google.dagger:hilt-android-compiler:$hilt_version\u0026quot;\nandroidTestImplementation \u0026quot;com.squareup.okhttp3:mockwebserver:$okhttp_version\u0026quot;\u003cspan\u003e\n}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003e\u003cstrong\u003eOverriding configuration for espresso test\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eThanks to Hilt great testing support, the setup of the test will be very easy. First we need to create a custom test runner, which will use \u003cstrong\u003eHiltTestApplication\u003c/strong\u003e as a default Application class for tests (it\u0026#x27;s analogous to using it in the Robolectric annotation):\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eclass HiltTestRunner : AndroidJUnitRunner() {\n    override fun newApplication(\n        cl: ClassLoader?, \n        name: String?,\n        context: Context?\n    ): Application = \n        super.newApplication(\n            cl, \n            HiltTestApplication::class.\u003cem\u003ejava\u003c/em\u003e.\u003cem\u003ename\u003c/em\u003e, \n            context\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we need to register this runner in the app-level gradle file, replacing the default one:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003edefaultConfig \u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e    \u003c/strong\u003e...\n    testInstrumentationRunner \n\u0026quot;{your_package}.HiltTestRunner\u0026quot;\n\u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor this test we will also mock the responses with the \u003cstrong\u003eMockWebServer\u003c/strong\u003e, because real API calls can sometimes take longer than usual and can make our tests non-deterministic.\u003c/p\u003e\u003cp\u003eHowever, the problem with \u003cstrong\u003eMockWebServer\u003c/strong\u003e in tests run on a device is that it uses by default plain \u003cstrong\u003ehttp\u003c/strong\u003e requests, and starting from Android 8 such requests are automatically blocked, allowing only \u003cstrong\u003ehttps\u003c/strong\u003e. \nBecause of that, we need to tell the system, that it should allow \u003cstrong\u003ehttp\u003c/strong\u003e requests for \u003cstrong\u003elocalhost\u003c/strong\u003e subdomain, otherwise this test would always fail on any device using Android 8 or any higher.\nWe can do it by defining a network config file under \u003cstrong\u003eres/xml\u003c/strong\u003e directory:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u0026lt;network-security-config\u0026gt;\n    \u0026lt;base-config cleartextTrafficPermitted=\u0026quot;false\u0026quot; /\u0026gt;\n    \u0026lt;domain-config cleartextTrafficPermitted=\u0026quot;true\u0026quot;\u0026gt;\n        \u0026lt;domain includeSubdomains=\u0026quot;true\u0026quot;\u0026gt;localhost\u0026lt;/domain\u0026gt;\n    \u0026lt;/domain-config\u0026gt;\n\u0026lt;/network-security-config\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we need to register this file in the Manifest file:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e\u0026lt;application\n    ...\nandroid:networkSecurityConfig=\u0026quot;@xml/network_security_config\u0026quot;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe will also use the \u003cstrong\u003eHiltAndroidRule\u003c/strong\u003e as before.\nAdditionally, we need the JSON file in this test as well, so create a new \u003cstrong\u003eassets\u003c/strong\u003e folder under \u003cstrong\u003eandroidTest\u003c/strong\u003e directory and paste there the same JSON file we used before.\nTo read it, we will need a new method:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003eprivate fun readAsset(path: String) =         \n    InstrumentationRegistry.getInstrumentation()\n        .context\n        .\u003cem\u003eassets\u003c/em\u003e\n    \u003cem\u003e    \u003c/em\u003e.open(path)\n        .\u003cem\u003euse \u003c/em\u003e\u003cstrong\u003e{ it\u003c/strong\u003e.\u003cem\u003ebufferedReader\u003c/em\u003e().\u003cem\u003ereadText\u003c/em\u003e() \u003cstrong\u003e}\u003c/strong\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we can finish the setup:\u003c/p\u003e\u003cpre class=\"cce-content__code-block\"\u003e\u003ccode\u003e@HiltAndroidTest\n@UninstallModules(NetworkConfigModule::class)\nclass CityFinderAcceptanceTest {\n\n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n\n    private val response = readAsset(\u0026quot;response.json\u0026quot;)\n\n    private val server = MockWebServer().\u003cem\u003eapply \u003c/em\u003e\u003cstrong\u003e{\u003c/strong\u003e\n\u003cstrong\u003e        \u003c/strong\u003edispatcher = object : Dispatcher() {\n            override fun dispatch(\n                request: RecordedRequest\n            ): MockResponse = \n                if(request.path.\u003cem\u003eorEmpty\u003c/em\u003e()\n                       .\u003cem\u003econtains\u003c/em\u003e(\u0026quot;/postcodes\u0026quot;)) {\n                   MockResponse()\n                      .setResponseCode(200)\n                      .setBody(response)\n                } else {\n                    MockResponse().setResponseCode(404)\n                }\n        }\n    \u003cstrong\u003e}\u003c/strong\u003e\n\n    @BindValue\n    @JvmField\n    val baseUrl: HttpUrl = server.url(\u0026quot;/\u0026quot;)\n\n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }\n\n    @After\n    fun clear() {\n        server.shutdown()\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis time instead of using \u003cstrong\u003eserver.enqueue(response)\u003c/strong\u003e we use a Dispatcher object. It can be useful when we have more than one request in the test and we want to configure them all in a one place.\nWe can distinguish different requests by the \u003cstrong\u003erequest.path \u003c/strong\u003eproperty.\u003c/p\u003e\u003cp\u003eRun you test - it is passing right now.\u003c/p\u003e\u003cp\u003eCongratulations, you have created one feature of your application using Test Driven Development!\u003c/p\u003e\u003cp\u003eNow try to use TDD yourself and add more features to this application.\u003c/p\u003e\u003cp\u003eThe full source code of this codelab is available \u003ca href=\"https://github.com/netguru/android-test-driven-development\"\u003ehere\u003c/a\u003e.\u003c/p\u003e","structured_body":{"entityMap":{"0":{"type":"LINK","mutability":"MUTABLE","data":{"url":"https://github.com/netguru/android-test-driven-development","text":"here"}}},"blocks":[{"key":"cjhpn","text":"The final step is to go back to the acceptance test and make it pass. It will be very similar to the MainActivityTest, however this time we will use Espresso and run the test on a real device.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ekcfb","text":"Adding required dependencies","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"co8ig","text":"We need to duplicate some libraries, that were previously used only for unit tests:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4kjhu","text":"dependencies {\n...\n androidTestImplementation \"com.google.dagger:hilt-android-testing:$hilt_version\"\nkaptAndroidTest \"com.google.dagger:hilt-android-compiler:$hilt_version\"\nandroidTestImplementation \"com.squareup.okhttp3:mockwebserver:$okhttp_version\"\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"CODE"},{"offset":251,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"f7nfk","text":"Overriding configuration for espresso test","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":0,"length":42,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"a994v","text":"Thanks to Hilt great testing support, the setup of the test will be very easy. First we need to create a custom test runner, which will use HiltTestApplication as a default Application class for tests (it's analogous to using it in the Robolectric annotation):","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":140,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ahe48","text":"class HiltTestRunner : AndroidJUnitRunner() {\n    override fun newApplication(\n        cl: ClassLoader?, \n        name: String?,\n        context: Context?\n    ): Application = \n        super.newApplication(\n            cl, \n            HiltTestApplication::class.java.name, \n            context\n        )\n    }\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":263,"length":4,"style":"ITALIC"},{"offset":268,"length":4,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"946c2","text":"Then we need to register this runner in the app-level gradle file, replacing the default one:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bo6bm","text":"defaultConfig {\n    ...\n    testInstrumentationRunner \n\"{your_package}.HiltTestRunner\"\n}","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":14,"length":1,"style":"BOLD"},{"offset":16,"length":4,"style":"BOLD"},{"offset":87,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"em5sf","text":"For this test we will also mock the responses with the MockWebServer, because real API calls can sometimes take longer than usual and can make our tests non-deterministic.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":55,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8ttn6","text":"However, the problem with MockWebServer in tests run on a device is that it uses by default plain http requests, and starting from Android 8 such requests are automatically blocked, allowing only https. \nBecause of that, we need to tell the system, that it should allow http requests for localhost subdomain, otherwise this test would always fail on any device using Android 8 or any higher.\nWe can do it by defining a network config file under res/xml directory:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":26,"length":13,"style":"BOLD"},{"offset":98,"length":4,"style":"BOLD"},{"offset":196,"length":5,"style":"BOLD"},{"offset":270,"length":4,"style":"BOLD"},{"offset":288,"length":9,"style":"BOLD"},{"offset":445,"length":7,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"b2re7","text":"\u003cnetwork-security-config\u003e\n    \u003cbase-config cleartextTrafficPermitted=\"false\" /\u003e\n    \u003cdomain-config cleartextTrafficPermitted=\"true\"\u003e\n        \u003cdomain includeSubdomains=\"true\"\u003elocalhost\u003c/domain\u003e\n    \u003c/domain-config\u003e\n\u003c/network-security-config\u003e","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"58ees","text":"Then we need to register this file in the Manifest file:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ahhg","text":"\u003capplication\n    ...\nandroid:networkSecurityConfig=\"@xml/network_security_config\"","type":"code-block","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f6q8i","text":"We will also use the HiltAndroidRule as before.\nAdditionally, we need the JSON file in this test as well, so create a new assets folder under androidTest directory and paste there the same JSON file we used before.\nTo read it, we will need a new method:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":21,"length":15,"style":"BOLD"},{"offset":122,"length":6,"style":"BOLD"},{"offset":142,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"8ataq","text":"private fun readAsset(path: String) =         \n    InstrumentationRegistry.getInstrumentation()\n        .context\n        .assets\n        .open(path)\n        .use { it.bufferedReader().readText() }","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":122,"length":6,"style":"ITALIC"},{"offset":133,"length":4,"style":"ITALIC"},{"offset":158,"length":4,"style":"ITALIC"},{"offset":167,"length":14,"style":"ITALIC"},{"offset":184,"length":8,"style":"ITALIC"},{"offset":162,"length":4,"style":"BOLD"},{"offset":195,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"b11ui","text":"Now we can finish the setup:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9nipf","text":"@HiltAndroidTest\n@UninstallModules(NetworkConfigModule::class)\nclass CityFinderAcceptanceTest {\n\n    @get:Rule\n    val hiltRule = HiltAndroidRule(this)\n\n    private val response = readAsset(\"response.json\")\n\n    private val server = MockWebServer().apply {\n        dispatcher = object : Dispatcher() {\n            override fun dispatch(\n                request: RecordedRequest\n            ): MockResponse = \n                if(request.path.orEmpty()\n                       .contains(\"/postcodes\")) {\n                   MockResponse()\n                      .setResponseCode(200)\n                      .setBody(response)\n                } else {\n                    MockResponse().setResponseCode(404)\n                }\n        }\n    }\n\n    @BindValue\n    @JvmField\n    val baseUrl: HttpUrl = server.url(\"/\")\n\n    @Before\n    fun setup() {\n        hiltRule.inject()\n    }\n\n    @After\n    fun clear() {\n        server.shutdown()\n    }\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":249,"length":6,"style":"ITALIC"},{"offset":441,"length":7,"style":"ITALIC"},{"offset":475,"length":8,"style":"ITALIC"},{"offset":255,"length":1,"style":"BOLD"},{"offset":257,"length":8,"style":"BOLD"},{"offset":733,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"f86hi","text":"This time instead of using server.enqueue(response) we use a Dispatcher object. It can be useful when we have more than one request in the test and we want to configure them all in a one place.\nWe can distinguish different requests by the request.path property.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":27,"length":24,"style":"BOLD"},{"offset":239,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"cqu1k","text":"Run you test - it is passing right now.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"arli2","text":"Congratulations, you have created one feature of your application using Test Driven Development!","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5cb1q","text":"Now try to use TDD yourself and add more features to this application.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4bvlf","text":"The full source code of this codelab is available here.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":50,"length":4,"key":0}],"data":{}}]},"feedback":null,"cover_slide_data":{}},"published_at":"2020-11-27T14:38:40.407+01:00","estimated_time":3,"attachments_count":0,"presentable":true,"external_id":null,"attachments":[]}],"attachments":[]}